ok i am having a web site platform building i will give the idea , detialing all and the persona,,, ttoal 3 pasted texts based on those u neeed to implement all the platform it should be ready fo productions live use so take a long time and impleemnta lll vey detaied lty ok u are opus i am alredy having the dat given the sonnet so dont give the same of u r base model ok for take idea and act advanced adn the brei fand the datat should be take the idea and we should build the website / paltforma for this we should be no one with all those integratiosn ofcusiing all the top palcesa dn tops integraurosn so we can now enter into this fats with more clollab and more integratiosn an tech and safety so while if even others enter they cant get these many integrations aas me so give in such so i will the top in the orld sokk..... all those like toml , json prd exectuitons all so i will keep all this data ins slow order to the opus in antigravity so i will directly implementntha plat form and in tegrat all the those featues and our ap pshould work for the beats withalll a "a live working protoye so the rela app platform ......{implementations, deep dive, unq 1-3}
bash
mkdir -p /home/claude/dharma-realty/{frontend/{app,components,hooks,services,utils,styles,lib,public},backend/{src/{routes,controllers,services,models,middleware,jobs,websockets,utils,config,integrations},prisma,tests},blockchain/{contracts,scripts,tests},docs,infrastructure}


Package · JSON


{
  "name": "dharma-realty",
  "version": "1.0.0",
  "description": "Revolutionary Real Estate Platform with Ancient Wisdom + Cutting-Edge Tech",
  "private": true,
  "workspaces": [
    "frontend",
    "backend",
    "blockchain"
  ],
  "scripts": {
    "dev": "concurrently \"npm run dev:backend\" \"npm run dev:frontend\"",
    "dev:frontend": "cd frontend && npm run dev",
    "dev:backend": "cd backend && npm run dev",
    "build": "npm run build:backend && npm run build:frontend",
    "build:frontend": "cd frontend && npm run build",
    "build:backend": "cd backend && npm run build",
    "start": "npm run start:backend",
    "start:backend": "cd backend && npm run start",
    "test": "npm run test:backend && npm run test:frontend",
    "test:backend": "cd backend && npm test",
    "test:frontend": "cd frontend && npm test",
    "migrate": "cd backend && npx prisma migrate dev",
    "migrate:deploy": "cd backend && npx prisma migrate deploy",
    "seed": "cd backend && npm run seed",
    "lint": "npm run lint:frontend && npm run lint:backend",
    "lint:frontend": "cd frontend && npm run lint",
    "lint:backend": "cd backend && npm run lint",
    "docker:up": "docker-compose up -d",
    "docker:down": "docker-compose down",
    "blockchain:compile": "cd blockchain && npx hardhat compile",
    "blockchain:deploy": "cd blockchain && npx hardhat run scripts/deploy.js"
  },
  "devDependencies": {
    "concurrently": "^8.2.2"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/dharma-realty/platform.git"
  },
  "author": "Dharma Realty",
  "license": "PROPRIETARY"
}


// Dharma Realty - Complete Database Schema
// Prisma Schema for PostgreSQL

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

Schema · PRISMA

// ==================== USER & AUTHENTICATION ====================

model User {
  id                   String              @id @default(uuid())
  email                String              @unique
  passwordHash         String?
  firstName            String
  lastName             String
  phone                String?
  profilePhotoUrl      String?
  userType             UserType            @default(BUYER)
  dateOfBirth          DateTime?
  birthTime            String?             // For astrological calculations
  birthPlace           String?             // For astrological calculations
  kycVerified          Boolean             @default(false)
  kycDocuments         Json?
  walletAddress        String?             // Blockchain wallet
  preferredLanguage    String              @default("en")
  timezone             String?
  doshaType            DoshaType?          // Ayurvedic constitution
  lifePathNumber       Int?                // Numerology
  createdAt            DateTime            @default(now())
  updatedAt            DateTime            @updatedAt
  lastLoginAt          DateTime?
  isActive             Boolean             @default(true)
  
  // Relations
  agent                Agent?
  savedSearches        SavedSearch[]
  favorites            Favorite[]
  leads                Lead[]              @relation("BuyerLeads")
  messages             Message[]           @relation("SentMessages")
  receivedMessages     Message[]           @relation("ReceivedMessages")
  reviews              Review[]            @relation("ReviewAuthor")
  propertyViews        PropertyView[]
  notifications        Notification[]
  karmicScores         KarmicScore[]       @relation("UserKarmic")
  referralsMade        Referral[]          @relation("Referrer")
  referralsReceived    Referral[]          @relation("Referred")
  daoVotes             DAOVote[]
  tokenBalance         TokenBalance?
  comparisons          PropertyComparison[]
  
  @@index([email])
  @@index([userType])
  @@index([walletAddress])
}

enum UserType {
  BUYER
  SELLER
  AGENT
  ADMIN
  INVESTOR
}

enum DoshaType {
  VATA
  PITTA
  KAPHA
  VATA_PITTA
  PITTA_KAPHA
  VATA_KAPHA
  TRIDOSHA
}

// ==================== AGENT ====================

model Agent {
  id                   String              @id @default(uuid())
  userId               String              @unique
  user                 User                @relation(fields: [userId], references: [id])
  licenseNumber        String
  licenseState         String
  licenseExpiry        DateTime
  brokerage            String?
  brokerageAddress     String?
  yearsExperience      Int
  specialties          String[]
  serviceAreas         String[]
  languages            String[]
  bio                  String?
  websiteUrl           String?
  linkedinUrl          String?
  rating               Float               @default(0)
  reviewCount          Int                 @default(0)
  subscriptionTier     SubscriptionTier    @default(FREE)
  subscriptionExpiry   DateTime?
  stripeCustomerId     String?
  stripeSubscriptionId String?
  verified             Boolean             @default(false)
  verificationDate     DateTime?
  ethicsScore          Float               @default(100) // Dharmic ethics score
  responseTime         Int?                // Average response time in minutes
  closingRate          Float?              // Percentage of leads converted
  totalSalesVolume     Decimal             @default(0) @db.Decimal(15, 2)
  certificationsJson   Json?               // Vastu, Feng Shui certifications
  createdAt            DateTime            @default(now())
  updatedAt            DateTime            @updatedAt
  
  // Relations
  properties           Property[]
  leads                Lead[]              @relation("AgentLeads")
  reviews              Review[]            @relation("AgentReviews")
  availability         AgentAvailability[]
  performanceMetrics   AgentPerformance[]
  
  @@index([licenseNumber])
  @@index([subscriptionTier])
  @@index([rating])
}

enum SubscriptionTier {
  FREE
  DHARMA        // $499/month
  KARMA         // $1,499/month
  ENLIGHTENED   // $4,999/month - Enterprise
}

model AgentAvailability {
  id          String    @id @default(uuid())
  agentId     String
  agent       Agent     @relation(fields: [agentId], references: [id])
  dayOfWeek   Int       // 0-6, Sunday-Saturday
  startTime   String    // HH:mm format
  endTime     String    // HH:mm format
  isAvailable Boolean   @default(true)
  
  @@unique([agentId, dayOfWeek, startTime])
}

model AgentPerformance {
  id              String    @id @default(uuid())
  agentId         String
  agent           Agent     @relation(fields: [agentId], references: [id])
  month           DateTime  @db.Date
  leadsReceived   Int       @default(0)
  leadsConverted  Int       @default(0)
  propertiesListed Int      @default(0)
  propertiesSold  Int       @default(0)
  totalVolume     Decimal   @default(0) @db.Decimal(15, 2)
  avgResponseTime Int?      // minutes
  avgRating       Float?
  
  @@unique([agentId, month])
}

// ==================== PROPERTY ====================

model Property {
  id                    String              @id @default(uuid())
  mlsId                 String?             @unique
  listingAgentId        String?
  listingAgent          Agent?              @relation(fields: [listingAgentId], references: [id])
  
  // Basic Info
  title                 String
  description           String              @db.Text
  propertyType          PropertyType
  listingType           ListingType
  status                PropertyStatus      @default(ACTIVE)
  
  // Location
  streetAddress         String
  unit                  String?
  city                  String
  state                 String
  zipCode               String
  country               String              @default("USA")
  latitude              Float
  longitude             Float
  neighborhoodId        String?
  neighborhood          Neighborhood?       @relation(fields: [neighborhoodId], references: [id])
  
  // Property Details
  price                 Decimal             @db.Decimal(15, 2)
  originalPrice         Decimal?            @db.Decimal(15, 2)
  pricePerSqft          Decimal?            @db.Decimal(10, 2)
  bedrooms              Int
  bathrooms             Float
  squareFeet            Int?
  lotSizeAcres          Float?
  yearBuilt             Int?
  stories               Int?
  parkingSpaces         Int?
  garageSpaces          Int?
  constructionDate      DateTime?           // For Kundali matching
  
  // Features
  features              String[]
  amenities             String[]
  appliances            String[]
  flooring              String[]
  heating               String[]
  cooling               String[]
  roofType              String?
  exteriorMaterial      String?
  foundationType        String?
  
  // Media
  photos                PropertyPhoto[]
  virtualTourUrl        String?
  videoUrl              String?
  floorPlanUrl          String?
  
  // Financial
  hoaFee                Decimal?            @db.Decimal(10, 2)
  hoaFrequency          String?             // monthly, quarterly, annual
  propertyTax           Decimal?            @db.Decimal(10, 2)
  taxYear               Int?
  estimatedMortgage     Decimal?            @db.Decimal(10, 2)
  
  // Dates
  listedDate            DateTime            @default(now())
  soldDate              DateTime?
  closingDate           DateTime?
  daysOnMarket          Int                 @default(0)
  
  // Stats
  viewCount             Int                 @default(0)
  favoriteCount         Int                 @default(0)
  inquiryCount          Int                 @default(0)
  
  // Blockchain
  blockchainTokenId     String?             @unique
  nftMinted             Boolean             @default(false)
  contractAddress       String?
  
  // Smart Home
  smartHomeScore        Int?                // 0-100
  smartHomeDevices      Json?
  
  // Timestamps
  createdAt             DateTime            @default(now())
  updatedAt             DateTime            @updatedAt
  
  // Relations
  priceHistory          PriceHistory[]
  vastu Analysis        VastuAnalysis?
  fengShuiAnalysis      FengShuiAnalysis?
  climateAnalysis       ClimateAnalysis?
  environmentalData     EnvironmentalData?
  blockchainHistory     BlockchainRecord[]
  iotSensors            IoTSensor[]
  leads                 Lead[]
  favorites             Favorite[]
  views                 PropertyView[]
  openHouses            OpenHouse[]
  inspections           Inspection[]
  documents             PropertyDocument[]
  comparisons           PropertyComparison[]
  fractionalShares      FractionalShare[]
  maintenanceRecords    MaintenanceRecord[]
  energyAnalysis        EnergyAnalysis?
  sacredGeometry        SacredGeometryAnalysis?
  landEnergy            LandEnergyAssessment?
  
  @@index([city, state])
  @@index([price])
  @@index([propertyType])
  @@index([status])
  @@index([latitude, longitude])
  @@index([bedrooms, bathrooms])
}

enum PropertyType {
  HOUSE
  CONDO
  TOWNHOUSE
  APARTMENT
  LAND
  MULTI_FAMILY
  COMMERCIAL
  VILLA
  PENTHOUSE
  FARMHOUSE
  ASHRAM         // Spiritual retreat
  PLOT           // Land for development
}

enum ListingType {
  SALE
  RENT
  LEASE
  AUCTION
}

enum PropertyStatus {
  ACTIVE
  PENDING
  SOLD
  OFF_MARKET
  COMING_SOON
  WITHDRAWN
}

model PropertyPhoto {
  id          String    @id @default(uuid())
  propertyId  String
  property    Property  @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  url         String
  thumbnailUrl String?
  caption     String?
  roomType    String?
  orderIndex  Int       @default(0)
  isPrimary   Boolean   @default(false)
  aiVerified  Boolean   @default(false) // Deepfake detection passed
  createdAt   DateTime  @default(now())
  
  @@index([propertyId, orderIndex])
}

model PriceHistory {
  id            String    @id @default(uuid())
  propertyId    String
  property      Property  @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  previousPrice Decimal   @db.Decimal(15, 2)
  newPrice      Decimal   @db.Decimal(15, 2)
  changeDate    DateTime  @default(now())
  changeReason  String?
  
  @@index([propertyId, changeDate])
}

// ==================== VASTU SHASTRA ====================

model VastuAnalysis {
  id                    String    @id @default(uuid())
  propertyId            String    @unique
  property              Property  @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  
  // Overall Score
  overallScore          Int       // 0-100
  grade                 String    // A+, A, B+, B, C, D, F
  
  // Directional Analysis
  entranceDirection     String    // N, NE, E, SE, S, SW, W, NW
  entranceScore         Int
  plotOrientation       String
  plotScore             Int
  
  // Zone Scores (0-100)
  northEastScore        Int       // Ishaan - Water, Wealth
  eastScore             Int       // Indra - Sun, Health
  southEastScore        Int       // Agni - Fire, Kitchen
  southScore            Int       // Yama - Death, Avoid bedrooms
  southWestScore        Int       // Nairutya - Master bedroom
  westScore             Int       // Varuna - Water storage
  northWestScore        Int       // Vayu - Air, Guests
  northScore            Int       // Kubera - Wealth
  centerScore           Int       // Brahmasthan - Should be open
  
  // Room Placement Analysis
  kitchenPlacement      Json      // {correct: boolean, current: string, ideal: string}
  masterBedroomPlacement Json
  bathroomPlacement     Json
  poojaRoomPlacement    Json
  studyRoomPlacement    Json
  livingRoomPlacement   Json
  
  // Defects Found
  defects               Json[]    // Array of defect objects
  criticalDefects       Int       @default(0)
  moderateDefects       Int       @default(0)
  minorDefects          Int       @default(0)
  
  // Remedies
  remedies              Json[]    // Array of remedy objects with type, cost, effectiveness
  totalRemedyCost       Decimal?  @db.Decimal(10, 2)
  
  // Additional Analysis
  slopeAnalysis         Json?     // Land slope direction and impact
  waterSourceAnalysis   Json?     // Underground water, tanks, etc.
  staircaseAnalysis     Json?     // Direction, clockwise/anticlockwise
  beamAnalysis          Json?     // Overhead beams in sleeping areas
  
  // Certification
  certificateUrl        String?
  blockchainTxHash      String?
  
  analyzedAt            DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  
  @@index([overallScore])
}

// ==================== FENG SHUI ====================

model FengShuiAnalysis {
  id                    String    @id @default(uuid())
  propertyId            String    @unique
  property              Property  @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  
  overallScore          Int       // 0-100
  
  // Bagua Map Analysis
  baguaAnalysis         Json      // 8 areas: wealth, fame, love, family, health, creativity, knowledge, career
  
  // Flying Stars
  flyingStarsChart      Json      // 9 palace grid with star numbers
  currentPeriod         Int       // Period 9 (2024-2043)
  mountainStar          Int
  waterStar             Int
  
  // Five Elements Balance
  woodElement           Int       // 0-100
  fireElement           Int
  earthElement          Int
  metalElement          Int
  waterElement          Int
  elementBalance        String    // Balanced, Wood-deficient, Fire-excess, etc.
  
  // Water Dragon Formula
  waterDragonScore      Int?
  waterFeatureRecommendation Json?
  
  // Chi Flow
  chiFlowScore          Int
  blockedAreas          String[]
  recommendations       Json[]
  
  analyzedAt            DateTime  @default(now())
}

// ==================== SACRED GEOMETRY ====================

model SacredGeometryAnalysis {
  id                    String    @id @default(uuid())
  propertyId            String    @unique
  property              Property  @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  
  overallScore          Int       // 0-100
  
  // Golden Ratio Analysis
  goldenRatioScore      Int
  goldenRatioDetails    Json      // Room proportions, architectural elements
  
  // Fibonacci Presence
  fibonacciScore        Int
  fibonacciElements     Json[]
  
  // Mandala Alignment
  mandalaScore          Int
  centerPointEnergy     Int
  
  // Yantra Compatibility
  recommendedYantras    Json[]    // Sri Yantra, Kubera Yantra, etc.
  yantraPlacement       Json      // Where to place yantras
  
  // Platonic Solids
  geometricHarmony      Int
  
  analyzedAt            DateTime  @default(now())
}

// ==================== LAND ENERGY (BHUMI SHUDDHI) ====================

model LandEnergyAssessment {
  id                    String    @id @default(uuid())
  propertyId            String    @unique
  property              Property  @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  
  overallScore          Int       // 0-100
  
  // Historical Analysis
  historicalUse         Json[]    // Past uses: temple, burial, hospital, etc.
  historicalScore       Int
  
  // Geological Features
  leyLineProximity      Float?    // Distance to nearest ley line in km
  energyVortex          Boolean   @default(false)
  geologicalFormations  Json?
  
  // Water Analysis
  waterTableDepth       Float?    // meters
  waterQuality          String?
  naturalSprings        Boolean   @default(false)
  
  // Soil Analysis
  soilComposition       Json?
  soilFertility         Int?      // 0-100
  contamination         Boolean   @default(false)
  contaminationType     String?
  
  // Tree Analysis
  ancientTrees          Int       @default(0)
  treeSpecies           String[]
  treeEnergyScore       Int?
  
  // Cosmic Alignment
  cardinalAlignment     Json?     // How well aligned with cardinal directions
  celestialEvents       Json?     // Sunrise/sunset alignment on solstices
  
  analyzedAt            DateTime  @default(now())
}

// ==================== CLIMATE ANALYSIS ====================

model ClimateAnalysis {
  id                    String    @id @default(uuid())
  propertyId            String    @unique
  property              Property  @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  
  overallRiskScore      Int       // 0-100 (higher = more risk)
  riskGrade             String    // LOW, MODERATE, HIGH, EXTREME
  
  // Flood Risk
  currentFloodZone      String?   // FEMA zone
  floodRisk2030         Int
  floodRisk2050         Int
  floodRisk2075         Int
  floodRisk2100         Int
  seaLevelRiseCm        Json      // {2030: 15, 2050: 45, 2100: 122}
  
  // Wildfire Risk
  wildfireRisk          Int
  fireHistoryWithin10Mi Int       // Number of fires in last 20 years
  vegetationDensity     String?
  
  // Hurricane/Tornado
  hurricaneRisk         Int
  tornadoRisk           Int
  historicalStorms      Int
  
  // Heat Risk
  currentExtremeDays    Int       // Days >95°F per year
  projectedExtreme2050  Int
  heatIslandEffect      Float?    // Temperature increase due to urbanization
  
  // Drought
  droughtRisk           Int
  waterStressIndex      Float?
  aquiferDepletionRate  Float?
  
  // Seismic
  seismicRisk           Int
  nearestFaultMi        Float?
  liquefactionPotential String?
  
  // Insurance Projections
  insuranceCurrent      Decimal?  @db.Decimal(10, 2)
  insurance2030         Decimal?  @db.Decimal(10, 2)
  insurance2050         Decimal?  @db.Decimal(10, 2)
  insurabilityStatus    String?   // INSURABLE, AT_RISK, UNINSURABLE
  
  // Mitigation Strategies
  mitigationStrategies  Json[]
  
  // Data Sources
  dataSources           String[]
  analysisDate          DateTime  @default(now())
  
  @@index([overallRiskScore])
}

// ==================== ENVIRONMENTAL DATA (IoT) ====================

model EnvironmentalData {
  id                    String    @id @default(uuid())
  propertyId            String    @unique
  property              Property  @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  
  // Air Quality
  aqiCurrent            Int?
  pm25                  Float?
  pm10                  Float?
  co2                   Float?
  vocs                  Float?
  ozone                 Float?
  airQualityGrade       String?
  
  // Water Quality
  tds                   Float?    // Total Dissolved Solids
  ph                    Float?
  leadLevel             Float?
  bacteriaPresent       Boolean?
  waterGrade            String?
  
  // EMF Radiation
  emfLevel              Float?    // μT (microteslas)
  emfGrade              String?
  nearestCellTower      Float?    // Distance in meters
  powerLineProximity    Float?
  
  // Noise
  avgNoiseDecibels      Float?
  peakNoiseDecibels     Float?
  noiseGrade            String?
  noiseSources          String[]
  
  // Radon
  radonLevel            Float?    // pCi/L
  radonRisk             String?
  
  // Mold & Humidity
  avgHumidity           Float?
  moldRisk              String?
  
  // Light Pollution
  lightPollutionIndex   Float?    // Bortle scale
  stargazingQuality     String?
  
  lastUpdated           DateTime  @default(now())
  
  @@index([aqiCurrent])
}

model IoTSensor {
  id              String    @id @default(uuid())
  propertyId      String
  property        Property  @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  sensorType      SensorType
  deviceId        String    @unique
  manufacturer    String?
  model           String?
  installDate     DateTime?
  lastReading     DateTime?
  status          String    @default("ACTIVE")
  readings        IoTReading[]
  
  @@index([propertyId, sensorType])
}

enum SensorType {
  AIR_QUALITY
  WATER_QUALITY
  EMF
  NOISE
  RADON
  HUMIDITY
  TEMPERATURE
  SEISMIC
  WEATHER
  SOIL
  WILDLIFE
  TRAFFIC
}

model IoTReading {
  id          String    @id @default(uuid())
  sensorId    String
  sensor      IoTSensor @relation(fields: [sensorId], references: [id], onDelete: Cascade)
  timestamp   DateTime  @default(now())
  value       Float
  unit        String
  metadata    Json?
  
  @@index([sensorId, timestamp])
}

// ==================== ENERGY ANALYSIS ====================

model EnergyAnalysis {
  id                    String    @id @default(uuid())
  propertyId            String    @unique
  property              Property  @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  
  // Current Consumption
  annualElectricityKwh  Float?
  annualGasTherms       Float?
  annualWaterGallons    Float?
  carbonFootprintTons   Float?
  
  // Solar Potential
  solarPotentialKwh     Float?
  roofAreaSqft          Float?
  roofOrientation       String?
  shadeAnalysis         Json?
  solarROIYears         Float?
  
  // Efficiency Score
  energyEfficiencyScore Int?      // 0-100
  energyStarRating      String?
  
  // Recommendations
  recommendations       Json[]    // Solar, insulation, HVAC, etc.
  potentialSavings      Decimal?  @db.Decimal(10, 2)
  
  analyzedAt            DateTime  @default(now())
}

// ==================== BLOCKCHAIN ====================

model BlockchainRecord {
  id              String    @id @default(uuid())
  propertyId      String
  property        Property  @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  recordType      BlockchainRecordType
  transactionHash String    @unique
  blockNumber     BigInt
  chainId         Int       @default(137) // Polygon
  ipfsHash        String?   // For document storage
  data            Json
  verified        Boolean   @default(false)
  createdAt       DateTime  @default(now())
  
  @@index([propertyId, recordType])
  @@index([transactionHash])
}

enum BlockchainRecordType {
  OWNERSHIP_TRANSFER
  RENOVATION
  INSPECTION
  INSURANCE_CLAIM
  DISPUTE
  LIEN
  APPRAISAL
  MAINTENANCE
  VASTU_CERTIFICATION
  CLIMATE_REPORT
}

model FractionalShare {
  id              String    @id @default(uuid())
  propertyId      String
  property        Property  @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  ownerAddress    String    // Wallet address
  sharePercentage Float
  purchasePrice   Decimal   @db.Decimal(15, 2)
  purchaseDate    DateTime
  tokenId         String?   // NFT token ID
  status          String    @default("ACTIVE")
  
  @@unique([propertyId, ownerAddress])
  @@index([ownerAddress])
}

// ==================== ASTROLOGICAL TIMING ====================

model AuspiciousTiming {
  id              String    @id @default(uuid())
  userId          String
  propertyId      String?
  eventType       AstroEventType
  
  // Birth Chart (if provided)
  birthChart      Json?     // Kundali data
  
  // Recommended Windows
  viewingWindows  Json[]    // Array of date-time ranges
  offerWindows    Json[]
  closingWindows  Json[]
  movingWindows   Json[]
  
  // Muhurat Details
  panchang        Json?     // Tithi, Nakshatra, Yoga, Karana
  planetaryPositions Json?
  
  // Warnings
  inauspiciousDates Json[]  // Rahu Kaal, eclipses, etc.
  
  generatedAt     DateTime  @default(now())
  validUntil      DateTime
  
  @@index([userId, eventType])
}

enum AstroEventType {
  PROPERTY_VIEWING
  MAKING_OFFER
  SIGNING_CONTRACT
  CLOSING
  GRIHA_PRAVESH  // Housewarming
  RENOVATION_START
}

// ==================== NEIGHBORHOOD ====================

model Neighborhood {
  id                    String    @id @default(uuid())
  name                  String
  city                  String
  state                 String
  country               String    @default("USA")
  boundaries            Json?     // GeoJSON polygon
  
  // Demographics
  population            Int?
  medianAge             Float?
  medianIncome          Decimal?  @db.Decimal(10, 2)
  demographicsJson      Json?
  
  // Real Estate
  medianHomePrice       Decimal?  @db.Decimal(15, 2)
  priceTrend6Month      Float?
  priceTrend1Year       Float?
  avgDaysOnMarket       Int?
  
  // Scores
  walkabilityScore      Int?      // 0-100
  transitScore          Int?
  bikeScore             Int?
  crimeIndex            Int?      // Lower is safer
  schoolRating          Float?    // 0-10
  
  // Community
  dominantCulture       String?
  communityEvents       Json?
  religiousPlaces       Json?     // Temples, churches, mosques
  
  // Amenities
  nearbyAmenities       Json?
  restaurants           Int?
  parks                 Int?
  gyms                  Int?
  
  // Properties
  properties            Property[]
  
  updatedAt             DateTime  @updatedAt
  
  @@unique([name, city, state])
  @@index([city, state])
}

// ==================== LEADS & COMMUNICATION ====================

model Lead {
  id              String    @id @default(uuid())
  propertyId      String
  property        Property  @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  agentId         String?
  agent           Agent?    @relation("AgentLeads", fields: [agentId], references: [id])
  userId          String?
  user            User?     @relation("BuyerLeads", fields: [userId], references: [id])
  
  // Contact Info (for anonymous leads)
  name            String
  email           String
  phone           String?
  message         String?   @db.Text
  
  // Status
  status          LeadStatus @default(NEW)
  priority        LeadPriority @default(MEDIUM)
  score           Int?      // AI-generated lead score 0-100
  
  // Source
  source          LeadSource @default(INQUIRY)
  utmSource       String?
  utmMedium       String?
  utmCampaign     String?
  
  // Activity
  propertiesViewed Int      @default(0)
  timeOnSite      Int?      // seconds
  lastActivity    DateTime?
  
  // Follow-up
  followUpDate    DateTime?
  notes           String?   @db.Text
  
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  
  // Relations
  messages        Message[]
  showings        Showing[]
  
  @@index([agentId, status])
  @@index([propertyId])
  @@index([email])
}

enum LeadStatus {
  NEW
  CONTACTED
  QUALIFIED
  SHOWING_SCHEDULED
  OFFER_MADE
  NEGOTIATING
  CLOSED_WON
  CLOSED_LOST
  NURTURING
}

enum LeadPriority {
  HOT
  WARM
  MEDIUM
  COLD
}

enum LeadSource {
  INQUIRY
  WALK_IN
  REFERRAL
  ADVERTISING
  SOCIAL_MEDIA
  OPEN_HOUSE
  AI_MATCHED
}

model Message {
  id            String    @id @default(uuid())
  leadId        String?
  lead          Lead?     @relation(fields: [leadId], references: [id], onDelete: Cascade)
  senderId      String
  sender        User      @relation("SentMessages", fields: [senderId], references: [id])
  recipientId   String
  recipient     User      @relation("ReceivedMessages", fields: [recipientId], references: [id])
  content       String    @db.Text
  messageType   MessageType @default(TEXT)
  attachmentUrl String?
  read          Boolean   @default(false)
  readAt        DateTime?
  translated    Boolean   @default(false)
  originalLang  String?
  translatedContent String? @db.Text
  createdAt     DateTime  @default(now())
  
  @@index([leadId])
  @@index([senderId])
  @@index([recipientId])
}

enum MessageType {
  TEXT
  IMAGE
  DOCUMENT
  VOICE
  VIDEO
}

model Showing {
  id            String    @id @default(uuid())
  leadId        String
  lead          Lead      @relation(fields: [leadId], references: [id], onDelete: Cascade)
  scheduledAt   DateTime
  duration      Int       @default(30) // minutes
  type          ShowingType @default(IN_PERSON)
  status        ShowingStatus @default(SCHEDULED)
  notes         String?
  feedback      String?
  rating        Int?      // 1-5 buyer's rating of property
  createdAt     DateTime  @default(now())
  
  @@index([leadId, scheduledAt])
}

enum ShowingType {
  IN_PERSON
  VIRTUAL
  LIVE_VIDEO
  SELF_GUIDED
}

enum ShowingStatus {
  SCHEDULED
  CONFIRMED
  COMPLETED
  CANCELLED
  NO_SHOW
}

// ==================== OPEN HOUSES ====================

model OpenHouse {
  id            String    @id @default(uuid())
  propertyId    String
  property      Property  @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  startTime     DateTime
  endTime       DateTime
  type          OpenHouseType @default(IN_PERSON)
  virtualLink   String?
  notes         String?
  maxAttendees  Int?
  registrations OpenHouseRegistration[]
  createdAt     DateTime  @default(now())
  
  @@index([propertyId, startTime])
}

enum OpenHouseType {
  IN_PERSON
  VIRTUAL
  HYBRID
  METAVERSE
}

model OpenHouseRegistration {
  id          String    @id @default(uuid())
  openHouseId String
  openHouse   OpenHouse @relation(fields: [openHouseId], references: [id], onDelete: Cascade)
  name        String
  email       String
  phone       String?
  attended    Boolean   @default(false)
  createdAt   DateTime  @default(now())
  
  @@unique([openHouseId, email])
}

// ==================== SAVED SEARCHES & FAVORITES ====================

model SavedSearch {
  id              String    @id @default(uuid())
  userId          String
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  name            String
  filters         Json      // All search criteria
  alertFrequency  AlertFrequency @default(INSTANT)
  isActive        Boolean   @default(true)
  lastAlertAt     DateTime?
  matchCount      Int       @default(0)
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  
  @@index([userId, isActive])
}

enum AlertFrequency {
  INSTANT
  DAILY
  WEEKLY
  NEVER
}

model Favorite {
  id          String    @id @default(uuid())
  userId      String
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  propertyId  String
  property    Property  @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  notes       String?   @db.Text
  createdAt   DateTime  @default(now())
  
  @@unique([userId, propertyId])
  @@index([userId])
}

model PropertyView {
  id          String    @id @default(uuid())
  userId      String?
  user        User?     @relation(fields: [userId], references: [id])
  propertyId  String
  property    Property  @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  sessionId   String?   // For anonymous tracking
  duration    Int?      // seconds
  source      String?
  createdAt   DateTime  @default(now())
  
  @@index([propertyId, createdAt])
  @@index([userId])
}

model PropertyComparison {
  id          String    @id @default(uuid())
  userId      String
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  propertyId  String
  property    Property  @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  groupId     String    // Groups properties being compared
  createdAt   DateTime  @default(now())
  
  @@unique([userId, propertyId, groupId])
  @@index([userId, groupId])
}

// ==================== REVIEWS ====================

model Review {
  id              String    @id @default(uuid())
  agentId         String
  agent           Agent     @relation("AgentReviews", fields: [agentId], references: [id], onDelete: Cascade)
  reviewerId      String
  reviewer        User      @relation("ReviewAuthor", fields: [reviewerId], references: [id])
  rating          Int       // 1-5
  title           String?
  comment         String    @db.Text
  transactionType TransactionType
  verified        Boolean   @default(false)
  verificationHash String?  // Blockchain verification
  helpful         Int       @default(0)
  response        String?   @db.Text // Agent's response
  responseAt      DateTime?
  createdAt       DateTime  @default(now())
  
  @@index([agentId, rating])
}

enum TransactionType {
  BOUGHT
  SOLD
  RENTED
  LEASED
}

// ==================== INSPECTIONS & DOCUMENTS ====================

model Inspection {
  id              String    @id @default(uuid())
  propertyId      String
  property        Property  @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  inspectorName   String
  inspectorLicense String?
  inspectorCompany String?
  inspectionType  InspectionType
  scheduledAt     DateTime
  completedAt     DateTime?
  status          String    @default("SCHEDULED")
  findings        Json?
  overallGrade    String?
  reportUrl       String?
  blockchainHash  String?
  createdAt       DateTime  @default(now())
  
  @@index([propertyId, inspectionType])
}

enum InspectionType {
  GENERAL
  STRUCTURAL
  ELECTRICAL
  PLUMBING
  HVAC
  ROOF
  PEST
  RADON
  MOLD
  LEAD
  ASBESTOS
  POOL
  SEPTIC
  WELL
  VASTU         // Vastu compliance inspection
  ENERGY
}

model PropertyDocument {
  id            String    @id @default(uuid())
  propertyId    String
  property      Property  @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  documentType  DocumentType
  title         String
  description   String?
  fileUrl       String
  fileSize      Int       // bytes
  mimeType      String
  ipfsHash      String?   // For blockchain storage
  uploadedBy    String
  isPublic      Boolean   @default(false)
  expiresAt     DateTime?
  createdAt     DateTime  @default(now())
  
  @@index([propertyId, documentType])
}

enum DocumentType {
  DEED
  TITLE
  SURVEY
  FLOOR_PLAN
  INSPECTION_REPORT
  APPRAISAL
  TAX_RECORD
  HOA_DOCS
  WARRANTY
  PERMIT
  INSURANCE
  DISCLOSURE
  CONTRACT
  VASTU_CERTIFICATE
  CLIMATE_REPORT
  OTHER
}

// ==================== MAINTENANCE ====================

model MaintenanceRecord {
  id              String    @id @default(uuid())
  propertyId      String
  property        Property  @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  maintenanceType String
  description     String    @db.Text
  cost            Decimal?  @db.Decimal(10, 2)
  contractor      String?
  contractorPhone String?
  scheduledAt     DateTime?
  completedAt     DateTime?
  nextDueAt       DateTime?
  warrantyExpiry  DateTime?
  receiptUrl      String?
  notes           String?
  blockchainHash  String?
  createdAt       DateTime  @default(now())
  
  @@index([propertyId, maintenanceType])
}

// ==================== NOTIFICATIONS ====================

model Notification {
  id            String    @id @default(uuid())
  userId        String
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  type          NotificationType
  title         String
  message       String
  data          Json?     // Additional data
  read          Boolean   @default(false)
  readAt        DateTime?
  actionUrl     String?
  createdAt     DateTime  @default(now())
  
  @@index([userId, read])
  @@index([userId, createdAt])
}

enum NotificationType {
  NEW_LISTING
  PRICE_CHANGE
  NEW_LEAD
  MESSAGE
  SHOWING_REMINDER
  OPEN_HOUSE
  OFFER_RECEIVED
  DOCUMENT_READY
  AUSPICIOUS_DATE
  CLIMATE_ALERT
  SENSOR_ALERT
  SYSTEM
}

// ==================== KARMIC SCORING (DHARMIC REPUTATION) ====================

model KarmicScore {
  id              String    @id @default(uuid())
  userId          String
  user            User      @relation("UserKarmic", fields: [userId], references: [id], onDelete: Cascade)
  overallScore    Int       // 0-1000 (higher is better)
  
  // Score Components
  honestyScore    Int       // Accurate listings, no hidden defects
  responsivenessScore Int   // Quick replies, keeps appointments
  fairnessScore   Int       // Fair pricing, ethical negotiations
  communityScore  Int       // Helps others, positive reviews
  environmentalScore Int    // Eco-friendly practices
  
  // Activity Tracking
  totalTransactions Int     @default(0)
  disputesInitiated Int     @default(0)
  disputesAgainst Int       @default(0)
  reviewsReceived Int       @default(0)
  avgRating       Float?
  
  // Badges
  badges          String[]  // ["VASTU_CERTIFIED", "ECO_WARRIOR", "TOP_RATED"]
  
  // Penalties
  warnings        Int       @default(0)
  suspensions     Int       @default(0)
  
  lastCalculated  DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  
  @@unique([userId])
  @@index([overallScore])
}

// ==================== DAO GOVERNANCE ====================

model DAOProposal {
  id              String    @id @default(uuid())
  title           String
  description     String    @db.Text
  proposerAddress String    // Wallet address
  proposalType    ProposalType
  status          ProposalStatus @default(ACTIVE)
  
  // Voting
  votesFor        Int       @default(0)
  votesAgainst    Int       @default(0)
  votesAbstain    Int       @default(0)
  quorum          Int       // Minimum votes needed
  
  // Timing
  startTime       DateTime  @default(now())
  endTime         DateTime
  executedAt      DateTime?
  
  // Execution
  executionData   Json?     // Data for executing proposal
  transactionHash String?
  
  votes           DAOVote[]
  createdAt       DateTime  @default(now())
  
  @@index([status, endTime])
}

enum ProposalType {
  PLATFORM_FEE_CHANGE
  NEW_FEATURE
  POLICY_CHANGE
  COMMUNITY_FUND
  PARTNERSHIP
  EMERGENCY
}

enum ProposalStatus {
  ACTIVE
  PASSED
  REJECTED
  EXECUTED
  CANCELLED
}

model DAOVote {
  id          String    @id @default(uuid())
  proposalId  String
  proposal    DAOProposal @relation(fields: [proposalId], references: [id], onDelete: Cascade)
  userId      String
  user        User      @relation(fields: [userId], references: [id])
  vote        VoteType
  votePower   Int       @default(1) // Based on token holdings
  txHash      String?
  createdAt   DateTime  @default(now())
  
  @@unique([proposalId, userId])
  @@index([proposalId])
}

enum VoteType {
  FOR
  AGAINST
  ABSTAIN
}

// ==================== TOKEN ECONOMY ====================

model TokenBalance {
  id          String    @id @default(uuid())
  userId      String    @unique
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  balance     Decimal   @default(0) @db.Decimal(18, 8)
  stakedAmount Decimal  @default(0) @db.Decimal(18, 8)
  lockedAmount Decimal  @default(0) @db.Decimal(18, 8)
  totalEarned Decimal   @default(0) @db.Decimal(18, 8)
  lastUpdated DateTime  @default(now())
  
  transactions TokenTransaction[]
}

model TokenTransaction {
  id            String    @id @default(uuid())
  balanceId     String
  balance       TokenBalance @relation(fields: [balanceId], references: [id], onDelete: Cascade)
  type          TokenTransactionType
  amount        Decimal   @db.Decimal(18, 8)
  description   String?
  referenceId   String?   // Related entity ID
  txHash        String?   // Blockchain tx
  createdAt     DateTime  @default(now())
  
  @@index([balanceId, createdAt])
}

enum TokenTransactionType {
  REWARD
  REFERRAL_BONUS
  STAKING_REWARD
  PLATFORM_FEE
  WITHDRAWAL
  PURCHASE
  TRANSFER
}

// ==================== REFERRALS ====================

model Referral {
  id            String    @id @default(uuid())
  referrerId    String
  referrer      User      @relation("Referrer", fields: [referrerId], references: [id])
  referredId    String
  referred      User      @relation("Referred", fields: [referredId], references: [id])
  referralCode  String
  status        ReferralStatus @default(PENDING)
  rewardAmount  Decimal?  @db.Decimal(10, 2)
  rewardPaidAt  DateTime?
  createdAt     DateTime  @default(now())
  
  @@unique([referrerId, referredId])
  @@index([referralCode])
}

enum ReferralStatus {
  PENDING
  QUALIFIED
  REWARDED
  EXPIRED
}

// ==================== VALUATIONS ====================

model PropertyValuation {
  id              String    @id @default(uuid())
  propertyId      String?
  address         String
  latitude        Float?
  longitude       Float?
  
  // Input Data
  bedrooms        Int
  bathrooms       Float
  squareFeet      Int
  yearBuilt       Int?
  propertyType    String
  features        String[]
  
  // Valuation Results
  estimatedValue  Decimal   @db.Decimal(15, 2)
  confidenceLow   Decimal   @db.Decimal(15, 2)
  confidenceHigh  Decimal   @db.Decimal(15, 2)
  confidenceScore Float     // 0-1
  
  // Adjustments
  vastuAdjustment Float?    // % adjustment for Vastu score
  climateAdjustment Float?  // % adjustment for climate risk
  
  // Comparables
  comparables     Json[]
  
  // Model Info
  modelVersion    String
  createdAt       DateTime  @default(now())
  
  @@index([address])
}

// ==================== AI NEGOTIATIONS ====================

model AIANegotiation {
  id              String    @id @default(uuid())
  userId          String
  propertyId      String
  status          NegotiationStatus @default(ANALYZING)
  
  // Analysis
  marketAnalysis  Json?     // Comparable sales, market trends
  sellerAnalysis  Json?     // Motivation indicators
  propertyAnalysis Json?    // Condition, defects
  
  // Strategy
  recommendedOffer Decimal?  @db.Decimal(15, 2)
  maxRecommended  Decimal?  @db.Decimal(15, 2)
  strategy        Json?     // Negotiation tactics
  
  // Offer History
  offers          Json[]    // Array of offer/counter-offer
  currentOffer    Decimal?  @db.Decimal(15, 2)
  
  // Outcome
  finalPrice      Decimal?  @db.Decimal(15, 2)
  savingsAmount   Decimal?  @db.Decimal(15, 2)
  
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  
  @@index([userId, status])
}

enum NegotiationStatus {
  ANALYZING
  STRATEGY_READY
  OFFER_SENT
  COUNTER_RECEIVED
  NEGOTIATING
  ACCEPTED
  REJECTED
  EXPIRED
}

// ==================== SYSTEM ====================

model AuditLog {
  id          String    @id @default(uuid())
  userId      String?
  action      String
  entityType  String
  entityId    String?
  oldValue    Json?
  newValue    Json?
  ipAddress   String?
  userAgent   String?
  createdAt   DateTime  @default(now())
  
  @@index([userId, createdAt])
  @@index([entityType, entityId])
}

model SystemSetting {
  id          String    @id @default(uuid())
  key         String    @unique
  value       Json
  description String?
  updatedAt   DateTime  @updatedAt
}


Package · JSON

{
  "name": "dharma-realty-backend",
  "version": "1.0.0",
  "description": "Dharma Realty Platform - Backend API",
  "main": "dist/server.js",
  "scripts": {
    "dev": "ts-node-dev --respawn --transpile-only src/server.ts",
    "build": "tsc && npx prisma generate",
    "start": "node dist/server.js",
    "start:prod": "NODE_ENV=production node dist/server.js",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "test:e2e": "jest --config jest.e2e.config.js",
    "lint": "eslint src/**/*.ts",
    "lint:fix": "eslint src/**/*.ts --fix",
    "typecheck": "tsc --noEmit",
    "seed": "ts-node prisma/seed.ts",
    "seed:prod": "node dist/prisma/seed.js",
    "prisma:generate": "npx prisma generate",
    "prisma:migrate": "npx prisma migrate dev",
    "prisma:deploy": "npx prisma migrate deploy",
    "prisma:reset": "npx prisma migrate reset",
    "prisma:studio": "npx prisma studio",
    "db:push": "npx prisma db push",
    "clean": "rm -rf dist",
    "prepare": "npx prisma generate"
  },
  "prisma": {
    "seed": "ts-node prisma/seed.ts"
  },
  "dependencies": {
    "@prisma/client": "^5.7.0",
    "@sendgrid/mail": "^8.1.0",
    "@types/jsonwebtoken": "^9.0.5",
    "axios": "^1.6.2",
    "bcryptjs": "^2.4.3",
    "bull": "^4.12.0",
    "compression": "^1.7.4",
    "cors": "^2.8.5",
    "dotenv": "^16.3.1",
    "express": "^4.18.2",
    "express-rate-limit": "^7.1.5",
    "express-validator": "^7.0.1",
    "helmet": "^7.1.0",
    "ioredis": "^5.3.2",
    "jsonwebtoken": "^9.0.2",
    "morgan": "^1.10.0",
    "multer": "^1.4.5-lts.1",
    "node-cron": "^3.0.3",
    "passport": "^0.7.0",
    "passport-google-oauth20": "^2.0.0",
    "passport-jwt": "^4.0.1",
    "redis": "^4.6.12",
    "socket.io": "^4.7.2",
    "stripe": "^14.9.0",
    "swagger-jsdoc": "^6.2.8",
    "swagger-ui-express": "^5.0.0",
    "twilio": "^4.19.3",
    "uuid": "^9.0.1",
    "winston": "^3.11.0",
    "zod": "^3.22.4",
    "ethers": "^6.9.0",
    "@tensorflow/tfjs-node": "^4.15.0",
    "sharp": "^0.33.0",
    "pdf-lib": "^1.17.1",
    "geolib": "^3.3.4",
    "luxon": "^3.4.4",
    "lodash": "^4.17.21"
  },
  "devDependencies": {
    "@types/bcryptjs": "^2.4.6",
    "@types/compression": "^1.7.5",
    "@types/cors": "^2.8.17",
    "@types/express": "^4.17.21",
    "@types/lodash": "^4.14.202",
    "@types/morgan": "^1.9.9",
    "@types/multer": "^1.4.11",
    "@types/node": "^20.10.5",
    "@types/node-cron": "^3.0.11",
    "@types/passport": "^1.0.16",
    "@types/passport-google-oauth20": "^2.0.14",
    "@types/passport-jwt": "^4.0.0",
    "@types/swagger-jsdoc": "^6.0.4",
    "@types/swagger-ui-express": "^4.1.6",
    "@types/uuid": "^9.0.7",
    "@typescript-eslint/eslint-plugin": "^6.15.0",
    "@typescript-eslint/parser": "^6.15.0",
    "eslint": "^8.56.0",
    "jest": "^29.7.0",
    "prisma": "^5.7.0",
    "supertest": "^6.3.3",
    "ts-jest": "^29.1.1",
    "ts-node": "^10.9.2",
    "ts-node-dev": "^2.0.0",
    "typescript": "^5.3.3"
  },
  "engines": {
    "node": ">=18.0.0"
  }
}


Tsconfig · JSON

{
  "compilerOptions": {
    "target": "ES2022",
    "module": "commonjs",
    "lib": ["ES2022"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"],
      "@config/*": ["src/config/*"],
      "@controllers/*": ["src/controllers/*"],
      "@services/*": ["src/services/*"],
      "@models/*": ["src/models/*"],
      "@middleware/*": ["src/middleware/*"],
      "@routes/*": ["src/routes/*"],
      "@utils/*": ["src/utils/*"],
      "@integrations/*": ["src/integrations/*"]
    }
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "tests"]
}

Index · TS

// Configuration Management
import dotenv from 'dotenv';
import { z } from 'zod';

dotenv.config();

const envSchema = z.object({
  // Server
  NODE_ENV: z.enum(['development', 'production', 'test']).default('development'),
  PORT: z.string().default('4000'),
  API_VERSION: z.string().default('v1'),
  
  // Database
  DATABASE_URL: z.string(),
  
  // Redis
  REDIS_URL: z.string().default('redis://localhost:6379'),
  
  // JWT
  JWT_SECRET: z.string(),
  JWT_EXPIRES_IN: z.string().default('7d'),
  JWT_REFRESH_SECRET: z.string(),
  JWT_REFRESH_EXPIRES_IN: z.string().default('30d'),
  
  // Encryption
  ENCRYPTION_KEY: z.string(),
  
  // AWS
  AWS_ACCESS_KEY_ID: z.string().optional(),
  AWS_SECRET_ACCESS_KEY: z.string().optional(),
  AWS_REGION: z.string().default('us-east-1'),
  AWS_S3_BUCKET: z.string().optional(),
  AWS_CLOUDFRONT_URL: z.string().optional(),
  
  // Stripe
  STRIPE_SECRET_KEY: z.string().optional(),
  STRIPE_WEBHOOK_SECRET: z.string().optional(),
  STRIPE_DHARMA_PRICE_ID: z.string().optional(),
  STRIPE_KARMA_PRICE_ID: z.string().optional(),
  STRIPE_ENLIGHTENED_PRICE_ID: z.string().optional(),
  
  // SendGrid
  SENDGRID_API_KEY: z.string().optional(),
  SENDGRID_FROM_EMAIL: z.string().default('noreply@dharmarealty.com'),
  
  // Twilio
  TWILIO_ACCOUNT_SID: z.string().optional(),
  TWILIO_AUTH_TOKEN: z.string().optional(),
  TWILIO_PHONE_NUMBER: z.string().optional(),
  
  // Google
  GOOGLE_CLIENT_ID: z.string().optional(),
  GOOGLE_CLIENT_SECRET: z.string().optional(),
  GOOGLE_MAPS_API_KEY: z.string().optional(),
  
  // Blockchain
  POLYGON_RPC_URL: z.string().default('https://polygon-rpc.com'),
  ETHEREUM_RPC_URL: z.string().optional(),
  CONTRACT_DEPLOYER_PRIVATE_KEY: z.string().optional(),
  PROPERTY_REGISTRY_CONTRACT: z.string().optional(),
  
  // IPFS
  IPFS_PROJECT_ID: z.string().optional(),
  IPFS_PROJECT_SECRET: z.string().optional(),
  IPFS_GATEWAY: z.string().default('https://gateway.pinata.cloud/ipfs/'),
  
  // External APIs
  MATTERPORT_API_KEY: z.string().optional(),
  ZILLOW_API_KEY: z.string().optional(),
  GREAT_SCHOOLS_API_KEY: z.string().optional(),
  NOAA_API_KEY: z.string().optional(),
  PURPLEAIR_API_KEY: z.string().optional(),
  
  // OpenAI / AI
  OPENAI_API_KEY: z.string().optional(),
  
  // Frontend URL
  FRONTEND_URL: z.string().default('http://localhost:3000'),
  
  // Rate Limiting
  RATE_LIMIT_WINDOW_MS: z.string().default('900000'),
  RATE_LIMIT_MAX_REQUESTS: z.string().default('100'),
});

const parsed = envSchema.safeParse(process.env);

if (!parsed.success) {
  console.error('❌ Invalid environment variables:', parsed.error.flatten().fieldErrors);
  process.exit(1);
}

export const config = {
  env: parsed.data.NODE_ENV,
  port: parseInt(parsed.data.PORT, 10),
  apiVersion: parsed.data.API_VERSION,
  
  database: {
    url: parsed.data.DATABASE_URL,
  },
  
  redis: {
    url: parsed.data.REDIS_URL,
  },
  
  jwt: {
    secret: parsed.data.JWT_SECRET,
    expiresIn: parsed.data.JWT_EXPIRES_IN,
    refreshSecret: parsed.data.JWT_REFRESH_SECRET,
    refreshExpiresIn: parsed.data.JWT_REFRESH_EXPIRES_IN,
  },
  
  encryption: {
    key: parsed.data.ENCRYPTION_KEY,
  },
  
  aws: {
    accessKeyId: parsed.data.AWS_ACCESS_KEY_ID,
    secretAccessKey: parsed.data.AWS_SECRET_ACCESS_KEY,
    region: parsed.data.AWS_REGION,
    s3Bucket: parsed.data.AWS_S3_BUCKET,
    cloudfrontUrl: parsed.data.AWS_CLOUDFRONT_URL,
  },
  
  stripe: {
    secretKey: parsed.data.STRIPE_SECRET_KEY,
    webhookSecret: parsed.data.STRIPE_WEBHOOK_SECRET,
    prices: {
      dharma: parsed.data.STRIPE_DHARMA_PRICE_ID,
      karma: parsed.data.STRIPE_KARMA_PRICE_ID,
      enlightened: parsed.data.STRIPE_ENLIGHTENED_PRICE_ID,
    },
  },
  
  sendgrid: {
    apiKey: parsed.data.SENDGRID_API_KEY,
    fromEmail: parsed.data.SENDGRID_FROM_EMAIL,
  },
  
  twilio: {
    accountSid: parsed.data.TWILIO_ACCOUNT_SID,
    authToken: parsed.data.TWILIO_AUTH_TOKEN,
    phoneNumber: parsed.data.TWILIO_PHONE_NUMBER,
  },
  
  google: {
    clientId: parsed.data.GOOGLE_CLIENT_ID,
    clientSecret: parsed.data.GOOGLE_CLIENT_SECRET,
    mapsApiKey: parsed.data.GOOGLE_MAPS_API_KEY,
  },
  
  blockchain: {
    polygonRpcUrl: parsed.data.POLYGON_RPC_URL,
    ethereumRpcUrl: parsed.data.ETHEREUM_RPC_URL,
    deployerPrivateKey: parsed.data.CONTRACT_DEPLOYER_PRIVATE_KEY,
    propertyRegistryContract: parsed.data.PROPERTY_REGISTRY_CONTRACT,
  },
  
  ipfs: {
    projectId: parsed.data.IPFS_PROJECT_ID,
    projectSecret: parsed.data.IPFS_PROJECT_SECRET,
    gateway: parsed.data.IPFS_GATEWAY,
  },
  
  externalApis: {
    matterport: parsed.data.MATTERPORT_API_KEY,
    zillow: parsed.data.ZILLOW_API_KEY,
    greatSchools: parsed.data.GREAT_SCHOOLS_API_KEY,
    noaa: parsed.data.NOAA_API_KEY,
    purpleAir: parsed.data.PURPLEAIR_API_KEY,
  },
  
  openai: {
    apiKey: parsed.data.OPENAI_API_KEY,
  },
  
  frontendUrl: parsed.data.FRONTEND_URL,
  
  rateLimit: {
    windowMs: parseInt(parsed.data.RATE_LIMIT_WINDOW_MS, 10),
    maxRequests: parseInt(parsed.data.RATE_LIMIT_MAX_REQUESTS, 10),
  },
};

export type Config = typeof config;

Server · TS
// Dharma Realty - Main Server Entry Point
import express, { Application, Request, Response, NextFunction } from 'express';
import cors from 'cors';
import helmet from 'helmet';
import compression from 'compression';
import morgan from 'morgan';
import rateLimit from 'express-rate-limit';
import { createServer } from 'http';
import { Server as SocketIOServer } from 'socket.io';
import swaggerUi from 'swagger-ui-express';
import swaggerJsdoc from 'swagger-jsdoc';

import { config } from './config';
import { logger } from './utils/logger';
import { errorHandler, notFoundHandler } from './middleware/errorHandler';
import { prisma } from './utils/prisma';
import { redisClient } from './utils/redis';
import { initializeSocketHandlers } from './websockets';

// Route imports
import authRoutes from './routes/auth';
import userRoutes from './routes/users';
import propertyRoutes from './routes/properties';
import searchRoutes from './routes/search';
import agentRoutes from './routes/agents';
import leadRoutes from './routes/leads';
import vastuRoutes from './routes/vastu';
import climateRoutes from './routes/climate';
import blockchainRoutes from './routes/blockchain';
import valuationRoutes from './routes/valuation';
import savedSearchRoutes from './routes/savedSearches';
import favoriteRoutes from './routes/favorites';
import messageRoutes from './routes/messages';
import notificationRoutes from './routes/notifications';
import subscriptionRoutes from './routes/subscriptions';
import uploadRoutes from './routes/uploads';
import astrologyRoutes from './routes/astrology';
import daoRoutes from './routes/dao';
import analyticsRoutes from './routes/analytics';
import webhookRoutes from './routes/webhooks';
import healthRoutes from './routes/health';

// Initialize Express app
const app: Application = express();
const httpServer = createServer(app);

// Initialize Socket.IO
const io = new SocketIOServer(httpServer, {
  cors: {
    origin: config.frontendUrl,
    methods: ['GET', 'POST'],
    credentials: true,
  },
});

// Swagger configuration
const swaggerOptions = {
  definition: {
    openapi: '3.0.0',
    info: {
      title: 'Dharma Realty API',
      version: '1.0.0',
      description: 'Revolutionary Real Estate Platform with Ancient Wisdom + Cutting-Edge Tech',
      contact: {
        name: 'Dharma Realty Support',
        email: 'support@dharmarealty.com',
      },
    },
    servers: [
      {
        url: `http://localhost:${config.port}/api/${config.apiVersion}`,
        description: 'Development server',
      },
      {
        url: `https://api.dharmarealty.com/api/${config.apiVersion}`,
        description: 'Production server',
      },
    ],
    components: {
      securitySchemes: {
        bearerAuth: {
          type: 'http',
          scheme: 'bearer',
          bearerFormat: 'JWT',
        },
      },
    },
    security: [{ bearerAuth: [] }],
  },
  apis: ['./src/routes/*.ts'],
};

const swaggerSpec = swaggerJsdoc(swaggerOptions);

// Trust proxy for rate limiting behind load balancer
app.set('trust proxy', 1);

// Security middleware
app.use(helmet({
  crossOriginResourcePolicy: { policy: 'cross-origin' },
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", 'data:', 'https:'],
    },
  },
}));

// CORS
app.use(cors({
  origin: [config.frontendUrl, 'http://localhost:3000'],
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With'],
}));

// Compression
app.use(compression());

// Request logging
app.use(morgan('combined', {
  stream: { write: (message) => logger.http(message.trim()) },
}));

// Rate limiting
const limiter = rateLimit({
  windowMs: config.rateLimit.windowMs,
  max: config.rateLimit.maxRequests,
  message: {
    success: false,
    error: 'Too many requests, please try again later.',
  },
  standardHeaders: true,
  legacyHeaders: false,
});
app.use('/api/', limiter);

// Body parsing - exclude webhooks from JSON parsing
app.use('/api/webhooks/stripe', express.raw({ type: 'application/json' }));
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// API Documentation
app.use('/api/docs', swaggerUi.serve, swaggerUi.setup(swaggerSpec, {
  customCss: '.swagger-ui .topbar { display: none }',
  customSiteTitle: 'Dharma Realty API Documentation',
}));

// Health check (no auth required)
app.use('/api/health', healthRoutes);

// Webhooks (no auth, raw body)
app.use('/api/webhooks', webhookRoutes);

// API Routes
const apiRouter = express.Router();

apiRouter.use('/auth', authRoutes);
apiRouter.use('/users', userRoutes);
apiRouter.use('/properties', propertyRoutes);
apiRouter.use('/search', searchRoutes);
apiRouter.use('/agents', agentRoutes);
apiRouter.use('/leads', leadRoutes);
apiRouter.use('/vastu', vastuRoutes);
apiRouter.use('/climate', climateRoutes);
apiRouter.use('/blockchain', blockchainRoutes);
apiRouter.use('/valuation', valuationRoutes);
apiRouter.use('/saved-searches', savedSearchRoutes);
apiRouter.use('/favorites', favoriteRoutes);
apiRouter.use('/messages', messageRoutes);
apiRouter.use('/notifications', notificationRoutes);
apiRouter.use('/subscriptions', subscriptionRoutes);
apiRouter.use('/uploads', uploadRoutes);
apiRouter.use('/astrology', astrologyRoutes);
apiRouter.use('/dao', daoRoutes);
apiRouter.use('/analytics', analyticsRoutes);

app.use(`/api/${config.apiVersion}`, apiRouter);

// 404 handler
app.use(notFoundHandler);

// Error handler
app.use(errorHandler);

// Initialize Socket.IO handlers
initializeSocketHandlers(io);

// Graceful shutdown
const gracefulShutdown = async () => {
  logger.info('Received shutdown signal. Closing connections...');
  
  // Close HTTP server
  httpServer.close(() => {
    logger.info('HTTP server closed');
  });
  
  // Close database connection
  await prisma.$disconnect();
  logger.info('Database connection closed');
  
  // Close Redis connection
  await redisClient.quit();
  logger.info('Redis connection closed');
  
  process.exit(0);
};

process.on('SIGTERM', gracefulShutdown);
process.on('SIGINT', gracefulShutdown);

// Start server
const startServer = async () => {
  try {
    // Test database connection
    await prisma.$connect();
    logger.info('✅ Database connected');
    
    // Test Redis connection
    await redisClient.ping();
    logger.info('✅ Redis connected');
    
    // Start HTTP server
    httpServer.listen(config.port, () => {
      logger.info(`
╔════════════════════════════════════════════════════════════╗
║                                                            ║
║    🙏 DHARMA REALTY PLATFORM 🙏                            ║
║                                                            ║
║    Ancient Wisdom + Cutting-Edge Technology                ║
║                                                            ║
║    Server: http://localhost:${config.port}                      ║
║    API: http://localhost:${config.port}/api/${config.apiVersion}                  ║
║    Docs: http://localhost:${config.port}/api/docs               ║
║                                                            ║
║    Environment: ${config.env}                          ║
║                                                            ║
╚════════════════════════════════════════════════════════════╝
      `);
    });
  } catch (error) {
    logger.error('Failed to start server:', error);
    process.exit(1);
  }
};

startServer();

export { app, io };

Logger · TS
// Winston Logger Configuration
import winston from 'winston';
import { config } from '../config';

const { combine, timestamp, printf, colorize, errors } = winston.format;

// Custom log format
const logFormat = printf(({ level, message, timestamp, stack }) => {
  return `${timestamp} [${level}]: ${stack || message}`;
});

// Create logger instance
export const logger = winston.createLogger({
  level: config.env === 'development' ? 'debug' : 'info',
  format: combine(
    timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
    errors({ stack: true }),
    logFormat
  ),
  defaultMeta: { service: 'dharma-realty' },
  transports: [
    // Console transport
    new winston.transports.Console({
      format: combine(
        colorize(),
        timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
        logFormat
      ),
    }),
    // File transport for errors
    new winston.transports.File({
      filename: 'logs/error.log',
      level: 'error',
      maxsize: 5242880, // 5MB
      maxFiles: 5,
    }),
    // File transport for all logs
    new winston.transports.File({
      filename: 'logs/combined.log',
      maxsize: 5242880, // 5MB
      maxFiles: 5,
    }),
  ],
});

// Stream for Morgan HTTP logging
logger.stream = {
  write: (message: string) => {
    logger.http(message.trim());
  },
} as any;

// Add HTTP level
winston.addColors({
  http: 'magenta',
});

Prisma · TS

// Prisma Client Singleton
import { PrismaClient } from '@prisma/client';
import { logger } from './logger';

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
};

export const prisma =
  globalForPrisma.prisma ??
  new PrismaClient({
    log: [
      { level: 'query', emit: 'event' },
      { level: 'error', emit: 'stdout' },
      { level: 'info', emit: 'stdout' },
      { level: 'warn', emit: 'stdout' },
    ],
  });

if (process.env.NODE_ENV !== 'production') {
  globalForPrisma.prisma = prisma;
}

// Log queries in development
prisma.$on('query' as never, (e: any) => {
  if (process.env.NODE_ENV === 'development') {
    logger.debug(`Query: ${e.query}`);
    logger.debug(`Duration: ${e.duration}ms`);
  }
});

// Prisma Middleware for audit logging
prisma.$use(async (params, next) => {
  const start = Date.now();
  const result = await next(params);
  const duration = Date.now() - start;
  
  if (duration > 1000) {
    logger.warn(`Slow query detected: ${params.model}.${params.action} took ${duration}ms`);
  }
  
  return result;
});

export default prisma;
Redis · TS
// Redis Client & Caching Utilities
import Redis from 'ioredis';
import { config } from '../config';
import { logger } from './logger';

// Create Redis client
export const redisClient = new Redis(config.redis.url, {
  maxRetriesPerRequest: 3,
  retryDelayOnFailover: 100,
  enableReadyCheck: true,
  lazyConnect: true,
});

// Event handlers
redisClient.on('connect', () => {
  logger.info('Redis client connected');
});

redisClient.on('error', (error) => {
  logger.error('Redis client error:', error);
});

redisClient.on('reconnecting', () => {
  logger.warn('Redis client reconnecting...');
});

// Cache key prefixes
export const CACHE_KEYS = {
  PROPERTY: 'property:',
  PROPERTY_LIST: 'property_list:',
  SEARCH: 'search:',
  USER: 'user:',
  AGENT: 'agent:',
  VASTU: 'vastu:',
  CLIMATE: 'climate:',
  NEIGHBORHOOD: 'neighborhood:',
  VALUATION: 'valuation:',
  SESSION: 'session:',
  RATE_LIMIT: 'rate_limit:',
  ANALYTICS: 'analytics:',
} as const;

// Cache TTL values (in seconds)
export const CACHE_TTL = {
  SHORT: 60, // 1 minute
  MEDIUM: 300, // 5 minutes
  LONG: 3600, // 1 hour
  DAY: 86400, // 24 hours
  WEEK: 604800, // 7 days
} as const;

// Generic cache get
export async function cacheGet<T>(key: string): Promise<T | null> {
  try {
    const cached = await redisClient.get(key);
    if (cached) {
      return JSON.parse(cached) as T;
    }
    return null;
  } catch (error) {
    logger.error(`Cache get error for key ${key}:`, error);
    return null;
  }
}

// Generic cache set
export async function cacheSet(
  key: string,
  value: unknown,
  ttlSeconds: number = CACHE_TTL.MEDIUM
): Promise<void> {
  try {
    await redisClient.setex(key, ttlSeconds, JSON.stringify(value));
  } catch (error) {
    logger.error(`Cache set error for key ${key}:`, error);
  }
}

// Generic cache delete
export async function cacheDelete(key: string): Promise<void> {
  try {
    await redisClient.del(key);
  } catch (error) {
    logger.error(`Cache delete error for key ${key}:`, error);
  }
}

// Delete cache by pattern
export async function cacheDeletePattern(pattern: string): Promise<void> {
  try {
    const keys = await redisClient.keys(pattern);
    if (keys.length > 0) {
      await redisClient.del(...keys);
      logger.debug(`Deleted ${keys.length} cache keys matching pattern: ${pattern}`);
    }
  } catch (error) {
    logger.error(`Cache delete pattern error for ${pattern}:`, error);
  }
}

// Cache wrapper for functions
export function withCache<T>(
  keyGenerator: (...args: any[]) => string,
  ttlSeconds: number = CACHE_TTL.MEDIUM
) {
  return function (
    target: any,
    propertyKey: string,
    descriptor: PropertyDescriptor
  ) {
    const originalMethod = descriptor.value;

    descriptor.value = async function (...args: any[]) {
      const cacheKey = keyGenerator(...args);
      
      // Try to get from cache
      const cached = await cacheGet<T>(cacheKey);
      if (cached !== null) {
        logger.debug(`Cache hit for ${cacheKey}`);
        return cached;
      }
      
      // Execute original method
      logger.debug(`Cache miss for ${cacheKey}`);
      const result = await originalMethod.apply(this, args);
      
      // Store in cache
      await cacheSet(cacheKey, result, ttlSeconds);
      
      return result;
    };

    return descriptor;
  };
}

// Rate limiting helper
export async function checkRateLimit(
  key: string,
  maxRequests: number,
  windowSeconds: number
): Promise<{ allowed: boolean; remaining: number; resetIn: number }> {
  const fullKey = `${CACHE_KEYS.RATE_LIMIT}${key}`;
  
  try {
    const multi = redisClient.multi();
    multi.incr(fullKey);
    multi.ttl(fullKey);
    const results = await multi.exec();
    
    const currentCount = results?.[0]?.[1] as number || 0;
    const ttl = results?.[1]?.[1] as number || -1;
    
    // Set expiry if this is a new key
    if (ttl === -1) {
      await redisClient.expire(fullKey, windowSeconds);
    }
    
    const allowed = currentCount <= maxRequests;
    const remaining = Math.max(0, maxRequests - currentCount);
    const resetIn = ttl === -1 ? windowSeconds : ttl;
    
    return { allowed, remaining, resetIn };
  } catch (error) {
    logger.error(`Rate limit check error for ${key}:`, error);
    // Allow request on error
    return { allowed: true, remaining: maxRequests, resetIn: windowSeconds };
  }
}

// Pub/Sub for real-time features
export const redisPubClient = redisClient.duplicate();
export const redisSubClient = redisClient.duplicate();

export default redisClient;

Errorhandler · TS

// Error Handler Middleware
import { Request, Response, NextFunction } from 'express';
import { Prisma } from '@prisma/client';
import { ZodError } from 'zod';
import { logger } from '../utils/logger';
import { config } from '../config';

// Custom error class
export class AppError extends Error {
  public readonly statusCode: number;
  public readonly isOperational: boolean;
  public readonly code?: string;
  public readonly details?: unknown;

  constructor(
    message: string,
    statusCode: number = 500,
    isOperational: boolean = true,
    code?: string,
    details?: unknown
  ) {
    super(message);
    this.statusCode = statusCode;
    this.isOperational = isOperational;
    this.code = code;
    this.details = details;

    Error.captureStackTrace(this, this.constructor);
  }
}

// Common error types
export class BadRequestError extends AppError {
  constructor(message: string = 'Bad request', details?: unknown) {
    super(message, 400, true, 'BAD_REQUEST', details);
  }
}

export class UnauthorizedError extends AppError {
  constructor(message: string = 'Unauthorized') {
    super(message, 401, true, 'UNAUTHORIZED');
  }
}

export class ForbiddenError extends AppError {
  constructor(message: string = 'Forbidden') {
    super(message, 403, true, 'FORBIDDEN');
  }
}

export class NotFoundError extends AppError {
  constructor(message: string = 'Resource not found') {
    super(message, 404, true, 'NOT_FOUND');
  }
}

export class ConflictError extends AppError {
  constructor(message: string = 'Resource already exists') {
    super(message, 409, true, 'CONFLICT');
  }
}

export class ValidationError extends AppError {
  constructor(message: string = 'Validation failed', details?: unknown) {
    super(message, 422, true, 'VALIDATION_ERROR', details);
  }
}

export class TooManyRequestsError extends AppError {
  constructor(message: string = 'Too many requests') {
    super(message, 429, true, 'TOO_MANY_REQUESTS');
  }
}

export class InternalServerError extends AppError {
  constructor(message: string = 'Internal server error') {
    super(message, 500, false, 'INTERNAL_SERVER_ERROR');
  }
}

// Error response interface
interface ErrorResponse {
  success: false;
  error: {
    message: string;
    code?: string;
    details?: unknown;
    stack?: string;
  };
}

// 404 Not Found handler
export const notFoundHandler = (req: Request, res: Response, next: NextFunction) => {
  const error = new NotFoundError(`Route ${req.method} ${req.originalUrl} not found`);
  next(error);
};

// Main error handler
export const errorHandler = (
  error: Error,
  req: Request,
  res: Response,
  next: NextFunction
) => {
  let statusCode = 500;
  let message = 'Internal server error';
  let code = 'INTERNAL_SERVER_ERROR';
  let details: unknown = undefined;

  // Handle AppError
  if (error instanceof AppError) {
    statusCode = error.statusCode;
    message = error.message;
    code = error.code || code;
    details = error.details;
  }

  // Handle Zod validation errors
  if (error instanceof ZodError) {
    statusCode = 422;
    message = 'Validation failed';
    code = 'VALIDATION_ERROR';
    details = error.errors.map((e) => ({
      field: e.path.join('.'),
      message: e.message,
    }));
  }

  // Handle Prisma errors
  if (error instanceof Prisma.PrismaClientKnownRequestError) {
    switch (error.code) {
      case 'P2002':
        statusCode = 409;
        message = 'A record with this value already exists';
        code = 'DUPLICATE_ENTRY';
        details = { field: error.meta?.target };
        break;
      case 'P2025':
        statusCode = 404;
        message = 'Record not found';
        code = 'NOT_FOUND';
        break;
      case 'P2003':
        statusCode = 400;
        message = 'Foreign key constraint failed';
        code = 'FOREIGN_KEY_ERROR';
        break;
      default:
        message = 'Database error';
        code = 'DATABASE_ERROR';
    }
  }

  if (error instanceof Prisma.PrismaClientValidationError) {
    statusCode = 400;
    message = 'Invalid data provided';
    code = 'VALIDATION_ERROR';
  }

  // Handle JWT errors
  if (error.name === 'JsonWebTokenError') {
    statusCode = 401;
    message = 'Invalid token';
    code = 'INVALID_TOKEN';
  }

  if (error.name === 'TokenExpiredError') {
    statusCode = 401;
    message = 'Token expired';
    code = 'TOKEN_EXPIRED';
  }

  // Log error
  const logData = {
    method: req.method,
    url: req.originalUrl,
    statusCode,
    message,
    code,
    userId: (req as any).user?.id,
    ip: req.ip,
    userAgent: req.get('user-agent'),
  };

  if (statusCode >= 500) {
    logger.error('Server error:', { ...logData, stack: error.stack });
  } else if (statusCode >= 400) {
    logger.warn('Client error:', logData);
  }

  // Build response
  const response: ErrorResponse = {
    success: false,
    error: {
      message,
      code,
      details,
    },
  };

  // Include stack trace in development
  if (config.env === 'development' && error.stack) {
    response.error.stack = error.stack;
  }

  res.status(statusCode).json(response);
};

// Async handler wrapper to catch errors
export const asyncHandler = (fn: Function) => {
  return (req: Request, res: Response, next: NextFunction) => {
    Promise.resolve(fn(req, res, next)).catch(next);
  };
};

Auth · TS
// Authentication Middleware
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import { config } from '../config';
import { prisma } from '../utils/prisma';
import { cacheGet, cacheSet, CACHE_KEYS, CACHE_TTL } from '../utils/redis';
import { UnauthorizedError, ForbiddenError } from './errorHandler';
import { logger } from '../utils/logger';

// Extended Request with user info
export interface AuthenticatedRequest extends Request {
  user?: {
    id: string;
    email: string;
    userType: string;
    agentId?: string;
    walletAddress?: string;
  };
}

// JWT payload interface
interface JWTPayload {
  userId: string;
  email: string;
  userType: string;
  agentId?: string;
  iat: number;
  exp: number;
}

// Verify JWT token
export const authenticate = async (
  req: AuthenticatedRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    // Get token from header
    const authHeader = req.headers.authorization;
    
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      throw new UnauthorizedError('No token provided');
    }

    const token = authHeader.split(' ')[1];

    // Verify token
    let decoded: JWTPayload;
    try {
      decoded = jwt.verify(token, config.jwt.secret) as JWTPayload;
    } catch (error) {
      if (error instanceof jwt.TokenExpiredError) {
        throw new UnauthorizedError('Token expired');
      }
      throw new UnauthorizedError('Invalid token');
    }

    // Check if user exists (with caching)
    const cacheKey = `${CACHE_KEYS.USER}${decoded.userId}`;
    let user = await cacheGet<any>(cacheKey);

    if (!user) {
      user = await prisma.user.findUnique({
        where: { id: decoded.userId },
        select: {
          id: true,
          email: true,
          userType: true,
          isActive: true,
          walletAddress: true,
          agent: {
            select: {
              id: true,
              subscriptionTier: true,
              verified: true,
            },
          },
        },
      });

      if (user) {
        await cacheSet(cacheKey, user, CACHE_TTL.MEDIUM);
      }
    }

    if (!user) {
      throw new UnauthorizedError('User not found');
    }

    if (!user.isActive) {
      throw new UnauthorizedError('Account is deactivated');
    }

    // Attach user to request
    req.user = {
      id: user.id,
      email: user.email,
      userType: user.userType,
      agentId: user.agent?.id,
      walletAddress: user.walletAddress,
    };

    next();
  } catch (error) {
    next(error);
  }
};

// Optional authentication (doesn't fail if no token)
export const optionalAuthenticate = async (
  req: AuthenticatedRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const authHeader = req.headers.authorization;
    
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return next();
    }

    const token = authHeader.split(' ')[1];

    try {
      const decoded = jwt.verify(token, config.jwt.secret) as JWTPayload;
      
      const cacheKey = `${CACHE_KEYS.USER}${decoded.userId}`;
      let user = await cacheGet<any>(cacheKey);

      if (!user) {
        user = await prisma.user.findUnique({
          where: { id: decoded.userId },
          select: {
            id: true,
            email: true,
            userType: true,
            isActive: true,
            walletAddress: true,
            agent: {
              select: {
                id: true,
              },
            },
          },
        });

        if (user) {
          await cacheSet(cacheKey, user, CACHE_TTL.MEDIUM);
        }
      }

      if (user && user.isActive) {
        req.user = {
          id: user.id,
          email: user.email,
          userType: user.userType,
          agentId: user.agent?.id,
          walletAddress: user.walletAddress,
        };
      }
    } catch (error) {
      // Ignore token errors for optional auth
      logger.debug('Optional auth failed:', error);
    }

    next();
  } catch (error) {
    next(error);
  }
};

// Require specific user types
export const requireUserType = (...allowedTypes: string[]) => {
  return (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
    if (!req.user) {
      return next(new UnauthorizedError('Authentication required'));
    }

    if (!allowedTypes.includes(req.user.userType)) {
      return next(new ForbiddenError('Insufficient permissions'));
    }

    next();
  };
};

// Require agent role
export const requireAgent = (
  req: AuthenticatedRequest,
  res: Response,
  next: NextFunction
) => {
  if (!req.user) {
    return next(new UnauthorizedError('Authentication required'));
  }

  if (!req.user.agentId) {
    return next(new ForbiddenError('Agent access required'));
  }

  next();
};

// Require admin role
export const requireAdmin = (
  req: AuthenticatedRequest,
  res: Response,
  next: NextFunction
) => {
  if (!req.user) {
    return next(new UnauthorizedError('Authentication required'));
  }

  if (req.user.userType !== 'ADMIN') {
    return next(new ForbiddenError('Admin access required'));
  }

  next();
};

// Require verified agent
export const requireVerifiedAgent = async (
  req: AuthenticatedRequest,
  res: Response,
  next: NextFunction
) => {
  if (!req.user || !req.user.agentId) {
    return next(new ForbiddenError('Agent access required'));
  }

  try {
    const agent = await prisma.agent.findUnique({
      where: { id: req.user.agentId },
      select: { verified: true },
    });

    if (!agent?.verified) {
      return next(new ForbiddenError('Agent verification required'));
    }

    next();
  } catch (error) {
    next(error);
  }
};

// Require specific subscription tier
export const requireSubscription = (...allowedTiers: string[]) => {
  return async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
    if (!req.user || !req.user.agentId) {
      return next(new ForbiddenError('Agent access required'));
    }

    try {
      const agent = await prisma.agent.findUnique({
        where: { id: req.user.agentId },
        select: { subscriptionTier: true, subscriptionExpiry: true },
      });

      if (!agent) {
        return next(new ForbiddenError('Agent not found'));
      }

      if (!allowedTiers.includes(agent.subscriptionTier)) {
        return next(new ForbiddenError(
          `This feature requires ${allowedTiers.join(' or ')} subscription`
        ));
      }

      if (agent.subscriptionExpiry && new Date(agent.subscriptionExpiry) < new Date()) {
        return next(new ForbiddenError('Subscription expired'));
      }

      next();
    } catch (error) {
      next(error);
    }
  };
};

// Generate tokens
export const generateTokens = (user: {
  id: string;
  email: string;
  userType: string;
  agentId?: string;
}) => {
  const accessToken = jwt.sign(
    {
      userId: user.id,
      email: user.email,
      userType: user.userType,
      agentId: user.agentId,
    },
    config.jwt.secret,
    { expiresIn: config.jwt.expiresIn }
  );

  const refreshToken = jwt.sign(
    { userId: user.id },
    config.jwt.refreshSecret,
    { expiresIn: config.jwt.refreshExpiresIn }
  );

  return { accessToken, refreshToken };
};

// Verify refresh token
export const verifyRefreshToken = (token: string): { userId: string } => {
  return jwt.verify(token, config.jwt.refreshSecret) as { userId: string };
};

Auth · TS
// Authentication Routes
import { Router } from 'express';
import bcrypt from 'bcryptjs';
import { z } from 'zod';
import { prisma } from '../utils/prisma';
import { cacheDelete, CACHE_KEYS } from '../utils/redis';
import { 
  authenticate, 
  generateTokens, 
  verifyRefreshToken,
  AuthenticatedRequest 
} from '../middleware/auth';
import { 
  asyncHandler, 
  BadRequestError, 
  UnauthorizedError, 
  ConflictError 
} from '../middleware/errorHandler';
import { logger } from '../utils/logger';

const router = Router();

// Validation schemas
const registerSchema = z.object({
  email: z.string().email('Invalid email address'),
  password: z.string().min(8, 'Password must be at least 8 characters'),
  firstName: z.string().min(1, 'First name is required'),
  lastName: z.string().min(1, 'Last name is required'),
  phone: z.string().optional(),
  userType: z.enum(['BUYER', 'SELLER', 'AGENT']).default('BUYER'),
  // Optional astrology fields
  dateOfBirth: z.string().optional(),
  birthTime: z.string().optional(),
  birthPlace: z.string().optional(),
});

const loginSchema = z.object({
  email: z.string().email('Invalid email address'),
  password: z.string().min(1, 'Password is required'),
});

const agentRegistrationSchema = z.object({
  licenseNumber: z.string().min(1, 'License number is required'),
  licenseState: z.string().min(1, 'License state is required'),
  licenseExpiry: z.string(),
  brokerage: z.string().optional(),
  yearsExperience: z.number().min(0),
  specialties: z.array(z.string()).optional(),
  serviceAreas: z.array(z.string()).optional(),
  languages: z.array(z.string()).default(['English']),
  bio: z.string().optional(),
});

/**
 * @swagger
 * /auth/register:
 *   post:
 *     summary: Register a new user
 *     tags: [Authentication]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - email
 *               - password
 *               - firstName
 *               - lastName
 *             properties:
 *               email:
 *                 type: string
 *               password:
 *                 type: string
 *               firstName:
 *                 type: string
 *               lastName:
 *                 type: string
 *               userType:
 *                 type: string
 *                 enum: [BUYER, SELLER, AGENT]
 *     responses:
 *       201:
 *         description: User created successfully
 */
router.post('/register', asyncHandler(async (req, res) => {
  const data = registerSchema.parse(req.body);

  // Check if user exists
  const existingUser = await prisma.user.findUnique({
    where: { email: data.email.toLowerCase() },
  });

  if (existingUser) {
    throw new ConflictError('User with this email already exists');
  }

  // Hash password
  const passwordHash = await bcrypt.hash(data.password, 12);

  // Calculate life path number if DOB provided
  let lifePathNumber: number | undefined;
  if (data.dateOfBirth) {
    lifePathNumber = calculateLifePathNumber(data.dateOfBirth);
  }

  // Create user
  const user = await prisma.user.create({
    data: {
      email: data.email.toLowerCase(),
      passwordHash,
      firstName: data.firstName,
      lastName: data.lastName,
      phone: data.phone,
      userType: data.userType,
      dateOfBirth: data.dateOfBirth ? new Date(data.dateOfBirth) : undefined,
      birthTime: data.birthTime,
      birthPlace: data.birthPlace,
      lifePathNumber,
    },
    select: {
      id: true,
      email: true,
      firstName: true,
      lastName: true,
      userType: true,
      createdAt: true,
    },
  });

  // Generate tokens
  const tokens = generateTokens({
    id: user.id,
    email: user.email,
    userType: user.userType,
  });

  // Create karmic score entry
  await prisma.karmicScore.create({
    data: {
      userId: user.id,
      overallScore: 500, // Start with neutral score
      honestyScore: 100,
      responsivenessScore: 100,
      fairnessScore: 100,
      communityScore: 100,
      environmentalScore: 100,
    },
  });

  // Create token balance entry
  await prisma.tokenBalance.create({
    data: {
      userId: user.id,
      balance: 100, // Welcome bonus tokens
    },
  });

  logger.info(`New user registered: ${user.email}`);

  res.status(201).json({
    success: true,
    data: {
      user,
      ...tokens,
    },
  });
}));

/**
 * @swagger
 * /auth/login:
 *   post:
 *     summary: Login user
 *     tags: [Authentication]
 */
router.post('/login', asyncHandler(async (req, res) => {
  const data = loginSchema.parse(req.body);

  // Find user
  const user = await prisma.user.findUnique({
    where: { email: data.email.toLowerCase() },
    include: {
      agent: {
        select: {
          id: true,
          subscriptionTier: true,
          verified: true,
        },
      },
    },
  });

  if (!user || !user.passwordHash) {
    throw new UnauthorizedError('Invalid email or password');
  }

  // Check password
  const isValidPassword = await bcrypt.compare(data.password, user.passwordHash);
  if (!isValidPassword) {
    throw new UnauthorizedError('Invalid email or password');
  }

  if (!user.isActive) {
    throw new UnauthorizedError('Account is deactivated');
  }

  // Update last login
  await prisma.user.update({
    where: { id: user.id },
    data: { lastLoginAt: new Date() },
  });

  // Generate tokens
  const tokens = generateTokens({
    id: user.id,
    email: user.email,
    userType: user.userType,
    agentId: user.agent?.id,
  });

  logger.info(`User logged in: ${user.email}`);

  res.json({
    success: true,
    data: {
      user: {
        id: user.id,
        email: user.email,
        firstName: user.firstName,
        lastName: user.lastName,
        userType: user.userType,
        profilePhotoUrl: user.profilePhotoUrl,
        agent: user.agent,
      },
      ...tokens,
    },
  });
}));

/**
 * @swagger
 * /auth/refresh:
 *   post:
 *     summary: Refresh access token
 *     tags: [Authentication]
 */
router.post('/refresh', asyncHandler(async (req, res) => {
  const { refreshToken } = req.body;

  if (!refreshToken) {
    throw new BadRequestError('Refresh token is required');
  }

  let decoded;
  try {
    decoded = verifyRefreshToken(refreshToken);
  } catch (error) {
    throw new UnauthorizedError('Invalid refresh token');
  }

  // Get user
  const user = await prisma.user.findUnique({
    where: { id: decoded.userId },
    include: {
      agent: {
        select: { id: true },
      },
    },
  });

  if (!user || !user.isActive) {
    throw new UnauthorizedError('User not found or inactive');
  }

  // Generate new tokens
  const tokens = generateTokens({
    id: user.id,
    email: user.email,
    userType: user.userType,
    agentId: user.agent?.id,
  });

  res.json({
    success: true,
    data: tokens,
  });
}));

/**
 * @swagger
 * /auth/me:
 *   get:
 *     summary: Get current user profile
 *     tags: [Authentication]
 *     security:
 *       - bearerAuth: []
 */
router.get('/me', authenticate, asyncHandler(async (req: AuthenticatedRequest, res) => {
  const user = await prisma.user.findUnique({
    where: { id: req.user!.id },
    select: {
      id: true,
      email: true,
      firstName: true,
      lastName: true,
      phone: true,
      profilePhotoUrl: true,
      userType: true,
      dateOfBirth: true,
      birthTime: true,
      birthPlace: true,
      kycVerified: true,
      walletAddress: true,
      preferredLanguage: true,
      timezone: true,
      doshaType: true,
      lifePathNumber: true,
      createdAt: true,
      agent: {
        select: {
          id: true,
          licenseNumber: true,
          brokerage: true,
          yearsExperience: true,
          specialties: true,
          serviceAreas: true,
          languages: true,
          bio: true,
          rating: true,
          reviewCount: true,
          subscriptionTier: true,
          subscriptionExpiry: true,
          verified: true,
          ethicsScore: true,
        },
      },
      karmicScores: {
        select: {
          overallScore: true,
          badges: true,
        },
      },
      tokenBalance: {
        select: {
          balance: true,
          stakedAmount: true,
        },
      },
    },
  });

  if (!user) {
    throw new UnauthorizedError('User not found');
  }

  res.json({
    success: true,
    data: user,
  });
}));

/**
 * @swagger
 * /auth/register-agent:
 *   post:
 *     summary: Register as an agent (requires authentication)
 *     tags: [Authentication]
 *     security:
 *       - bearerAuth: []
 */
router.post('/register-agent', authenticate, asyncHandler(async (req: AuthenticatedRequest, res) => {
  const data = agentRegistrationSchema.parse(req.body);

  // Check if already an agent
  const existingAgent = await prisma.agent.findUnique({
    where: { userId: req.user!.id },
  });

  if (existingAgent) {
    throw new ConflictError('User is already registered as an agent');
  }

  // Create agent profile
  const agent = await prisma.agent.create({
    data: {
      userId: req.user!.id,
      licenseNumber: data.licenseNumber,
      licenseState: data.licenseState,
      licenseExpiry: new Date(data.licenseExpiry),
      brokerage: data.brokerage,
      yearsExperience: data.yearsExperience,
      specialties: data.specialties || [],
      serviceAreas: data.serviceAreas || [],
      languages: data.languages,
      bio: data.bio,
    },
  });

  // Update user type
  await prisma.user.update({
    where: { id: req.user!.id },
    data: { userType: 'AGENT' },
  });

  // Clear cache
  await cacheDelete(`${CACHE_KEYS.USER}${req.user!.id}`);

  logger.info(`Agent registered: ${req.user!.email}`);

  res.status(201).json({
    success: true,
    data: agent,
  });
}));

/**
 * @swagger
 * /auth/logout:
 *   post:
 *     summary: Logout user
 *     tags: [Authentication]
 *     security:
 *       - bearerAuth: []
 */
router.post('/logout', authenticate, asyncHandler(async (req: AuthenticatedRequest, res) => {
  // Clear user cache
  await cacheDelete(`${CACHE_KEYS.USER}${req.user!.id}`);
  
  // In a more complete implementation, you would also:
  // - Blacklist the current token
  // - Clear refresh token from database
  
  res.json({
    success: true,
    message: 'Logged out successfully',
  });
}));

/**
 * @swagger
 * /auth/connect-wallet:
 *   post:
 *     summary: Connect blockchain wallet
 *     tags: [Authentication]
 *     security:
 *       - bearerAuth: []
 */
router.post('/connect-wallet', authenticate, asyncHandler(async (req: AuthenticatedRequest, res) => {
  const { walletAddress, signature, message } = req.body;

  if (!walletAddress || !signature || !message) {
    throw new BadRequestError('Wallet address, signature, and message are required');
  }

  // TODO: Verify signature using ethers.js
  // const recoveredAddress = ethers.verifyMessage(message, signature);
  // if (recoveredAddress.toLowerCase() !== walletAddress.toLowerCase()) {
  //   throw new BadRequestError('Invalid signature');
  // }

  // Update user wallet
  await prisma.user.update({
    where: { id: req.user!.id },
    data: { walletAddress: walletAddress.toLowerCase() },
  });

  // Clear cache
  await cacheDelete(`${CACHE_KEYS.USER}${req.user!.id}`);

  res.json({
    success: true,
    message: 'Wallet connected successfully',
    data: { walletAddress },
  });
}));

// Helper: Calculate life path number from date of birth
function calculateLifePathNumber(dateOfBirth: string): number {
  const date = new Date(dateOfBirth);
  const day = date.getDate();
  const month = date.getMonth() + 1;
  const year = date.getFullYear();

  const sum = reduceToSingleDigit(day) + reduceToSingleDigit(month) + reduceToSingleDigit(year);
  return reduceToSingleDigit(sum);
}

function reduceToSingleDigit(num: number): number {
  if (num === 11 || num === 22 || num === 33) return num; // Master numbers
  while (num > 9) {
    num = num.toString().split('').reduce((a, b) => a + parseInt(b), 0);
  }
  return num;
}

export default router;
Properties · TS
// Property Routes
import { Router } from 'express';
import { z } from 'zod';
import { prisma } from '../utils/prisma';
import { 
  cacheGet, 
  cacheSet, 
  cacheDelete, 
  cacheDeletePattern,
  CACHE_KEYS, 
  CACHE_TTL 
} from '../utils/redis';
import { 
  authenticate, 
  optionalAuthenticate,
  requireAgent,
  requireSubscription,
  AuthenticatedRequest 
} from '../middleware/auth';
import { 
  asyncHandler, 
  BadRequestError, 
  NotFoundError,
  ForbiddenError 
} from '../middleware/errorHandler';
import { logger } from '../utils/logger';

const router = Router();

// Validation schemas
const createPropertySchema = z.object({
  title: z.string().min(5, 'Title must be at least 5 characters'),
  description: z.string().min(20, 'Description must be at least 20 characters'),
  propertyType: z.enum(['HOUSE', 'CONDO', 'TOWNHOUSE', 'APARTMENT', 'LAND', 'MULTI_FAMILY', 'COMMERCIAL', 'VILLA', 'PENTHOUSE', 'FARMHOUSE', 'ASHRAM', 'PLOT']),
  listingType: z.enum(['SALE', 'RENT', 'LEASE', 'AUCTION']),
  
  // Location
  streetAddress: z.string().min(1, 'Street address is required'),
  unit: z.string().optional(),
  city: z.string().min(1, 'City is required'),
  state: z.string().min(1, 'State is required'),
  zipCode: z.string().min(1, 'ZIP code is required'),
  country: z.string().default('USA'),
  latitude: z.number(),
  longitude: z.number(),
  
  // Details
  price: z.number().positive('Price must be positive'),
  bedrooms: z.number().int().min(0),
  bathrooms: z.number().min(0),
  squareFeet: z.number().int().positive().optional(),
  lotSizeAcres: z.number().positive().optional(),
  yearBuilt: z.number().int().min(1800).max(new Date().getFullYear() + 2).optional(),
  stories: z.number().int().min(1).optional(),
  parkingSpaces: z.number().int().min(0).optional(),
  garageSpaces: z.number().int().min(0).optional(),
  constructionDate: z.string().optional(), // For Kundali matching
  
  // Features
  features: z.array(z.string()).default([]),
  amenities: z.array(z.string()).default([]),
  appliances: z.array(z.string()).default([]),
  flooring: z.array(z.string()).default([]),
  heating: z.array(z.string()).default([]),
  cooling: z.array(z.string()).default([]),
  roofType: z.string().optional(),
  exteriorMaterial: z.string().optional(),
  foundationType: z.string().optional(),
  
  // Media
  virtualTourUrl: z.string().url().optional(),
  videoUrl: z.string().url().optional(),
  floorPlanUrl: z.string().url().optional(),
  
  // Financial
  hoaFee: z.number().optional(),
  hoaFrequency: z.string().optional(),
  propertyTax: z.number().optional(),
  taxYear: z.number().int().optional(),
  
  // Photos (array of photo objects)
  photos: z.array(z.object({
    url: z.string().url(),
    thumbnailUrl: z.string().url().optional(),
    caption: z.string().optional(),
    roomType: z.string().optional(),
    orderIndex: z.number().int().default(0),
    isPrimary: z.boolean().default(false),
  })).optional(),
});

const updatePropertySchema = createPropertySchema.partial();

const propertyListQuerySchema = z.object({
  page: z.coerce.number().int().positive().default(1),
  limit: z.coerce.number().int().min(1).max(100).default(24),
  sortBy: z.enum(['price', 'createdAt', 'bedrooms', 'squareFeet', 'daysOnMarket']).default('createdAt'),
  sortOrder: z.enum(['asc', 'desc']).default('desc'),
  
  // Filters
  city: z.string().optional(),
  state: z.string().optional(),
  zipCode: z.string().optional(),
  minPrice: z.coerce.number().optional(),
  maxPrice: z.coerce.number().optional(),
  propertyType: z.string().optional(),
  listingType: z.enum(['SALE', 'RENT', 'LEASE', 'AUCTION']).optional(),
  status: z.enum(['ACTIVE', 'PENDING', 'SOLD', 'OFF_MARKET', 'COMING_SOON']).optional(),
  minBedrooms: z.coerce.number().int().optional(),
  maxBedrooms: z.coerce.number().int().optional(),
  minBathrooms: z.coerce.number().optional(),
  maxBathrooms: z.coerce.number().optional(),
  minSquareFeet: z.coerce.number().int().optional(),
  maxSquareFeet: z.coerce.number().int().optional(),
  minYearBuilt: z.coerce.number().int().optional(),
  maxYearBuilt: z.coerce.number().int().optional(),
  features: z.string().optional(), // Comma-separated list
  
  // Vastu filter
  minVastuScore: z.coerce.number().int().min(0).max(100).optional(),
  
  // Climate filter
  maxClimateRisk: z.coerce.number().int().min(0).max(100).optional(),
  
  // Geo search
  latitude: z.coerce.number().optional(),
  longitude: z.coerce.number().optional(),
  radiusMiles: z.coerce.number().positive().optional(),
});

/**
 * @swagger
 * /properties:
 *   get:
 *     summary: List properties with filters
 *     tags: [Properties]
 */
router.get('/', optionalAuthenticate, asyncHandler(async (req: AuthenticatedRequest, res) => {
  const query = propertyListQuerySchema.parse(req.query);
  const { page, limit, sortBy, sortOrder, ...filters } = query;
  
  // Build cache key from query
  const cacheKey = `${CACHE_KEYS.PROPERTY_LIST}${JSON.stringify(query)}`;
  
  // Try cache
  const cached = await cacheGet(cacheKey);
  if (cached) {
    return res.json({ success: true, data: cached });
  }

  // Build where clause
  const where: any = {
    status: filters.status || 'ACTIVE',
  };

  if (filters.city) where.city = { contains: filters.city, mode: 'insensitive' };
  if (filters.state) where.state = filters.state;
  if (filters.zipCode) where.zipCode = filters.zipCode;
  if (filters.propertyType) {
    where.propertyType = { in: filters.propertyType.split(',') };
  }
  if (filters.listingType) where.listingType = filters.listingType;
  
  if (filters.minPrice || filters.maxPrice) {
    where.price = {};
    if (filters.minPrice) where.price.gte = filters.minPrice;
    if (filters.maxPrice) where.price.lte = filters.maxPrice;
  }
  
  if (filters.minBedrooms || filters.maxBedrooms) {
    where.bedrooms = {};
    if (filters.minBedrooms) where.bedrooms.gte = filters.minBedrooms;
    if (filters.maxBedrooms) where.bedrooms.lte = filters.maxBedrooms;
  }
  
  if (filters.minBathrooms || filters.maxBathrooms) {
    where.bathrooms = {};
    if (filters.minBathrooms) where.bathrooms.gte = filters.minBathrooms;
    if (filters.maxBathrooms) where.bathrooms.lte = filters.maxBathrooms;
  }
  
  if (filters.minSquareFeet || filters.maxSquareFeet) {
    where.squareFeet = {};
    if (filters.minSquareFeet) where.squareFeet.gte = filters.minSquareFeet;
    if (filters.maxSquareFeet) where.squareFeet.lte = filters.maxSquareFeet;
  }
  
  if (filters.minYearBuilt || filters.maxYearBuilt) {
    where.yearBuilt = {};
    if (filters.minYearBuilt) where.yearBuilt.gte = filters.minYearBuilt;
    if (filters.maxYearBuilt) where.yearBuilt.lte = filters.maxYearBuilt;
  }
  
  if (filters.features) {
    where.features = { hasEvery: filters.features.split(',') };
  }
  
  // Vastu score filter
  if (filters.minVastuScore) {
    where.vastuAnalysis = {
      overallScore: { gte: filters.minVastuScore },
    };
  }
  
  // Climate risk filter
  if (filters.maxClimateRisk) {
    where.climateAnalysis = {
      overallRiskScore: { lte: filters.maxClimateRisk },
    };
  }

  // Geo search - using raw SQL for distance calculation
  let geoFilter = '';
  if (filters.latitude && filters.longitude && filters.radiusMiles) {
    // Haversine formula in raw SQL would be added here
    // For now, we'll do a simple bounding box filter
    const latDelta = filters.radiusMiles / 69; // Approx miles per degree latitude
    const lonDelta = filters.radiusMiles / (69 * Math.cos(filters.latitude * Math.PI / 180));
    
    where.latitude = {
      gte: filters.latitude - latDelta,
      lte: filters.latitude + latDelta,
    };
    where.longitude = {
      gte: filters.longitude - lonDelta,
      lte: filters.longitude + lonDelta,
    };
  }

  // Execute query
  const [properties, total] = await Promise.all([
    prisma.property.findMany({
      where,
      skip: (page - 1) * limit,
      take: limit,
      orderBy: { [sortBy]: sortOrder },
      select: {
        id: true,
        mlsId: true,
        title: true,
        streetAddress: true,
        city: true,
        state: true,
        zipCode: true,
        latitude: true,
        longitude: true,
        price: true,
        pricePerSqft: true,
        bedrooms: true,
        bathrooms: true,
        squareFeet: true,
        lotSizeAcres: true,
        yearBuilt: true,
        propertyType: true,
        listingType: true,
        status: true,
        features: true,
        daysOnMarket: true,
        viewCount: true,
        favoriteCount: true,
        virtualTourUrl: true,
        smartHomeScore: true,
        photos: {
          where: { isPrimary: true },
          take: 1,
          select: { url: true, thumbnailUrl: true },
        },
        vastuAnalysis: {
          select: {
            overallScore: true,
            grade: true,
          },
        },
        climateAnalysis: {
          select: {
            overallRiskScore: true,
            riskGrade: true,
          },
        },
        listingAgent: {
          select: {
            id: true,
            user: {
              select: {
                firstName: true,
                lastName: true,
                profilePhotoUrl: true,
              },
            },
            rating: true,
          },
        },
      },
    }),
    prisma.property.count({ where }),
  ]);

  const result = {
    properties,
    pagination: {
      page,
      limit,
      total,
      totalPages: Math.ceil(total / limit),
    },
  };

  // Cache result
  await cacheSet(cacheKey, result, CACHE_TTL.SHORT);

  res.json({
    success: true,
    data: result,
  });
}));

/**
 * @swagger
 * /properties/{id}:
 *   get:
 *     summary: Get property details
 *     tags: [Properties]
 */
router.get('/:id', optionalAuthenticate, asyncHandler(async (req: AuthenticatedRequest, res) => {
  const { id } = req.params;
  
  // Try cache
  const cacheKey = `${CACHE_KEYS.PROPERTY}${id}`;
  const cached = await cacheGet(cacheKey);
  if (cached) {
    // Track view asynchronously
    trackPropertyView(id, req.user?.id);
    return res.json({ success: true, data: cached });
  }

  const property = await prisma.property.findUnique({
    where: { id },
    include: {
      photos: {
        orderBy: { orderIndex: 'asc' },
      },
      priceHistory: {
        orderBy: { changeDate: 'desc' },
        take: 10,
      },
      vastuAnalysis: true,
      fengShuiAnalysis: true,
      climateAnalysis: true,
      environmentalData: true,
      sacredGeometry: true,
      landEnergy: true,
      energyAnalysis: true,
      neighborhood: {
        select: {
          id: true,
          name: true,
          medianHomePrice: true,
          priceTrend6Month: true,
          walkabilityScore: true,
          transitScore: true,
          bikeScore: true,
          crimeIndex: true,
          schoolRating: true,
        },
      },
      listingAgent: {
        select: {
          id: true,
          yearsExperience: true,
          specialties: true,
          rating: true,
          reviewCount: true,
          ethicsScore: true,
          user: {
            select: {
              firstName: true,
              lastName: true,
              phone: true,
              email: true,
              profilePhotoUrl: true,
            },
          },
        },
      },
      openHouses: {
        where: {
          startTime: { gte: new Date() },
        },
        orderBy: { startTime: 'asc' },
        take: 5,
      },
      iotSensors: {
        select: {
          sensorType: true,
          lastReading: true,
          status: true,
        },
      },
    },
  });

  if (!property) {
    throw new NotFoundError('Property not found');
  }

  // Calculate estimated monthly payment
  const estimatedPayment = calculateEstimatedPayment(Number(property.price), {
    propertyTax: Number(property.propertyTax) || 0,
    hoaFee: Number(property.hoaFee) || 0,
  });

  // Get favorites count for this user
  let isFavorited = false;
  if (req.user) {
    const favorite = await prisma.favorite.findUnique({
      where: {
        userId_propertyId: {
          userId: req.user.id,
          propertyId: id,
        },
      },
    });
    isFavorited = !!favorite;
  }

  const result = {
    ...property,
    estimatedPayment,
    isFavorited,
  };

  // Cache result
  await cacheSet(cacheKey, result, CACHE_TTL.MEDIUM);

  // Track view
  trackPropertyView(id, req.user?.id);

  res.json({
    success: true,
    data: result,
  });
}));

/**
 * @swagger
 * /properties:
 *   post:
 *     summary: Create a new property listing (Agent only)
 *     tags: [Properties]
 *     security:
 *       - bearerAuth: []
 */
router.post('/', authenticate, requireAgent, asyncHandler(async (req: AuthenticatedRequest, res) => {
  const data = createPropertySchema.parse(req.body);

  // Calculate price per sqft
  const pricePerSqft = data.squareFeet 
    ? data.price / data.squareFeet 
    : null;

  // Create property
  const property = await prisma.property.create({
    data: {
      ...data,
      pricePerSqft,
      originalPrice: data.price,
      listingAgentId: req.user!.agentId,
      photos: data.photos ? {
        create: data.photos.map((photo, index) => ({
          ...photo,
          orderIndex: photo.orderIndex ?? index,
          isPrimary: photo.isPrimary ?? index === 0,
        })),
      } : undefined,
      constructionDate: data.constructionDate ? new Date(data.constructionDate) : undefined,
    },
    include: {
      photos: true,
      listingAgent: {
        select: {
          user: {
            select: {
              firstName: true,
              lastName: true,
            },
          },
        },
      },
    },
  });

  // Clear list caches
  await cacheDeletePattern(`${CACHE_KEYS.PROPERTY_LIST}*`);

  logger.info(`Property created: ${property.id} by agent ${req.user!.agentId}`);

  res.status(201).json({
    success: true,
    data: property,
  });
}));

/**
 * @swagger
 * /properties/{id}:
 *   put:
 *     summary: Update a property listing (Owner agent only)
 *     tags: [Properties]
 *     security:
 *       - bearerAuth: []
 */
router.put('/:id', authenticate, requireAgent, asyncHandler(async (req: AuthenticatedRequest, res) => {
  const { id } = req.params;
  const data = updatePropertySchema.parse(req.body);

  // Check ownership
  const property = await prisma.property.findUnique({
    where: { id },
    select: { listingAgentId: true, price: true },
  });

  if (!property) {
    throw new NotFoundError('Property not found');
  }

  if (property.listingAgentId !== req.user!.agentId) {
    throw new ForbiddenError('You can only edit your own listings');
  }

  // Track price change
  if (data.price && data.price !== Number(property.price)) {
    await prisma.priceHistory.create({
      data: {
        propertyId: id,
        previousPrice: property.price,
        newPrice: data.price,
        changeReason: 'Price update',
      },
    });
  }

  // Update property
  const updated = await prisma.property.update({
    where: { id },
    data: {
      ...data,
      pricePerSqft: data.squareFeet && data.price 
        ? data.price / data.squareFeet 
        : undefined,
      updatedAt: new Date(),
    },
    include: {
      photos: true,
    },
  });

  // Clear caches
  await cacheDelete(`${CACHE_KEYS.PROPERTY}${id}`);
  await cacheDeletePattern(`${CACHE_KEYS.PROPERTY_LIST}*`);

  logger.info(`Property updated: ${id} by agent ${req.user!.agentId}`);

  res.json({
    success: true,
    data: updated,
  });
}));

/**
 * @swagger
 * /properties/{id}:
 *   delete:
 *     summary: Delete a property listing (Owner agent only)
 *     tags: [Properties]
 *     security:
 *       - bearerAuth: []
 */
router.delete('/:id', authenticate, requireAgent, asyncHandler(async (req: AuthenticatedRequest, res) => {
  const { id } = req.params;

  // Check ownership
  const property = await prisma.property.findUnique({
    where: { id },
    select: { listingAgentId: true },
  });

  if (!property) {
    throw new NotFoundError('Property not found');
  }

  if (property.listingAgentId !== req.user!.agentId && req.user!.userType !== 'ADMIN') {
    throw new ForbiddenError('You can only delete your own listings');
  }

  // Delete property (cascades to related records)
  await prisma.property.delete({
    where: { id },
  });

  // Clear caches
  await cacheDelete(`${CACHE_KEYS.PROPERTY}${id}`);
  await cacheDeletePattern(`${CACHE_KEYS.PROPERTY_LIST}*`);

  logger.info(`Property deleted: ${id} by agent ${req.user!.agentId}`);

  res.json({
    success: true,
    message: 'Property deleted successfully',
  });
}));

/**
 * @swagger
 * /properties/{id}/photos:
 *   post:
 *     summary: Add photos to a property
 *     tags: [Properties]
 *     security:
 *       - bearerAuth: []
 */
router.post('/:id/photos', authenticate, requireAgent, asyncHandler(async (req: AuthenticatedRequest, res) => {
  const { id } = req.params;
  const { photos } = req.body;

  // Check ownership
  const property = await prisma.property.findUnique({
    where: { id },
    select: { listingAgentId: true },
  });

  if (!property) {
    throw new NotFoundError('Property not found');
  }

  if (property.listingAgentId !== req.user!.agentId) {
    throw new ForbiddenError('You can only edit your own listings');
  }

  // Get current max order index
  const maxOrder = await prisma.propertyPhoto.findFirst({
    where: { propertyId: id },
    orderBy: { orderIndex: 'desc' },
    select: { orderIndex: true },
  });

  const startIndex = (maxOrder?.orderIndex || 0) + 1;

  // Create photos
  const created = await prisma.propertyPhoto.createMany({
    data: photos.map((photo: any, index: number) => ({
      propertyId: id,
      url: photo.url,
      thumbnailUrl: photo.thumbnailUrl,
      caption: photo.caption,
      roomType: photo.roomType,
      orderIndex: startIndex + index,
      isPrimary: false,
    })),
  });

  // Clear cache
  await cacheDelete(`${CACHE_KEYS.PROPERTY}${id}`);

  res.status(201).json({
    success: true,
    data: { count: created.count },
  });
}));

/**
 * @swagger
 * /properties/{id}/similar:
 *   get:
 *     summary: Get similar properties
 *     tags: [Properties]
 */
router.get('/:id/similar', optionalAuthenticate, asyncHandler(async (req: AuthenticatedRequest, res) => {
  const { id } = req.params;
  const limit = parseInt(req.query.limit as string) || 6;

  const property = await prisma.property.findUnique({
    where: { id },
    select: {
      city: true,
      state: true,
      price: true,
      bedrooms: true,
      propertyType: true,
      latitude: true,
      longitude: true,
    },
  });

  if (!property) {
    throw new NotFoundError('Property not found');
  }

  const priceRange = Number(property.price) * 0.2; // 20% price range

  const similar = await prisma.property.findMany({
    where: {
      id: { not: id },
      status: 'ACTIVE',
      propertyType: property.propertyType,
      city: property.city,
      price: {
        gte: Number(property.price) - priceRange,
        lte: Number(property.price) + priceRange,
      },
      bedrooms: {
        gte: property.bedrooms - 1,
        lte: property.bedrooms + 1,
      },
    },
    take: limit,
    orderBy: { price: 'asc' },
    select: {
      id: true,
      title: true,
      streetAddress: true,
      city: true,
      state: true,
      price: true,
      bedrooms: true,
      bathrooms: true,
      squareFeet: true,
      photos: {
        where: { isPrimary: true },
        take: 1,
        select: { url: true, thumbnailUrl: true },
      },
      vastuAnalysis: {
        select: { overallScore: true },
      },
    },
  });

  res.json({
    success: true,
    data: similar,
  });
}));

/**
 * @swagger
 * /properties/{id}/schedule-showing:
 *   post:
 *     summary: Schedule a property showing
 *     tags: [Properties]
 *     security:
 *       - bearerAuth: []
 */
router.post('/:id/schedule-showing', authenticate, asyncHandler(async (req: AuthenticatedRequest, res) => {
  const { id } = req.params;
  const { scheduledAt, type, notes } = req.body;

  const property = await prisma.property.findUnique({
    where: { id },
    select: { 
      id: true, 
      listingAgentId: true,
      title: true,
      streetAddress: true,
    },
  });

  if (!property) {
    throw new NotFoundError('Property not found');
  }

  // Create or get lead
  let lead = await prisma.lead.findFirst({
    where: {
      propertyId: id,
      userId: req.user!.id,
    },
  });

  if (!lead) {
    const user = await prisma.user.findUnique({
      where: { id: req.user!.id },
      select: { firstName: true, lastName: true, email: true, phone: true },
    });

    lead = await prisma.lead.create({
      data: {
        propertyId: id,
        agentId: property.listingAgentId,
        userId: req.user!.id,
        name: `${user!.firstName} ${user!.lastName}`,
        email: user!.email,
        phone: user!.phone,
        status: 'SHOWING_SCHEDULED',
        source: 'INQUIRY',
      },
    });
  }

  // Create showing
  const showing = await prisma.showing.create({
    data: {
      leadId: lead.id,
      scheduledAt: new Date(scheduledAt),
      type: type || 'IN_PERSON',
      notes,
      status: 'SCHEDULED',
    },
  });

  // Update lead status
  await prisma.lead.update({
    where: { id: lead.id },
    data: { status: 'SHOWING_SCHEDULED' },
  });

  // TODO: Send notification to agent
  // TODO: Send confirmation email to user

  res.status(201).json({
    success: true,
    data: showing,
  });
}));

// Helper: Track property view
async function trackPropertyView(propertyId: string, userId?: string) {
  try {
    // Increment view count
    await prisma.property.update({
      where: { id: propertyId },
      data: { viewCount: { increment: 1 } },
    });

    // Record view
    await prisma.propertyView.create({
      data: {
        propertyId,
        userId,
      },
    });
  } catch (error) {
    logger.error('Error tracking property view:', error);
  }
}

// Helper: Calculate estimated monthly payment
function calculateEstimatedPayment(
  price: number,
  options: { propertyTax?: number; hoaFee?: number; downPaymentPercent?: number; interestRate?: number; loanTermYears?: number }
) {
  const {
    propertyTax = 0,
    hoaFee = 0,
    downPaymentPercent = 20,
    interestRate = 6.5,
    loanTermYears = 30,
  } = options;

  const downPayment = price * (downPaymentPercent / 100);
  const loanAmount = price - downPayment;
  const monthlyRate = interestRate / 100 / 12;
  const numPayments = loanTermYears * 12;

  // Principal & Interest
  const principalInterest = loanAmount * 
    (monthlyRate * Math.pow(1 + monthlyRate, numPayments)) / 
    (Math.pow(1 + monthlyRate, numPayments) - 1);

  // Monthly property tax
  const monthlyTax = propertyTax / 12;

  // Estimated insurance (0.35% of home value annually)
  const monthlyInsurance = (price * 0.0035) / 12;

  // HOA
  const monthlyHoa = hoaFee;

  return {
    principalInterest: Math.round(principalInterest),
    propertyTax: Math.round(monthlyTax),
    insurance: Math.round(monthlyInsurance),
    hoa: Math.round(monthlyHoa),
    total: Math.round(principalInterest + monthlyTax + monthlyInsurance + monthlyHoa),
  };
}

export default router;
Vastu · TS
// Vastu Shastra AI Analysis Routes
import { Router } from 'express';
import { z } from 'zod';
import { prisma } from '../utils/prisma';
import { 
  cacheGet, 
  cacheSet, 
  CACHE_KEYS, 
  CACHE_TTL 
} from '../utils/redis';
import { 
  authenticate, 
  requireSubscription,
  AuthenticatedRequest 
} from '../middleware/auth';
import { 
  asyncHandler, 
  BadRequestError, 
  NotFoundError 
} from '../middleware/errorHandler';
import { logger } from '../utils/logger';

const router = Router();

// Vastu Rules Database - Comprehensive set of rules from ancient texts
const VASTU_RULES = {
  entrance: {
    NORTH: { score: 90, energy: 'positive', deity: 'Kubera', effect: 'wealth' },
    NORTH_EAST: { score: 100, energy: 'highly_positive', deity: 'Ishaan', effect: 'prosperity' },
    EAST: { score: 95, energy: 'positive', deity: 'Indra', effect: 'health' },
    SOUTH_EAST: { score: 60, energy: 'neutral', deity: 'Agni', effect: 'fire_element' },
    SOUTH: { score: 40, energy: 'negative', deity: 'Yama', effect: 'obstacles' },
    SOUTH_WEST: { score: 30, energy: 'highly_negative', deity: 'Nairutya', effect: 'instability' },
    WEST: { score: 70, energy: 'neutral', deity: 'Varuna', effect: 'water_element' },
    NORTH_WEST: { score: 75, energy: 'positive', deity: 'Vayu', effect: 'movement' },
  },
  
  rooms: {
    kitchen: {
      ideal: ['SOUTH_EAST'],
      acceptable: ['NORTH_WEST', 'SOUTH'],
      avoid: ['NORTH_EAST', 'SOUTH_WEST'],
      deity: 'Agni',
      element: 'fire',
    },
    masterBedroom: {
      ideal: ['SOUTH_WEST'],
      acceptable: ['SOUTH', 'WEST'],
      avoid: ['NORTH_EAST', 'SOUTH_EAST'],
      deity: 'Nairutya',
      element: 'earth',
    },
    bathroom: {
      ideal: ['NORTH_WEST', 'WEST'],
      acceptable: ['SOUTH'],
      avoid: ['NORTH_EAST', 'SOUTH_WEST', 'CENTER'],
      element: 'water',
    },
    poojaRoom: {
      ideal: ['NORTH_EAST'],
      acceptable: ['NORTH', 'EAST'],
      avoid: ['SOUTH', 'SOUTH_WEST', 'SOUTH_EAST'],
      deity: 'Ishaan',
      element: 'ether',
    },
    livingRoom: {
      ideal: ['NORTH', 'EAST', 'NORTH_EAST'],
      acceptable: ['NORTH_WEST'],
      avoid: ['SOUTH_WEST'],
      element: 'air',
    },
    study: {
      ideal: ['NORTH_EAST', 'EAST', 'NORTH'],
      acceptable: ['WEST'],
      avoid: ['SOUTH_WEST'],
      element: 'air',
    },
    dining: {
      ideal: ['WEST', 'EAST'],
      acceptable: ['NORTH'],
      avoid: ['SOUTH_EAST'],
      element: 'earth',
    },
    guestRoom: {
      ideal: ['NORTH_WEST'],
      acceptable: ['WEST', 'NORTH'],
      avoid: ['SOUTH_WEST'],
      element: 'air',
    },
  },
  
  slope: {
    ideal: { northEast: 'lowest', southWest: 'highest' },
    acceptable: { north: 'lower', south: 'higher' },
  },
  
  waterSources: {
    ideal: ['NORTH', 'NORTH_EAST', 'EAST'],
    acceptable: ['NORTH_WEST'],
    avoid: ['SOUTH', 'SOUTH_WEST', 'SOUTH_EAST'],
  },
  
  staircase: {
    idealDirection: ['WEST', 'SOUTH'],
    avoidDirection: ['NORTH_EAST', 'CENTER'],
    preferClockwise: true,
  },
};

// Remedies Database
const VASTU_REMEDIES = {
  entrance_south_west: [
    {
      type: 'structural',
      description: 'Relocate main entrance to North or East direction',
      cost_estimate: 50000,
      effectiveness: 100,
      difficulty: 'high',
    },
    {
      type: 'placement',
      description: 'Place Ganesha idol outside entrance facing outward',
      cost_estimate: 500,
      effectiveness: 60,
      difficulty: 'low',
    },
    {
      type: 'symbolic',
      description: 'Install Vastu pyramid at entrance, paint door green, hang sacred toran',
      cost_estimate: 200,
      effectiveness: 40,
      difficulty: 'low',
    },
  ],
  
  kitchen_north_east: [
    {
      type: 'structural',
      description: 'Relocate kitchen to South-East (Agni) direction',
      cost_estimate: 75000,
      effectiveness: 100,
      difficulty: 'high',
    },
    {
      type: 'placement',
      description: 'Place copper vessel with water in kitchen, cook facing East',
      cost_estimate: 100,
      effectiveness: 50,
      difficulty: 'low',
    },
    {
      type: 'symbolic',
      description: 'Install Agni yantra, use red/orange colors in kitchen',
      cost_estimate: 150,
      effectiveness: 35,
      difficulty: 'low',
    },
  ],
  
  bathroom_north_east: [
    {
      type: 'structural',
      description: 'Convert to prayer room or study, relocate bathroom',
      cost_estimate: 100000,
      effectiveness: 100,
      difficulty: 'high',
    },
    {
      type: 'placement',
      description: 'Keep bathroom door always closed, place sea salt bowl inside',
      cost_estimate: 50,
      effectiveness: 40,
      difficulty: 'low',
    },
    {
      type: 'symbolic',
      description: 'Install mirror on North wall, use light colors, add plants',
      cost_estimate: 200,
      effectiveness: 30,
      difficulty: 'low',
    },
  ],
  
  bedroom_north_east: [
    {
      type: 'structural',
      description: 'Convert to meditation room or study',
      cost_estimate: 25000,
      effectiveness: 100,
      difficulty: 'medium',
    },
    {
      type: 'placement',
      description: 'Sleep with head towards South, place heavy furniture in South-West',
      cost_estimate: 100,
      effectiveness: 50,
      difficulty: 'low',
    },
  ],
  
  center_blocked: [
    {
      type: 'structural',
      description: 'Keep Brahmasthan (center) open, remove pillars/walls',
      cost_estimate: 40000,
      effectiveness: 100,
      difficulty: 'high',
    },
    {
      type: 'placement',
      description: 'If unavoidable, place tulsi plant or crystal in center',
      cost_estimate: 100,
      effectiveness: 45,
      difficulty: 'low',
    },
  ],
};

// Validation schemas
const analyzeFloorPlanSchema = z.object({
  propertyId: z.string().uuid().optional(),
  floorPlanUrl: z.string().url().optional(),
  orientation: z.enum(['NORTH', 'SOUTH', 'EAST', 'WEST', 'NORTH_EAST', 'NORTH_WEST', 'SOUTH_EAST', 'SOUTH_WEST']),
  propertyType: z.enum(['HOUSE', 'APARTMENT', 'COMMERCIAL', 'VILLA', 'FARMHOUSE']).default('HOUSE'),
  
  // Manual room input (if no AI detection)
  rooms: z.array(z.object({
    type: z.string(),
    direction: z.enum(['NORTH', 'SOUTH', 'EAST', 'WEST', 'NORTH_EAST', 'NORTH_WEST', 'SOUTH_EAST', 'SOUTH_WEST', 'CENTER']),
    coordinates: z.object({
      x: z.number(),
      y: z.number(),
      width: z.number(),
      height: z.number(),
    }).optional(),
  })).optional(),
  
  entrance: z.object({
    direction: z.enum(['NORTH', 'SOUTH', 'EAST', 'WEST', 'NORTH_EAST', 'NORTH_WEST', 'SOUTH_EAST', 'SOUTH_WEST']),
    position: z.enum(['LEFT', 'CENTER', 'RIGHT']).optional(),
  }),
  
  slope: z.object({
    lowest: z.enum(['NORTH', 'SOUTH', 'EAST', 'WEST', 'NORTH_EAST', 'NORTH_WEST', 'SOUTH_EAST', 'SOUTH_WEST']).optional(),
    highest: z.enum(['NORTH', 'SOUTH', 'EAST', 'WEST', 'NORTH_EAST', 'NORTH_WEST', 'SOUTH_EAST', 'SOUTH_WEST']).optional(),
  }).optional(),
  
  waterSources: z.array(z.object({
    type: z.string(), // well, borewell, tank, etc.
    direction: z.enum(['NORTH', 'SOUTH', 'EAST', 'WEST', 'NORTH_EAST', 'NORTH_WEST', 'SOUTH_EAST', 'SOUTH_WEST']),
  })).optional(),
  
  staircase: z.object({
    direction: z.enum(['NORTH', 'SOUTH', 'EAST', 'WEST', 'NORTH_EAST', 'NORTH_WEST', 'SOUTH_EAST', 'SOUTH_WEST', 'CENTER']).optional(),
    rotation: z.enum(['CLOCKWISE', 'ANTICLOCKWISE']).optional(),
  }).optional(),
  
  language: z.enum(['en', 'hi', 'ta', 'te', 'mr', 'gu', 'bn']).default('en'),
});

/**
 * @swagger
 * /vastu/analyze:
 *   post:
 *     summary: Analyze property for Vastu compliance
 *     tags: [Vastu]
 *     security:
 *       - bearerAuth: []
 */
router.post('/analyze', authenticate, asyncHandler(async (req: AuthenticatedRequest, res) => {
  const data = analyzeFloorPlanSchema.parse(req.body);
  
  logger.info(`Vastu analysis requested by user ${req.user!.id}`);

  // Initialize analysis result
  const analysis: any = {
    overallScore: 0,
    grade: '',
    issues: [],
    recommendations: [],
    zoneScores: {},
    roomAnalysis: {},
  };

  // 1. Analyze Entrance Direction
  const entranceRule = VASTU_RULES.entrance[data.entrance.direction];
  analysis.entranceAnalysis = {
    direction: data.entrance.direction,
    score: entranceRule.score,
    energy: entranceRule.energy,
    deity: entranceRule.deity,
    effect: entranceRule.effect,
    isIdeal: entranceRule.score >= 90,
  };

  if (entranceRule.score < 70) {
    analysis.issues.push({
      type: 'entrance',
      severity: entranceRule.score < 50 ? 'critical' : 'moderate',
      direction: data.entrance.direction,
      description: `Main entrance is in ${data.entrance.direction} direction. ${
        entranceRule.energy === 'highly_negative' 
          ? 'This is considered highly inauspicious and may bring obstacles and instability.' 
          : 'This direction is not ideal for prosperity.'
      }`,
      vastuPrinciple: `Entrance should ideally be in North-East (Ishaan) or North (Kubera) for prosperity and wealth.`,
      remedies: getRemedies('entrance', data.entrance.direction),
    });
  }

  // 2. Analyze Room Placements
  if (data.rooms) {
    for (const room of data.rooms) {
      const roomRules = VASTU_RULES.rooms[room.type.toLowerCase() as keyof typeof VASTU_RULES.rooms];
      
      if (roomRules) {
        const isIdeal = roomRules.ideal.includes(room.direction);
        const isAcceptable = roomRules.acceptable.includes(room.direction);
        const isToAvoid = roomRules.avoid.includes(room.direction);
        
        let roomScore = 100;
        if (isIdeal) roomScore = 100;
        else if (isAcceptable) roomScore = 70;
        else if (isToAvoid) roomScore = 30;
        else roomScore = 50;

        analysis.roomAnalysis[room.type] = {
          currentDirection: room.direction,
          idealDirections: roomRules.ideal,
          score: roomScore,
          isIdeal,
          isAcceptable,
          isToAvoid,
          element: roomRules.element,
          deity: roomRules.deity,
        };

        if (isToAvoid) {
          analysis.issues.push({
            type: room.type,
            severity: 'critical',
            direction: room.direction,
            description: `${room.type.charAt(0).toUpperCase() + room.type.slice(1)} is placed in ${room.direction} direction, which should be avoided.`,
            vastuPrinciple: `${room.type.charAt(0).toUpperCase() + room.type.slice(1)} should ideally be in ${roomRules.ideal.join(' or ')} direction.`,
            remedies: getRemedies(room.type, room.direction),
          });
        } else if (!isIdeal && !isAcceptable) {
          analysis.issues.push({
            type: room.type,
            severity: 'minor',
            direction: room.direction,
            description: `${room.type.charAt(0).toUpperCase() + room.type.slice(1)} placement could be improved.`,
            vastuPrinciple: `Consider ${roomRules.ideal.join(' or ')} for optimal energy flow.`,
          });
        }
      }
    }
  }

  // 3. Analyze Slope
  if (data.slope) {
    const idealSlope = data.slope.lowest === 'NORTH_EAST' && data.slope.highest === 'SOUTH_WEST';
    analysis.slopeAnalysis = {
      current: data.slope,
      isIdeal: idealSlope,
      score: idealSlope ? 100 : 50,
    };

    if (!idealSlope) {
      analysis.issues.push({
        type: 'slope',
        severity: 'moderate',
        description: 'Land slope is not in the ideal Vastu direction.',
        vastuPrinciple: 'Land should slope from South-West (highest) to North-East (lowest) for prosperity.',
        remedies: [
          {
            type: 'structural',
            description: 'Grade the land to slope towards North-East',
            cost_estimate: 20000,
            effectiveness: 100,
            difficulty: 'high',
          },
          {
            type: 'placement',
            description: 'Place heavy elements (boulders, structures) in South-West',
            cost_estimate: 5000,
            effectiveness: 60,
            difficulty: 'medium',
          },
        ],
      });
    }
  }

  // 4. Analyze Water Sources
  if (data.waterSources && data.waterSources.length > 0) {
    for (const water of data.waterSources) {
      const isIdeal = VASTU_RULES.waterSources.ideal.includes(water.direction);
      const isToAvoid = VASTU_RULES.waterSources.avoid.includes(water.direction);

      if (isToAvoid) {
        analysis.issues.push({
          type: 'water_source',
          severity: 'moderate',
          direction: water.direction,
          description: `Water source (${water.type}) is in ${water.direction}, which can disturb energy flow.`,
          vastuPrinciple: 'Water sources should be in North, North-East, or East for abundance.',
          remedies: [
            {
              type: 'structural',
              description: 'Relocate water source to North-East or North',
              cost_estimate: 30000,
              effectiveness: 100,
              difficulty: 'high',
            },
            {
              type: 'symbolic',
              description: 'Place Varuna yantra near water source, add aquatic plants',
              cost_estimate: 200,
              effectiveness: 40,
              difficulty: 'low',
            },
          ],
        });
      }
    }
  }

  // 5. Analyze Staircase
  if (data.staircase) {
    const isIdealDirection = VASTU_RULES.staircase.idealDirection.includes(data.staircase.direction!);
    const isToAvoid = VASTU_RULES.staircase.avoidDirection.includes(data.staircase.direction!);
    const isClockwise = data.staircase.rotation === 'CLOCKWISE';

    if (isToAvoid || !isClockwise) {
      analysis.issues.push({
        type: 'staircase',
        severity: isToAvoid ? 'critical' : 'minor',
        description: `Staircase ${isToAvoid ? 'is in ' + data.staircase.direction + ' (should be avoided)' : ''} ${!isClockwise ? 'rotates anticlockwise' : ''}`,
        vastuPrinciple: 'Staircase should be in South or West, rotating clockwise when ascending.',
        remedies: [
          {
            type: 'placement',
            description: 'Place a mirror on the North wall of staircase, use light colors',
            cost_estimate: 500,
            effectiveness: 40,
            difficulty: 'low',
          },
        ],
      });
    }
  }

  // Calculate Zone Scores (16-zone Vastu grid)
  const zones = ['NORTH', 'NORTH_EAST', 'EAST', 'SOUTH_EAST', 'SOUTH', 'SOUTH_WEST', 'WEST', 'NORTH_WEST', 'CENTER'];
  for (const zone of zones) {
    let zoneScore = 70; // Default neutral score
    
    // Adjust based on room placements
    if (data.rooms) {
      for (const room of data.rooms) {
        if (room.direction === zone) {
          const roomRules = VASTU_RULES.rooms[room.type.toLowerCase() as keyof typeof VASTU_RULES.rooms];
          if (roomRules) {
            if (roomRules.ideal.includes(zone)) zoneScore += 15;
            else if (roomRules.avoid.includes(zone)) zoneScore -= 20;
          }
        }
      }
    }
    
    analysis.zoneScores[zone] = Math.max(0, Math.min(100, zoneScore));
  }

  // Calculate Overall Score
  const entranceWeight = 0.25;
  const roomsWeight = 0.4;
  const slopeWeight = 0.15;
  const waterWeight = 0.1;
  const staircaseWeight = 0.1;

  let totalScore = analysis.entranceAnalysis.score * entranceWeight;
  
  if (Object.keys(analysis.roomAnalysis).length > 0) {
    const roomScores = Object.values(analysis.roomAnalysis).map((r: any) => r.score);
    const avgRoomScore = roomScores.reduce((a: number, b: number) => a + b, 0) / roomScores.length;
    totalScore += avgRoomScore * roomsWeight;
  } else {
    totalScore += 70 * roomsWeight; // Default if no rooms specified
  }

  if (analysis.slopeAnalysis) {
    totalScore += analysis.slopeAnalysis.score * slopeWeight;
  } else {
    totalScore += 70 * slopeWeight;
  }

  // Add remaining weights with default scores
  totalScore += 70 * waterWeight;
  totalScore += 70 * staircaseWeight;

  analysis.overallScore = Math.round(totalScore);

  // Determine Grade
  if (analysis.overallScore >= 90) analysis.grade = 'A+';
  else if (analysis.overallScore >= 80) analysis.grade = 'A';
  else if (analysis.overallScore >= 70) analysis.grade = 'B+';
  else if (analysis.overallScore >= 60) analysis.grade = 'B';
  else if (analysis.overallScore >= 50) analysis.grade = 'C';
  else if (analysis.overallScore >= 40) analysis.grade = 'D';
  else analysis.grade = 'F';

  // Count defects by severity
  analysis.criticalDefects = analysis.issues.filter((i: any) => i.severity === 'critical').length;
  analysis.moderateDefects = analysis.issues.filter((i: any) => i.severity === 'moderate').length;
  analysis.minorDefects = analysis.issues.filter((i: any) => i.severity === 'minor').length;

  // Calculate total remedy cost
  analysis.totalRemedyCost = analysis.issues.reduce((total: number, issue: any) => {
    if (issue.remedies) {
      const lowestCostRemedy = issue.remedies.reduce((min: any, r: any) => 
        r.cost_estimate < min.cost_estimate ? r : min, issue.remedies[0]);
      return total + (lowestCostRemedy?.cost_estimate || 0);
    }
    return total;
  }, 0);

  // Generate recommendations
  analysis.recommendations = generateRecommendations(analysis);

  // Save analysis if property ID provided
  if (data.propertyId) {
    await prisma.vastuAnalysis.upsert({
      where: { propertyId: data.propertyId },
      create: {
        propertyId: data.propertyId,
        overallScore: analysis.overallScore,
        grade: analysis.grade,
        entranceDirection: data.entrance.direction,
        entranceScore: analysis.entranceAnalysis.score,
        plotOrientation: data.orientation,
        plotScore: 70, // Default
        northEastScore: analysis.zoneScores['NORTH_EAST'] || 70,
        eastScore: analysis.zoneScores['EAST'] || 70,
        southEastScore: analysis.zoneScores['SOUTH_EAST'] || 70,
        southScore: analysis.zoneScores['SOUTH'] || 70,
        southWestScore: analysis.zoneScores['SOUTH_WEST'] || 70,
        westScore: analysis.zoneScores['WEST'] || 70,
        northWestScore: analysis.zoneScores['NORTH_WEST'] || 70,
        northScore: analysis.zoneScores['NORTH'] || 70,
        centerScore: analysis.zoneScores['CENTER'] || 70,
        kitchenPlacement: analysis.roomAnalysis['kitchen'] || {},
        masterBedroomPlacement: analysis.roomAnalysis['masterBedroom'] || {},
        bathroomPlacement: analysis.roomAnalysis['bathroom'] || {},
        poojaRoomPlacement: analysis.roomAnalysis['poojaRoom'] || {},
        studyRoomPlacement: analysis.roomAnalysis['study'] || {},
        livingRoomPlacement: analysis.roomAnalysis['livingRoom'] || {},
        defects: analysis.issues,
        criticalDefects: analysis.criticalDefects,
        moderateDefects: analysis.moderateDefects,
        minorDefects: analysis.minorDefects,
        remedies: analysis.issues.flatMap((i: any) => i.remedies || []),
        totalRemedyCost: analysis.totalRemedyCost,
        slopeAnalysis: analysis.slopeAnalysis,
      },
      update: {
        overallScore: analysis.overallScore,
        grade: analysis.grade,
        entranceDirection: data.entrance.direction,
        entranceScore: analysis.entranceAnalysis.score,
        defects: analysis.issues,
        criticalDefects: analysis.criticalDefects,
        moderateDefects: analysis.moderateDefects,
        minorDefects: analysis.minorDefects,
        remedies: analysis.issues.flatMap((i: any) => i.remedies || []),
        totalRemedyCost: analysis.totalRemedyCost,
        updatedAt: new Date(),
      },
    });
  }

  res.json({
    success: true,
    data: analysis,
  });
}));

/**
 * @swagger
 * /vastu/property/{propertyId}:
 *   get:
 *     summary: Get Vastu analysis for a property
 *     tags: [Vastu]
 */
router.get('/property/:propertyId', asyncHandler(async (req, res) => {
  const { propertyId } = req.params;

  const cacheKey = `${CACHE_KEYS.VASTU}${propertyId}`;
  const cached = await cacheGet(cacheKey);
  if (cached) {
    return res.json({ success: true, data: cached });
  }

  const analysis = await prisma.vastuAnalysis.findUnique({
    where: { propertyId },
  });

  if (!analysis) {
    throw new NotFoundError('Vastu analysis not found for this property');
  }

  await cacheSet(cacheKey, analysis, CACHE_TTL.LONG);

  res.json({
    success: true,
    data: analysis,
  });
}));

/**
 * @swagger
 * /vastu/rules:
 *   get:
 *     summary: Get Vastu rules reference
 *     tags: [Vastu]
 */
router.get('/rules', asyncHandler(async (req, res) => {
  res.json({
    success: true,
    data: {
      entrance: VASTU_RULES.entrance,
      rooms: Object.keys(VASTU_RULES.rooms).map(room => ({
        name: room,
        ...VASTU_RULES.rooms[room as keyof typeof VASTU_RULES.rooms],
      })),
      slope: VASTU_RULES.slope,
      waterSources: VASTU_RULES.waterSources,
      staircase: VASTU_RULES.staircase,
    },
  });
}));

/**
 * @swagger
 * /vastu/certificate/{propertyId}:
 *   get:
 *     summary: Generate Vastu compliance certificate
 *     tags: [Vastu]
 *     security:
 *       - bearerAuth: []
 */
router.get('/certificate/:propertyId', authenticate, asyncHandler(async (req: AuthenticatedRequest, res) => {
  const { propertyId } = req.params;

  const analysis = await prisma.vastuAnalysis.findUnique({
    where: { propertyId },
    include: {
      property: {
        select: {
          streetAddress: true,
          city: true,
          state: true,
          zipCode: true,
        },
      },
    },
  });

  if (!analysis) {
    throw new NotFoundError('Vastu analysis not found');
  }

  // Generate certificate data
  const certificate = {
    certificateId: `VASTU-${propertyId.slice(0, 8).toUpperCase()}-${Date.now()}`,
    propertyAddress: `${analysis.property.streetAddress}, ${analysis.property.city}, ${analysis.property.state} ${analysis.property.zipCode}`,
    analysisDate: analysis.analyzedAt,
    overallScore: analysis.overallScore,
    grade: analysis.grade,
    entranceDirection: analysis.entranceDirection,
    entranceScore: analysis.entranceScore,
    criticalIssues: analysis.criticalDefects,
    recommendations: analysis.remedies?.slice(0, 5),
    issuedBy: 'Dharma Realty Vastu AI',
    validUntil: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000), // 1 year validity
    // TODO: Add blockchain hash for verification
  };

  res.json({
    success: true,
    data: certificate,
  });
}));

/**
 * @swagger
 * /vastu/auspicious-timing:
 *   post:
 *     summary: Get auspicious timing for property transactions
 *     tags: [Vastu]
 *     security:
 *       - bearerAuth: []
 */
router.post('/auspicious-timing', authenticate, asyncHandler(async (req: AuthenticatedRequest, res) => {
  const { eventType, startDate, endDate, birthDetails } = req.body;

  if (!eventType || !startDate || !endDate) {
    throw new BadRequestError('Event type, start date, and end date are required');
  }

  // TODO: Integrate with Panchang API for actual calculations
  // For now, return mock auspicious timings
  
  const start = new Date(startDate);
  const end = new Date(endDate);
  const auspiciousDates: any[] = [];

  // Generate sample auspicious dates
  let current = new Date(start);
  while (current <= end) {
    // Simple logic: Skip Tuesday and Saturday for property transactions
    const dayOfWeek = current.getDay();
    if (dayOfWeek !== 2 && dayOfWeek !== 6) {
      // Check for Rahu Kaal (varies by day)
      const rahuKaalStart = getRahuKaalStart(dayOfWeek);
      
      auspiciousDates.push({
        date: current.toISOString().split('T')[0],
        dayOfWeek: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][dayOfWeek],
        auspiciousWindows: [
          { start: '06:00', end: rahuKaalStart, rating: 'good' },
          { start: addHours(rahuKaalStart, 1.5), end: '12:00', rating: 'excellent' },
          { start: '14:00', end: '17:00', rating: 'good' },
        ],
        rahuKaal: { start: rahuKaalStart, end: addHours(rahuKaalStart, 1.5) },
        nakshatra: getNakshatraForDate(current),
        tithi: getTithiForDate(current),
        yoga: getYogaForDate(current),
      });
    }
    
    current.setDate(current.getDate() + 1);
  }

  res.json({
    success: true,
    data: {
      eventType,
      auspiciousDates: auspiciousDates.slice(0, 10), // Limit to 10 dates
      generalGuidance: getEventGuidance(eventType),
    },
  });
}));

// Helper Functions
function getRemedies(type: string, direction: string): any[] {
  const key = `${type.toLowerCase()}_${direction.toLowerCase()}`;
  return VASTU_REMEDIES[key as keyof typeof VASTU_REMEDIES] || [
    {
      type: 'symbolic',
      description: 'Consult a Vastu expert for specific remedies',
      cost_estimate: 500,
      effectiveness: 50,
      difficulty: 'low',
    },
  ];
}

function generateRecommendations(analysis: any): string[] {
  const recommendations: string[] = [];

  if (analysis.overallScore < 60) {
    recommendations.push('Consider consulting a professional Vastu consultant for structural modifications.');
  }

  if (analysis.entranceAnalysis.score < 70) {
    recommendations.push('Focus on entrance remedies as they have the highest impact on overall energy.');
  }

  if (analysis.criticalDefects > 0) {
    recommendations.push(`Address the ${analysis.criticalDefects} critical defect(s) first for maximum improvement.`);
  }

  if (analysis.zoneScores['NORTH_EAST'] < 60) {
    recommendations.push('North-East (Ishaan) zone needs attention - keep it clean, clutter-free, and well-lit.');
  }

  if (analysis.zoneScores['SOUTH_WEST'] < 60) {
    recommendations.push('Strengthen South-West zone with heavy furniture and earth elements.');
  }

  recommendations.push('Regular space cleansing with camphor or incense improves overall energy.');
  recommendations.push('Ensure adequate natural light and ventilation throughout the property.');

  return recommendations;
}

function getRahuKaalStart(dayOfWeek: number): string {
  const rahuKaalTimes: Record<number, string> = {
    0: '16:30', // Sunday
    1: '07:30', // Monday
    2: '15:00', // Tuesday
    3: '12:00', // Wednesday
    4: '13:30', // Thursday
    5: '10:30', // Friday
    6: '09:00', // Saturday
  };
  return rahuKaalTimes[dayOfWeek];
}

function addHours(time: string, hours: number): string {
  const [h, m] = time.split(':').map(Number);
  const totalMinutes = h * 60 + m + hours * 60;
  const newH = Math.floor(totalMinutes / 60) % 24;
  const newM = totalMinutes % 60;
  return `${String(newH).padStart(2, '0')}:${String(newM).padStart(2, '0')}`;
}

function getNakshatraForDate(date: Date): string {
  const nakshatras = ['Ashwini', 'Bharani', 'Krittika', 'Rohini', 'Mrigashira', 'Ardra', 'Punarvasu', 
    'Pushya', 'Ashlesha', 'Magha', 'Purva Phalguni', 'Uttara Phalguni', 'Hasta', 'Chitra',
    'Swati', 'Vishakha', 'Anuradha', 'Jyeshtha', 'Mula', 'Purva Ashadha', 'Uttara Ashadha',
    'Shravana', 'Dhanishta', 'Shatabhisha', 'Purva Bhadrapada', 'Uttara Bhadrapada', 'Revati'];
  return nakshatras[date.getDate() % 27];
}

function getTithiForDate(date: Date): string {
  const tithis = ['Pratipada', 'Dwitiya', 'Tritiya', 'Chaturthi', 'Panchami', 'Shashthi', 'Saptami',
    'Ashtami', 'Navami', 'Dashami', 'Ekadashi', 'Dwadashi', 'Trayodashi', 'Chaturdashi', 'Purnima/Amavasya'];
  return tithis[date.getDate() % 15];
}

function getYogaForDate(date: Date): string {
  const yogas = ['Vishkumbha', 'Priti', 'Ayushman', 'Saubhagya', 'Shobhana', 'Atiganda', 'Sukarman',
    'Dhriti', 'Shula', 'Ganda', 'Vriddhi', 'Dhruva', 'Vyaghata', 'Harshana', 'Vajra', 'Siddhi',
    'Vyatipata', 'Variyan', 'Parigha', 'Shiva', 'Siddha', 'Sadhya', 'Shubha', 'Shukla', 'Brahma',
    'Indra', 'Vaidhriti'];
  return yogas[date.getDate() % 27];
}

function getEventGuidance(eventType: string): string {
  const guidance: Record<string, string> = {
    'PROPERTY_VIEWING': 'View properties during morning hours (after sunrise) when natural light reveals true condition.',
    'MAKING_OFFER': 'Make offers on days with favorable Nakshatra. Avoid during Rahu Kaal.',
    'SIGNING_CONTRACT': 'Sign contracts during Pushya or Uttara Phalguni Nakshatra for prosperity.',
    'CLOSING': 'Complete closing formalities during Shukla Paksha (waxing moon) for growth.',
    'GRIHA_PRAVESH': 'Enter new home during auspicious Muhurat with proper rituals for lasting happiness.',
    'RENOVATION_START': 'Begin renovations during Uttara Bhadrapada or Revati Nakshatra.',
  };
  return guidance[eventType] || 'Consult a Jyotish (Vedic astrologer) for personalized timing.';
}

export default router;

















Search · TS
import { Router, Request, Response } from 'express';
import { z } from 'zod';
import { prisma } from '../utils/prisma';
import { redis, cacheKeys, cacheTTL } from '../utils/redis';
import { authenticate, optionalAuthenticate } from '../middleware/auth';
import { asyncHandler, BadRequestError, NotFoundError } from '../middleware/errorHandler';
import { Prisma } from '@prisma/client';

const router = Router();

// ============================================================================
// SEARCH SCHEMAS
// ============================================================================

const advancedSearchSchema = z.object({
  // Text search
  query: z.string().optional(),
  
  // Location
  location: z.object({
    address: z.string().optional(),
    city: z.string().optional(),
    state: z.string().optional(),
    zipCode: z.string().optional(),
    latitude: z.number().optional(),
    longitude: z.number().optional(),
    radiusMiles: z.number().min(0.1).max(100).default(25),
  }).optional(),
  
  // Property details
  propertyType: z.array(z.enum(['HOUSE', 'CONDO', 'TOWNHOUSE', 'VILLA', 'PENTHOUSE', 'APARTMENT', 'STUDIO', 'LOFT', 'DUPLEX', 'ASHRAM', 'PLOT', 'FARM', 'COMMERCIAL', 'MIXED_USE'])).optional(),
  listingType: z.enum(['SALE', 'RENT', 'AUCTION', 'LEASE_OPTION']).optional(),
  status: z.array(z.enum(['ACTIVE', 'PENDING', 'SOLD', 'OFF_MARKET', 'COMING_SOON'])).optional(),
  
  // Price range
  minPrice: z.number().min(0).optional(),
  maxPrice: z.number().min(0).optional(),
  
  // Size
  minBedrooms: z.number().min(0).optional(),
  maxBedrooms: z.number().optional(),
  minBathrooms: z.number().min(0).optional(),
  maxBathrooms: z.number().optional(),
  minSquareFeet: z.number().min(0).optional(),
  maxSquareFeet: z.number().optional(),
  minLotSize: z.number().min(0).optional(),
  maxLotSize: z.number().optional(),
  
  // Year
  minYearBuilt: z.number().min(1800).optional(),
  maxYearBuilt: z.number().optional(),
  
  // Features
  features: z.array(z.string()).optional(),
  amenities: z.array(z.string()).optional(),
  mustHaveFeatures: z.array(z.string()).optional(), // Required features (AND logic)
  
  // Ancient Wisdom Filters
  minVastuScore: z.number().min(0).max(100).optional(),
  vastuGrade: z.array(z.enum(['A+', 'A', 'B+', 'B', 'C', 'D', 'F'])).optional(),
  entranceDirection: z.array(z.enum(['NORTH', 'NORTH_EAST', 'EAST', 'SOUTH_EAST', 'SOUTH', 'SOUTH_WEST', 'WEST', 'NORTH_WEST'])).optional(),
  minFengShuiScore: z.number().min(0).max(100).optional(),
  
  // Climate Filters
  maxClimateRiskScore: z.number().min(0).max(100).optional(),
  climateRiskGrade: z.array(z.enum(['LOW', 'MODERATE', 'HIGH', 'EXTREME'])).optional(),
  maxFloodRisk: z.number().min(0).max(100).optional(),
  maxWildfireRisk: z.number().min(0).max(100).optional(),
  maxHurricaneRisk: z.number().min(0).max(100).optional(),
  
  // Environmental Filters
  maxAQI: z.number().min(0).max(500).optional(),
  maxNoiseLevel: z.number().min(0).max(150).optional(),
  maxEMFLevel: z.number().min(0).optional(),
  
  // Neighborhood Filters
  minWalkScore: z.number().min(0).max(100).optional(),
  minTransitScore: z.number().min(0).max(100).optional(),
  minSchoolRating: z.number().min(1).max(10).optional(),
  maxCrimeIndex: z.number().min(0).optional(),
  
  // Other
  hasVirtualTour: z.boolean().optional(),
  hasOpenHouse: z.boolean().optional(),
  newConstruction: z.boolean().optional(),
  foreclosure: z.boolean().optional(),
  shortSale: z.boolean().optional(),
  priceReduced: z.boolean().optional(),
  daysOnMarket: z.number().min(0).optional(),
  
  // Pagination & Sorting
  page: z.number().min(1).default(1),
  limit: z.number().min(1).max(100).default(20),
  sortBy: z.enum(['relevance', 'price', 'pricePerSqft', 'bedrooms', 'bathrooms', 'squareFeet', 'yearBuilt', 'daysOnMarket', 'vastuScore', 'climateRisk', 'createdAt']).default('relevance'),
  sortOrder: z.enum(['asc', 'desc']).default('desc'),
});

const naturalLanguageSearchSchema = z.object({
  query: z.string().min(3).max(500),
  page: z.number().min(1).default(1),
  limit: z.number().min(1).max(100).default(20),
});

const autocompleteSchema = z.object({
  query: z.string().min(1).max(100),
  type: z.enum(['location', 'feature', 'agent', 'all']).default('all'),
  limit: z.number().min(1).max(20).default(10),
});

// ============================================================================
// NATURAL LANGUAGE PARSER
// ============================================================================

interface ParsedQuery {
  propertyType?: string[];
  listingType?: string;
  location?: { city?: string; state?: string; neighborhood?: string };
  minBedrooms?: number;
  maxBedrooms?: number;
  minBathrooms?: number;
  minPrice?: number;
  maxPrice?: number;
  minSquareFeet?: number;
  features?: string[];
  minVastuScore?: number;
  maxClimateRiskScore?: number;
  keywords?: string[];
}

function parseNaturalLanguageQuery(query: string): ParsedQuery {
  const parsed: ParsedQuery = {};
  const lowerQuery = query.toLowerCase();
  
  // Property type detection
  const propertyTypes: { [key: string]: string } = {
    'house': 'HOUSE',
    'home': 'HOUSE',
    'condo': 'CONDO',
    'condominium': 'CONDO',
    'townhouse': 'TOWNHOUSE',
    'townhome': 'TOWNHOUSE',
    'villa': 'VILLA',
    'mansion': 'VILLA',
    'penthouse': 'PENTHOUSE',
    'apartment': 'APARTMENT',
    'apt': 'APARTMENT',
    'studio': 'STUDIO',
    'loft': 'LOFT',
    'duplex': 'DUPLEX',
    'ashram': 'ASHRAM',
    'spiritual retreat': 'ASHRAM',
    'plot': 'PLOT',
    'land': 'PLOT',
    'lot': 'PLOT',
    'farm': 'FARM',
    'farmhouse': 'FARM',
    'commercial': 'COMMERCIAL',
    'office': 'COMMERCIAL',
  };
  
  const detectedTypes: string[] = [];
  for (const [keyword, type] of Object.entries(propertyTypes)) {
    if (lowerQuery.includes(keyword)) {
      if (!detectedTypes.includes(type)) {
        detectedTypes.push(type);
      }
    }
  }
  if (detectedTypes.length > 0) {
    parsed.propertyType = detectedTypes;
  }
  
  // Listing type detection
  if (lowerQuery.includes('rent') || lowerQuery.includes('rental') || lowerQuery.includes('lease')) {
    parsed.listingType = 'RENT';
  } else if (lowerQuery.includes('buy') || lowerQuery.includes('purchase') || lowerQuery.includes('for sale')) {
    parsed.listingType = 'SALE';
  } else if (lowerQuery.includes('auction')) {
    parsed.listingType = 'AUCTION';
  }
  
  // Bedroom detection
  const bedroomPatterns = [
    /(\d+)\s*(?:bed|bedroom|br|bed room)/i,
    /(\d+)\s*(?:bd|bdrm)/i,
    /(\d+)\+?\s*(?:bed|bedroom)/i,
  ];
  for (const pattern of bedroomPatterns) {
    const match = query.match(pattern);
    if (match) {
      parsed.minBedrooms = parseInt(match[1]);
      break;
    }
  }
  
  // Bathroom detection
  const bathroomPatterns = [
    /(\d+(?:\.\d+)?)\s*(?:bath|bathroom|ba)/i,
    /(\d+)\s*(?:full bath)/i,
  ];
  for (const pattern of bathroomPatterns) {
    const match = query.match(pattern);
    if (match) {
      parsed.minBathrooms = parseFloat(match[1]);
      break;
    }
  }
  
  // Price detection
  const pricePatterns = [
    /under\s*\$?\s*(\d+(?:,\d{3})*(?:\.\d+)?)\s*(?:k|m|million|thousand)?/i,
    /below\s*\$?\s*(\d+(?:,\d{3})*(?:\.\d+)?)\s*(?:k|m|million|thousand)?/i,
    /less than\s*\$?\s*(\d+(?:,\d{3})*(?:\.\d+)?)\s*(?:k|m|million|thousand)?/i,
    /max(?:imum)?\s*\$?\s*(\d+(?:,\d{3})*(?:\.\d+)?)\s*(?:k|m|million|thousand)?/i,
    /\$?\s*(\d+(?:,\d{3})*(?:\.\d+)?)\s*(?:k|m|million|thousand)?\s*(?:or less|max)/i,
  ];
  
  for (const pattern of pricePatterns) {
    const match = query.match(pattern);
    if (match) {
      let price = parseFloat(match[1].replace(/,/g, ''));
      const suffix = match[0].toLowerCase();
      if (suffix.includes('m') || suffix.includes('million')) {
        price *= 1000000;
      } else if (suffix.includes('k') || suffix.includes('thousand')) {
        price *= 1000;
      }
      parsed.maxPrice = price;
      break;
    }
  }
  
  // Minimum price detection
  const minPricePatterns = [
    /over\s*\$?\s*(\d+(?:,\d{3})*(?:\.\d+)?)\s*(?:k|m|million|thousand)?/i,
    /above\s*\$?\s*(\d+(?:,\d{3})*(?:\.\d+)?)\s*(?:k|m|million|thousand)?/i,
    /more than\s*\$?\s*(\d+(?:,\d{3})*(?:\.\d+)?)\s*(?:k|m|million|thousand)?/i,
    /min(?:imum)?\s*\$?\s*(\d+(?:,\d{3})*(?:\.\d+)?)\s*(?:k|m|million|thousand)?/i,
  ];
  
  for (const pattern of minPricePatterns) {
    const match = query.match(pattern);
    if (match) {
      let price = parseFloat(match[1].replace(/,/g, ''));
      const suffix = match[0].toLowerCase();
      if (suffix.includes('m') || suffix.includes('million')) {
        price *= 1000000;
      } else if (suffix.includes('k') || suffix.includes('thousand')) {
        price *= 1000;
      }
      parsed.minPrice = price;
      break;
    }
  }
  
  // Square footage detection
  const sqftPatterns = [
    /(\d+(?:,\d{3})*)\s*(?:sq\.?\s*ft|square feet|sqft)/i,
    /(\d+(?:,\d{3})*)\s*(?:sf)/i,
  ];
  for (const pattern of sqftPatterns) {
    const match = query.match(pattern);
    if (match) {
      parsed.minSquareFeet = parseInt(match[1].replace(/,/g, ''));
      break;
    }
  }
  
  // Location detection (simplified - in production would use NLP/NER)
  const locationPatterns = [
    /in\s+([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)/,
    /near\s+([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)/,
    /([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)\s+(?:area|neighborhood|district)/i,
  ];
  
  for (const pattern of locationPatterns) {
    const match = query.match(pattern);
    if (match) {
      const location = match[1];
      // Check if it's a US state
      const usStates = ['California', 'Texas', 'Florida', 'New York', 'Arizona', 'Nevada', 'Colorado', 'Washington', 'Oregon', 'Georgia'];
      if (usStates.some(state => location.includes(state))) {
        parsed.location = { state: location };
      } else {
        parsed.location = { city: location };
      }
      break;
    }
  }
  
  // Feature detection
  const features: string[] = [];
  const featureKeywords: { [key: string]: string } = {
    'pool': 'POOL',
    'swimming pool': 'POOL',
    'garage': 'GARAGE',
    'parking': 'PARKING',
    'garden': 'GARDEN',
    'backyard': 'BACKYARD',
    'fireplace': 'FIREPLACE',
    'balcony': 'BALCONY',
    'terrace': 'TERRACE',
    'waterfront': 'WATERFRONT',
    'ocean view': 'OCEAN_VIEW',
    'mountain view': 'MOUNTAIN_VIEW',
    'city view': 'CITY_VIEW',
    'gym': 'GYM',
    'fitness': 'FITNESS_CENTER',
    'spa': 'SPA',
    'elevator': 'ELEVATOR',
    'smart home': 'SMART_HOME',
    'solar': 'SOLAR_PANELS',
    'ev charger': 'EV_CHARGING',
    'guest house': 'GUEST_HOUSE',
    'home office': 'HOME_OFFICE',
    'wine cellar': 'WINE_CELLAR',
    'theater': 'HOME_THEATER',
    'puja room': 'PUJA_ROOM',
    'pooja room': 'PUJA_ROOM',
    'meditation': 'MEDITATION_ROOM',
    'yoga': 'YOGA_ROOM',
  };
  
  for (const [keyword, feature] of Object.entries(featureKeywords)) {
    if (lowerQuery.includes(keyword)) {
      features.push(feature);
    }
  }
  if (features.length > 0) {
    parsed.features = features;
  }
  
  // Vastu detection
  if (lowerQuery.includes('vastu') || lowerQuery.includes('vaastu')) {
    if (lowerQuery.includes('excellent') || lowerQuery.includes('great') || lowerQuery.includes('good')) {
      parsed.minVastuScore = 80;
    } else {
      parsed.minVastuScore = 60; // Default minimum if Vastu mentioned
    }
  }
  
  // Climate risk detection
  if (lowerQuery.includes('safe') && (lowerQuery.includes('climate') || lowerQuery.includes('flood') || lowerQuery.includes('fire'))) {
    parsed.maxClimateRiskScore = 30;
  }
  if (lowerQuery.includes('low risk') || lowerQuery.includes('low flood') || lowerQuery.includes('no flood')) {
    parsed.maxClimateRiskScore = 25;
  }
  
  return parsed;
}

// ============================================================================
// ADVANCED SEARCH
// ============================================================================

router.post('/advanced', optionalAuthenticate, asyncHandler(async (req: Request, res: Response) => {
  const validated = advancedSearchSchema.parse(req.body);
  const { page, limit, sortBy, sortOrder, ...filters } = validated;
  
  // Build WHERE clause
  const where: Prisma.PropertyWhereInput = {
    status: filters.status ? { in: filters.status } : 'ACTIVE',
  };
  
  // Property type filter
  if (filters.propertyType && filters.propertyType.length > 0) {
    where.propertyType = { in: filters.propertyType };
  }
  
  // Listing type filter
  if (filters.listingType) {
    where.listingType = filters.listingType;
  }
  
  // Price range
  if (filters.minPrice !== undefined || filters.maxPrice !== undefined) {
    where.price = {};
    if (filters.minPrice !== undefined) where.price.gte = filters.minPrice;
    if (filters.maxPrice !== undefined) where.price.lte = filters.maxPrice;
  }
  
  // Bedrooms
  if (filters.minBedrooms !== undefined || filters.maxBedrooms !== undefined) {
    where.bedrooms = {};
    if (filters.minBedrooms !== undefined) where.bedrooms.gte = filters.minBedrooms;
    if (filters.maxBedrooms !== undefined) where.bedrooms.lte = filters.maxBedrooms;
  }
  
  // Bathrooms
  if (filters.minBathrooms !== undefined || filters.maxBathrooms !== undefined) {
    where.bathrooms = {};
    if (filters.minBathrooms !== undefined) where.bathrooms.gte = filters.minBathrooms;
    if (filters.maxBathrooms !== undefined) where.bathrooms.lte = filters.maxBathrooms;
  }
  
  // Square feet
  if (filters.minSquareFeet !== undefined || filters.maxSquareFeet !== undefined) {
    where.squareFeet = {};
    if (filters.minSquareFeet !== undefined) where.squareFeet.gte = filters.minSquareFeet;
    if (filters.maxSquareFeet !== undefined) where.squareFeet.lte = filters.maxSquareFeet;
  }
  
  // Lot size
  if (filters.minLotSize !== undefined || filters.maxLotSize !== undefined) {
    where.lotSizeAcres = {};
    if (filters.minLotSize !== undefined) where.lotSizeAcres.gte = filters.minLotSize;
    if (filters.maxLotSize !== undefined) where.lotSizeAcres.lte = filters.maxLotSize;
  }
  
  // Year built
  if (filters.minYearBuilt !== undefined || filters.maxYearBuilt !== undefined) {
    where.yearBuilt = {};
    if (filters.minYearBuilt !== undefined) where.yearBuilt.gte = filters.minYearBuilt;
    if (filters.maxYearBuilt !== undefined) where.yearBuilt.lte = filters.maxYearBuilt;
  }
  
  // Location filters
  if (filters.location) {
    if (filters.location.city) where.city = { contains: filters.location.city, mode: 'insensitive' };
    if (filters.location.state) where.state = { contains: filters.location.state, mode: 'insensitive' };
    if (filters.location.zipCode) where.zipCode = filters.location.zipCode;
    
    // Geo search (bounding box)
    if (filters.location.latitude && filters.location.longitude) {
      const radiusKm = (filters.location.radiusMiles || 25) * 1.60934;
      const latDelta = radiusKm / 111;
      const lngDelta = radiusKm / (111 * Math.cos(filters.location.latitude * Math.PI / 180));
      
      where.latitude = {
        gte: filters.location.latitude - latDelta,
        lte: filters.location.latitude + latDelta,
      };
      where.longitude = {
        gte: filters.location.longitude - lngDelta,
        lte: filters.location.longitude + lngDelta,
      };
    }
  }
  
  // Features filter (OR logic by default)
  if (filters.features && filters.features.length > 0) {
    where.features = { hasSome: filters.features };
  }
  
  // Must have features (AND logic)
  if (filters.mustHaveFeatures && filters.mustHaveFeatures.length > 0) {
    where.features = { hasEvery: filters.mustHaveFeatures };
  }
  
  // Amenities filter
  if (filters.amenities && filters.amenities.length > 0) {
    where.amenities = { hasSome: filters.amenities };
  }
  
  // Vastu filters
  if (filters.minVastuScore !== undefined || filters.vastuGrade || filters.entranceDirection) {
    where.vastuAnalysis = {};
    if (filters.minVastuScore !== undefined) {
      where.vastuAnalysis.overallScore = { gte: filters.minVastuScore };
    }
    if (filters.vastuGrade && filters.vastuGrade.length > 0) {
      where.vastuAnalysis.grade = { in: filters.vastuGrade };
    }
    if (filters.entranceDirection && filters.entranceDirection.length > 0) {
      where.vastuAnalysis.entranceDirection = { in: filters.entranceDirection };
    }
  }
  
  // Feng Shui filter
  if (filters.minFengShuiScore !== undefined) {
    where.fengShuiAnalysis = {
      overallScore: { gte: filters.minFengShuiScore },
    };
  }
  
  // Climate filters
  if (filters.maxClimateRiskScore !== undefined || filters.climateRiskGrade || 
      filters.maxFloodRisk !== undefined || filters.maxWildfireRisk !== undefined || 
      filters.maxHurricaneRisk !== undefined) {
    where.climateAnalysis = {};
    if (filters.maxClimateRiskScore !== undefined) {
      where.climateAnalysis.overallRiskScore = { lte: filters.maxClimateRiskScore };
    }
    if (filters.climateRiskGrade && filters.climateRiskGrade.length > 0) {
      where.climateAnalysis.riskGrade = { in: filters.climateRiskGrade };
    }
    if (filters.maxFloodRisk !== undefined) {
      where.climateAnalysis.floodRisk2030 = { lte: filters.maxFloodRisk };
    }
    if (filters.maxWildfireRisk !== undefined) {
      where.climateAnalysis.wildfireRisk = { lte: filters.maxWildfireRisk };
    }
    if (filters.maxHurricaneRisk !== undefined) {
      where.climateAnalysis.hurricaneRisk = { lte: filters.maxHurricaneRisk };
    }
  }
  
  // Environmental filters
  if (filters.maxAQI !== undefined || filters.maxNoiseLevel !== undefined || 
      filters.maxEMFLevel !== undefined) {
    where.environmentalData = {};
    if (filters.maxAQI !== undefined) {
      where.environmentalData.aqiCurrent = { lte: filters.maxAQI };
    }
    if (filters.maxNoiseLevel !== undefined) {
      where.environmentalData.avgNoiseDecibels = { lte: filters.maxNoiseLevel };
    }
    if (filters.maxEMFLevel !== undefined) {
      where.environmentalData.emfLevel = { lte: filters.maxEMFLevel };
    }
  }
  
  // Neighborhood filters
  if (filters.minWalkScore !== undefined || filters.minTransitScore !== undefined ||
      filters.minSchoolRating !== undefined || filters.maxCrimeIndex !== undefined) {
    where.neighborhood = {};
    if (filters.minWalkScore !== undefined) {
      where.neighborhood.walkabilityScore = { gte: filters.minWalkScore };
    }
    if (filters.minTransitScore !== undefined) {
      where.neighborhood.transitScore = { gte: filters.minTransitScore };
    }
    if (filters.minSchoolRating !== undefined) {
      where.neighborhood.schoolRating = { gte: filters.minSchoolRating };
    }
    if (filters.maxCrimeIndex !== undefined) {
      where.neighborhood.crimeIndex = { lte: filters.maxCrimeIndex };
    }
  }
  
  // Other filters
  if (filters.hasVirtualTour) {
    where.virtualTourUrl = { not: null };
  }
  
  if (filters.hasOpenHouse) {
    where.openHouses = {
      some: {
        startTime: { gte: new Date() },
      },
    };
  }
  
  if (filters.newConstruction) {
    const currentYear = new Date().getFullYear();
    where.yearBuilt = { gte: currentYear - 2 };
  }
  
  if (filters.priceReduced) {
    where.priceHistory = {
      some: {
        newPrice: { lt: prisma.priceHistory.fields.previousPrice },
        changeDate: { gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) }, // Last 30 days
      },
    };
  }
  
  if (filters.daysOnMarket !== undefined) {
    const cutoffDate = new Date(Date.now() - filters.daysOnMarket * 24 * 60 * 60 * 1000);
    where.listedAt = { gte: cutoffDate };
  }
  
  // Build ORDER BY
  let orderBy: Prisma.PropertyOrderByWithRelationInput = {};
  switch (sortBy) {
    case 'price':
      orderBy = { price: sortOrder };
      break;
    case 'pricePerSqft':
      orderBy = { pricePerSqft: sortOrder };
      break;
    case 'bedrooms':
      orderBy = { bedrooms: sortOrder };
      break;
    case 'bathrooms':
      orderBy = { bathrooms: sortOrder };
      break;
    case 'squareFeet':
      orderBy = { squareFeet: sortOrder };
      break;
    case 'yearBuilt':
      orderBy = { yearBuilt: sortOrder };
      break;
    case 'daysOnMarket':
      orderBy = { listedAt: sortOrder === 'asc' ? 'desc' : 'asc' };
      break;
    case 'vastuScore':
      orderBy = { vastuAnalysis: { overallScore: sortOrder } };
      break;
    case 'climateRisk':
      orderBy = { climateAnalysis: { overallRiskScore: sortOrder === 'asc' ? 'desc' : 'asc' } };
      break;
    case 'createdAt':
      orderBy = { createdAt: sortOrder };
      break;
    default:
      // Relevance - prioritize featured, then recent
      orderBy = { createdAt: 'desc' };
  }
  
  // Execute query
  const [properties, total] = await Promise.all([
    prisma.property.findMany({
      where,
      orderBy,
      skip: (page - 1) * limit,
      take: limit,
      include: {
        photos: {
          where: { isPrimary: true },
          take: 1,
        },
        vastuAnalysis: {
          select: {
            overallScore: true,
            grade: true,
            entranceDirection: true,
          },
        },
        climateAnalysis: {
          select: {
            overallRiskScore: true,
            riskGrade: true,
          },
        },
        listingAgent: {
          include: {
            user: {
              select: {
                firstName: true,
                lastName: true,
              },
            },
          },
        },
        neighborhood: {
          select: {
            name: true,
            walkabilityScore: true,
            transitScore: true,
            schoolRating: true,
          },
        },
      },
    }),
    prisma.property.count({ where }),
  ]);
  
  // Track search if user is authenticated
  if ((req as any).user) {
    // Could save search history here for recommendations
  }
  
  res.json({
    success: true,
    data: {
      properties,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit),
        hasMore: page * limit < total,
      },
      filters: {
        applied: Object.keys(filters).filter(k => filters[k as keyof typeof filters] !== undefined).length,
        available: {
          propertyTypes: ['HOUSE', 'CONDO', 'TOWNHOUSE', 'VILLA', 'PENTHOUSE', 'APARTMENT', 'STUDIO', 'LOFT', 'DUPLEX', 'ASHRAM', 'PLOT', 'FARM', 'COMMERCIAL', 'MIXED_USE'],
          vastuGrades: ['A+', 'A', 'B+', 'B', 'C', 'D', 'F'],
          climateRiskGrades: ['LOW', 'MODERATE', 'HIGH', 'EXTREME'],
        },
      },
    },
  });
}));

// ============================================================================
// NATURAL LANGUAGE SEARCH
// ============================================================================

router.post('/natural-language', optionalAuthenticate, asyncHandler(async (req: Request, res: Response) => {
  const validated = naturalLanguageSearchSchema.parse(req.body);
  const { query, page, limit } = validated;
  
  // Parse natural language query
  const parsed = parseNaturalLanguageQuery(query);
  
  // Build WHERE clause from parsed query
  const where: Prisma.PropertyWhereInput = {
    status: 'ACTIVE',
  };
  
  if (parsed.propertyType && parsed.propertyType.length > 0) {
    where.propertyType = { in: parsed.propertyType };
  }
  
  if (parsed.listingType) {
    where.listingType = parsed.listingType;
  }
  
  if (parsed.location) {
    if (parsed.location.city) where.city = { contains: parsed.location.city, mode: 'insensitive' };
    if (parsed.location.state) where.state = { contains: parsed.location.state, mode: 'insensitive' };
  }
  
  if (parsed.minBedrooms !== undefined) {
    where.bedrooms = { gte: parsed.minBedrooms };
  }
  
  if (parsed.minBathrooms !== undefined) {
    where.bathrooms = { gte: parsed.minBathrooms };
  }
  
  if (parsed.minPrice !== undefined || parsed.maxPrice !== undefined) {
    where.price = {};
    if (parsed.minPrice !== undefined) where.price.gte = parsed.minPrice;
    if (parsed.maxPrice !== undefined) where.price.lte = parsed.maxPrice;
  }
  
  if (parsed.minSquareFeet !== undefined) {
    where.squareFeet = { gte: parsed.minSquareFeet };
  }
  
  if (parsed.features && parsed.features.length > 0) {
    where.features = { hasSome: parsed.features };
  }
  
  if (parsed.minVastuScore !== undefined) {
    where.vastuAnalysis = { overallScore: { gte: parsed.minVastuScore } };
  }
  
  if (parsed.maxClimateRiskScore !== undefined) {
    where.climateAnalysis = { overallRiskScore: { lte: parsed.maxClimateRiskScore } };
  }
  
  // Execute query
  const [properties, total] = await Promise.all([
    prisma.property.findMany({
      where,
      orderBy: { createdAt: 'desc' },
      skip: (page - 1) * limit,
      take: limit,
      include: {
        photos: {
          where: { isPrimary: true },
          take: 1,
        },
        vastuAnalysis: {
          select: {
            overallScore: true,
            grade: true,
          },
        },
        climateAnalysis: {
          select: {
            overallRiskScore: true,
            riskGrade: true,
          },
        },
        listingAgent: {
          include: {
            user: {
              select: {
                firstName: true,
                lastName: true,
              },
            },
          },
        },
      },
    }),
    prisma.property.count({ where }),
  ]);
  
  res.json({
    success: true,
    data: {
      originalQuery: query,
      parsedFilters: parsed,
      properties,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit),
      },
      suggestions: properties.length === 0 ? [
        'Try removing some filters',
        'Expand your search area',
        'Adjust your price range',
      ] : [],
    },
  });
}));

// ============================================================================
// AUTOCOMPLETE
// ============================================================================

router.get('/autocomplete', asyncHandler(async (req: Request, res: Response) => {
  const validated = autocompleteSchema.parse(req.query);
  const { query, type, limit } = validated;
  
  const suggestions: Array<{
    type: string;
    value: string;
    display: string;
    metadata?: Record<string, any>;
  }> = [];
  
  // Location autocomplete
  if (type === 'all' || type === 'location') {
    // Cities
    const cities = await prisma.property.findMany({
      where: {
        city: { contains: query, mode: 'insensitive' },
        status: 'ACTIVE',
      },
      select: { city: true, state: true },
      distinct: ['city'],
      take: limit,
    });
    
    cities.forEach(c => {
      suggestions.push({
        type: 'city',
        value: c.city,
        display: `${c.city}, ${c.state}`,
        metadata: { state: c.state },
      });
    });
    
    // Neighborhoods
    const neighborhoods = await prisma.neighborhood.findMany({
      where: {
        name: { contains: query, mode: 'insensitive' },
      },
      select: { name: true, city: true, state: true },
      take: limit,
    });
    
    neighborhoods.forEach(n => {
      suggestions.push({
        type: 'neighborhood',
        value: n.name,
        display: `${n.name}, ${n.city}`,
        metadata: { city: n.city, state: n.state },
      });
    });
    
    // Zip codes
    if (/^\d{1,5}$/.test(query)) {
      const zips = await prisma.property.findMany({
        where: {
          zipCode: { startsWith: query },
          status: 'ACTIVE',
        },
        select: { zipCode: true, city: true, state: true },
        distinct: ['zipCode'],
        take: limit,
      });
      
      zips.forEach(z => {
        suggestions.push({
          type: 'zipCode',
          value: z.zipCode,
          display: `${z.zipCode} - ${z.city}, ${z.state}`,
          metadata: { city: z.city, state: z.state },
        });
      });
    }
  }
  
  // Feature autocomplete
  if (type === 'all' || type === 'feature') {
    const allFeatures = [
      'POOL', 'GARAGE', 'GARDEN', 'FIREPLACE', 'BALCONY', 'TERRACE',
      'WATERFRONT', 'OCEAN_VIEW', 'MOUNTAIN_VIEW', 'CITY_VIEW',
      'GYM', 'SPA', 'ELEVATOR', 'SMART_HOME', 'SOLAR_PANELS',
      'EV_CHARGING', 'GUEST_HOUSE', 'HOME_OFFICE', 'WINE_CELLAR',
      'HOME_THEATER', 'PUJA_ROOM', 'MEDITATION_ROOM', 'YOGA_ROOM',
      'SECURITY_SYSTEM', 'GATED', 'CONCIERGE', 'DOORMAN',
    ];
    
    const matchingFeatures = allFeatures.filter(f => 
      f.toLowerCase().includes(query.toLowerCase()) ||
      f.replace(/_/g, ' ').toLowerCase().includes(query.toLowerCase())
    );
    
    matchingFeatures.slice(0, limit).forEach(f => {
      suggestions.push({
        type: 'feature',
        value: f,
        display: f.replace(/_/g, ' ').toLowerCase().replace(/\b\w/g, l => l.toUpperCase()),
      });
    });
  }
  
  // Agent autocomplete
  if (type === 'all' || type === 'agent') {
    const agents = await prisma.agent.findMany({
      where: {
        OR: [
          { user: { firstName: { contains: query, mode: 'insensitive' } } },
          { user: { lastName: { contains: query, mode: 'insensitive' } } },
          { brokerage: { contains: query, mode: 'insensitive' } },
        ],
        isVerified: true,
      },
      include: {
        user: {
          select: { firstName: true, lastName: true },
        },
      },
      take: limit,
    });
    
    agents.forEach(a => {
      suggestions.push({
        type: 'agent',
        value: a.id,
        display: `${a.user.firstName} ${a.user.lastName}`,
        metadata: { brokerage: a.brokerage },
      });
    });
  }
  
  res.json({
    success: true,
    data: {
      query,
      suggestions: suggestions.slice(0, limit),
    },
  });
}));

// ============================================================================
// SEARCH SUGGESTIONS
// ============================================================================

router.get('/suggestions', optionalAuthenticate, asyncHandler(async (req: Request, res: Response) => {
  const userId = (req as any).user?.id;
  
  const suggestions: Array<{
    type: string;
    title: string;
    query: Record<string, any>;
  }> = [];
  
  // Popular searches
  suggestions.push(
    {
      type: 'popular',
      title: '3+ BR Houses under $500K',
      query: { propertyType: ['HOUSE'], minBedrooms: 3, maxPrice: 500000 },
    },
    {
      type: 'popular',
      title: 'High Vastu Score Properties',
      query: { minVastuScore: 80 },
    },
    {
      type: 'popular',
      title: 'Low Climate Risk Homes',
      query: { maxClimateRiskScore: 25 },
    },
    {
      type: 'popular',
      title: 'Luxury Villas with Pool',
      query: { propertyType: ['VILLA'], minPrice: 1000000, features: ['POOL'] },
    },
    {
      type: 'popular',
      title: 'New Construction',
      query: { newConstruction: true },
    },
  );
  
  // User-specific suggestions based on saved searches and viewing history
  if (userId) {
    // Get user's most common search criteria
    const savedSearches = await prisma.savedSearch.findMany({
      where: { userId },
      orderBy: { matchCount: 'desc' },
      take: 3,
    });
    
    savedSearches.forEach(search => {
      suggestions.push({
        type: 'saved',
        title: search.name,
        query: search.filters as Record<string, any>,
      });
    });
    
    // Get recently viewed property types
    const recentViews = await prisma.propertyView.findMany({
      where: { userId },
      include: { property: { select: { propertyType: true, city: true } } },
      orderBy: { viewedAt: 'desc' },
      take: 10,
    });
    
    if (recentViews.length > 0) {
      const mostViewedType = recentViews
        .map(v => v.property.propertyType)
        .reduce((acc, type) => {
          acc[type] = (acc[type] || 0) + 1;
          return acc;
        }, {} as Record<string, number>);
      
      const topType = Object.entries(mostViewedType).sort((a, b) => b[1] - a[1])[0];
      if (topType) {
        suggestions.push({
          type: 'personalized',
          title: `More ${topType[0].toLowerCase()}s you might like`,
          query: { propertyType: [topType[0]] },
        });
      }
    }
  }
  
  res.json({
    success: true,
    data: { suggestions },
  });
}));

// ============================================================================
// TRENDING SEARCHES
// ============================================================================

router.get('/trending', asyncHandler(async (req: Request, res: Response) => {
  // In production, this would track actual search queries
  // For now, return curated trending searches
  const trending = [
    {
      rank: 1,
      term: 'Vastu compliant homes',
      searchCount: 15420,
      trend: 'up',
      change: 23,
    },
    {
      rank: 2,
      term: 'Climate safe properties',
      searchCount: 12350,
      trend: 'up',
      change: 45,
    },
    {
      rank: 3,
      term: 'Waterfront condos',
      searchCount: 9870,
      trend: 'stable',
      change: 2,
    },
    {
      rank: 4,
      term: 'Smart homes',
      searchCount: 8540,
      trend: 'up',
      change: 18,
    },
    {
      rank: 5,
      term: 'Spiritual retreats',
      searchCount: 6230,
      trend: 'up',
      change: 67,
    },
    {
      rank: 6,
      term: 'Solar powered homes',
      searchCount: 5890,
      trend: 'up',
      change: 31,
    },
    {
      rank: 7,
      term: 'Mountain view properties',
      searchCount: 5420,
      trend: 'stable',
      change: 5,
    },
    {
      rank: 8,
      term: 'Investment properties',
      searchCount: 4980,
      trend: 'down',
      change: -8,
    },
    {
      rank: 9,
      term: 'New construction',
      searchCount: 4750,
      trend: 'stable',
      change: 1,
    },
    {
      rank: 10,
      term: 'Puja room homes',
      searchCount: 4320,
      trend: 'up',
      change: 89,
    },
  ];
  
  res.json({
    success: true,
    data: { trending },
  });
}));

export default router;
Favorites · TS
import { Router, Request, Response } from 'express';
import { z } from 'zod';
import { prisma } from '../utils/prisma';
import { redis, cacheKeys, cacheTTL } from '../utils/redis';
import { authenticate } from '../middleware/auth';
import { asyncHandler, BadRequestError, NotFoundError, ForbiddenError } from '../middleware/errorHandler';

const router = Router();

// ============================================================================
// SCHEMAS
// ============================================================================

const createSavedSearchSchema = z.object({
  name: z.string().min(1).max(100),
  filters: z.record(z.any()),
  alertFrequency: z.enum(['INSTANT', 'DAILY', 'WEEKLY', 'NEVER']).default('DAILY'),
});

const updateSavedSearchSchema = z.object({
  name: z.string().min(1).max(100).optional(),
  filters: z.record(z.any()).optional(),
  alertFrequency: z.enum(['INSTANT', 'DAILY', 'WEEKLY', 'NEVER']).optional(),
  isActive: z.boolean().optional(),
});

const addFavoriteSchema = z.object({
  propertyId: z.string().uuid(),
  notes: z.string().max(500).optional(),
});

const updateFavoriteSchema = z.object({
  notes: z.string().max(500).optional(),
});

const comparisonGroupSchema = z.object({
  propertyIds: z.array(z.string().uuid()).min(2).max(10),
  name: z.string().min(1).max(100).optional(),
});

// ============================================================================
// SAVED SEARCHES
// ============================================================================

// Get all saved searches for user
router.get('/saved-searches', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const userId = (req as any).user.id;
  
  const savedSearches = await prisma.savedSearch.findMany({
    where: { userId },
    orderBy: { createdAt: 'desc' },
    select: {
      id: true,
      name: true,
      filters: true,
      alertFrequency: true,
      isActive: true,
      lastAlertAt: true,
      matchCount: true,
      createdAt: true,
      updatedAt: true,
    },
  });
  
  res.json({
    success: true,
    data: { savedSearches },
  });
}));

// Create saved search
router.post('/saved-searches', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const userId = (req as any).user.id;
  const validated = createSavedSearchSchema.parse(req.body);
  
  // Check limit (max 20 saved searches per user)
  const existingCount = await prisma.savedSearch.count({ where: { userId } });
  if (existingCount >= 20) {
    throw new BadRequestError('Maximum of 20 saved searches allowed. Please delete some existing searches.');
  }
  
  // Get initial match count
  const matchCount = await countMatchingProperties(validated.filters);
  
  const savedSearch = await prisma.savedSearch.create({
    data: {
      userId,
      name: validated.name,
      filters: validated.filters,
      alertFrequency: validated.alertFrequency,
      matchCount,
      isActive: true,
    },
  });
  
  res.status(201).json({
    success: true,
    data: { savedSearch },
    message: `Saved search created. Found ${matchCount} matching properties.`,
  });
}));

// Get saved search by ID
router.get('/saved-searches/:id', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const userId = (req as any).user.id;
  const { id } = req.params;
  
  const savedSearch = await prisma.savedSearch.findUnique({
    where: { id },
  });
  
  if (!savedSearch) {
    throw new NotFoundError('Saved search not found');
  }
  
  if (savedSearch.userId !== userId) {
    throw new ForbiddenError('Not authorized to access this saved search');
  }
  
  res.json({
    success: true,
    data: { savedSearch },
  });
}));

// Update saved search
router.put('/saved-searches/:id', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const userId = (req as any).user.id;
  const { id } = req.params;
  const validated = updateSavedSearchSchema.parse(req.body);
  
  const savedSearch = await prisma.savedSearch.findUnique({
    where: { id },
  });
  
  if (!savedSearch) {
    throw new NotFoundError('Saved search not found');
  }
  
  if (savedSearch.userId !== userId) {
    throw new ForbiddenError('Not authorized to update this saved search');
  }
  
  // Recalculate match count if filters changed
  let matchCount = savedSearch.matchCount;
  if (validated.filters) {
    matchCount = await countMatchingProperties(validated.filters);
  }
  
  const updated = await prisma.savedSearch.update({
    where: { id },
    data: {
      ...validated,
      matchCount,
    },
  });
  
  res.json({
    success: true,
    data: { savedSearch: updated },
  });
}));

// Delete saved search
router.delete('/saved-searches/:id', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const userId = (req as any).user.id;
  const { id } = req.params;
  
  const savedSearch = await prisma.savedSearch.findUnique({
    where: { id },
  });
  
  if (!savedSearch) {
    throw new NotFoundError('Saved search not found');
  }
  
  if (savedSearch.userId !== userId) {
    throw new ForbiddenError('Not authorized to delete this saved search');
  }
  
  await prisma.savedSearch.delete({ where: { id } });
  
  res.json({
    success: true,
    message: 'Saved search deleted successfully',
  });
}));

// Get matching properties for saved search
router.get('/saved-searches/:id/matches', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const userId = (req as any).user.id;
  const { id } = req.params;
  const page = parseInt(req.query.page as string) || 1;
  const limit = Math.min(parseInt(req.query.limit as string) || 20, 100);
  const newOnly = req.query.newOnly === 'true';
  
  const savedSearch = await prisma.savedSearch.findUnique({
    where: { id },
  });
  
  if (!savedSearch) {
    throw new NotFoundError('Saved search not found');
  }
  
  if (savedSearch.userId !== userId) {
    throw new ForbiddenError('Not authorized to access this saved search');
  }
  
  const filters = savedSearch.filters as Record<string, any>;
  const where = buildWhereClause(filters);
  
  // If newOnly, filter by properties created after last alert
  if (newOnly && savedSearch.lastAlertAt) {
    where.createdAt = { gt: savedSearch.lastAlertAt };
  }
  
  const [properties, total] = await Promise.all([
    prisma.property.findMany({
      where,
      orderBy: { createdAt: 'desc' },
      skip: (page - 1) * limit,
      take: limit,
      include: {
        photos: {
          where: { isPrimary: true },
          take: 1,
        },
        vastuAnalysis: {
          select: {
            overallScore: true,
            grade: true,
          },
        },
        climateAnalysis: {
          select: {
            overallRiskScore: true,
            riskGrade: true,
          },
        },
      },
    }),
    prisma.property.count({ where }),
  ]);
  
  // Update match count
  await prisma.savedSearch.update({
    where: { id },
    data: { matchCount: total },
  });
  
  res.json({
    success: true,
    data: {
      properties,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit),
      },
      newMatches: newOnly ? properties.length : undefined,
    },
  });
}));

// ============================================================================
// FAVORITES
// ============================================================================

// Get all favorites for user
router.get('/favorites', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const userId = (req as any).user.id;
  const page = parseInt(req.query.page as string) || 1;
  const limit = Math.min(parseInt(req.query.limit as string) || 20, 100);
  const sortBy = (req.query.sortBy as string) || 'createdAt';
  const sortOrder = (req.query.sortOrder as string) === 'asc' ? 'asc' : 'desc';
  
  const orderBy: any = {};
  if (sortBy === 'price' || sortBy === 'bedrooms' || sortBy === 'squareFeet') {
    orderBy.property = { [sortBy]: sortOrder };
  } else {
    orderBy[sortBy] = sortOrder;
  }
  
  const [favorites, total] = await Promise.all([
    prisma.favorite.findMany({
      where: { userId },
      orderBy,
      skip: (page - 1) * limit,
      take: limit,
      include: {
        property: {
          include: {
            photos: {
              where: { isPrimary: true },
              take: 1,
            },
            vastuAnalysis: {
              select: {
                overallScore: true,
                grade: true,
              },
            },
            climateAnalysis: {
              select: {
                overallRiskScore: true,
                riskGrade: true,
              },
            },
            listingAgent: {
              include: {
                user: {
                  select: {
                    firstName: true,
                    lastName: true,
                  },
                },
              },
            },
          },
        },
      },
    }),
    prisma.favorite.count({ where: { userId } }),
  ]);
  
  res.json({
    success: true,
    data: {
      favorites,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit),
      },
    },
  });
}));

// Add to favorites
router.post('/favorites', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const userId = (req as any).user.id;
  const validated = addFavoriteSchema.parse(req.body);
  
  // Check if property exists
  const property = await prisma.property.findUnique({
    where: { id: validated.propertyId },
  });
  
  if (!property) {
    throw new NotFoundError('Property not found');
  }
  
  // Check if already favorited
  const existing = await prisma.favorite.findUnique({
    where: {
      userId_propertyId: {
        userId,
        propertyId: validated.propertyId,
      },
    },
  });
  
  if (existing) {
    throw new BadRequestError('Property already in favorites');
  }
  
  // Check limit (max 100 favorites per user)
  const favoriteCount = await prisma.favorite.count({ where: { userId } });
  if (favoriteCount >= 100) {
    throw new BadRequestError('Maximum of 100 favorites allowed. Please remove some existing favorites.');
  }
  
  const favorite = await prisma.favorite.create({
    data: {
      userId,
      propertyId: validated.propertyId,
      notes: validated.notes,
    },
    include: {
      property: {
        include: {
          photos: {
            where: { isPrimary: true },
            take: 1,
          },
        },
      },
    },
  });
  
  res.status(201).json({
    success: true,
    data: { favorite },
    message: 'Property added to favorites',
  });
}));

// Update favorite (notes)
router.put('/favorites/:propertyId', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const userId = (req as any).user.id;
  const { propertyId } = req.params;
  const validated = updateFavoriteSchema.parse(req.body);
  
  const favorite = await prisma.favorite.findUnique({
    where: {
      userId_propertyId: {
        userId,
        propertyId,
      },
    },
  });
  
  if (!favorite) {
    throw new NotFoundError('Favorite not found');
  }
  
  const updated = await prisma.favorite.update({
    where: {
      userId_propertyId: {
        userId,
        propertyId,
      },
    },
    data: { notes: validated.notes },
    include: {
      property: {
        include: {
          photos: {
            where: { isPrimary: true },
            take: 1,
          },
        },
      },
    },
  });
  
  res.json({
    success: true,
    data: { favorite: updated },
  });
}));

// Remove from favorites
router.delete('/favorites/:propertyId', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const userId = (req as any).user.id;
  const { propertyId } = req.params;
  
  const favorite = await prisma.favorite.findUnique({
    where: {
      userId_propertyId: {
        userId,
        propertyId,
      },
    },
  });
  
  if (!favorite) {
    throw new NotFoundError('Property not in favorites');
  }
  
  await prisma.favorite.delete({
    where: {
      userId_propertyId: {
        userId,
        propertyId,
      },
    },
  });
  
  res.json({
    success: true,
    message: 'Property removed from favorites',
  });
}));

// Check if property is favorited
router.get('/favorites/check/:propertyId', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const userId = (req as any).user.id;
  const { propertyId } = req.params;
  
  const favorite = await prisma.favorite.findUnique({
    where: {
      userId_propertyId: {
        userId,
        propertyId,
      },
    },
    select: {
      id: true,
      notes: true,
      createdAt: true,
    },
  });
  
  res.json({
    success: true,
    data: {
      isFavorited: !!favorite,
      favorite,
    },
  });
}));

// ============================================================================
// PROPERTY COMPARISON
// ============================================================================

// Create comparison group
router.post('/comparisons', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const userId = (req as any).user.id;
  const validated = comparisonGroupSchema.parse(req.body);
  
  // Verify all properties exist and get their details
  const properties = await prisma.property.findMany({
    where: { id: { in: validated.propertyIds } },
    include: {
      photos: {
        where: { isPrimary: true },
        take: 1,
      },
      vastuAnalysis: true,
      fengShuiAnalysis: true,
      climateAnalysis: true,
      environmentalData: true,
      energyAnalysis: true,
      neighborhood: true,
    },
  });
  
  if (properties.length !== validated.propertyIds.length) {
    throw new BadRequestError('One or more properties not found');
  }
  
  // Generate unique group ID
  const groupId = `comp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  
  // Create comparison records
  await prisma.propertyComparison.createMany({
    data: validated.propertyIds.map(propertyId => ({
      userId,
      propertyId,
      groupId,
    })),
  });
  
  // Build comparison data
  const comparison = buildComparisonData(properties);
  
  res.status(201).json({
    success: true,
    data: {
      groupId,
      name: validated.name || `Comparison ${new Date().toLocaleDateString()}`,
      properties,
      comparison,
    },
  });
}));

// Get comparison groups
router.get('/comparisons', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const userId = (req as any).user.id;
  
  const comparisons = await prisma.propertyComparison.findMany({
    where: { userId },
    include: {
      property: {
        include: {
          photos: {
            where: { isPrimary: true },
            take: 1,
          },
        },
      },
    },
    orderBy: { createdAt: 'desc' },
  });
  
  // Group by groupId
  const grouped = comparisons.reduce((acc, comp) => {
    if (!acc[comp.groupId]) {
      acc[comp.groupId] = {
        groupId: comp.groupId,
        createdAt: comp.createdAt,
        properties: [],
      };
    }
    acc[comp.groupId].properties.push(comp.property);
    return acc;
  }, {} as Record<string, any>);
  
  res.json({
    success: true,
    data: { comparisons: Object.values(grouped) },
  });
}));

// Get specific comparison
router.get('/comparisons/:groupId', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const userId = (req as any).user.id;
  const { groupId } = req.params;
  
  const comparisons = await prisma.propertyComparison.findMany({
    where: { userId, groupId },
    include: {
      property: {
        include: {
          photos: true,
          vastuAnalysis: true,
          fengShuiAnalysis: true,
          climateAnalysis: true,
          environmentalData: true,
          energyAnalysis: true,
          neighborhood: true,
          priceHistory: {
            orderBy: { changeDate: 'desc' },
            take: 5,
          },
        },
      },
    },
  });
  
  if (comparisons.length === 0) {
    throw new NotFoundError('Comparison not found');
  }
  
  const properties = comparisons.map(c => c.property);
  const comparison = buildComparisonData(properties);
  
  res.json({
    success: true,
    data: {
      groupId,
      properties,
      comparison,
    },
  });
}));

// Delete comparison group
router.delete('/comparisons/:groupId', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const userId = (req as any).user.id;
  const { groupId } = req.params;
  
  const deleted = await prisma.propertyComparison.deleteMany({
    where: { userId, groupId },
  });
  
  if (deleted.count === 0) {
    throw new NotFoundError('Comparison not found');
  }
  
  res.json({
    success: true,
    message: 'Comparison deleted successfully',
  });
}));

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

async function countMatchingProperties(filters: Record<string, any>): Promise<number> {
  const where = buildWhereClause(filters);
  return prisma.property.count({ where });
}

function buildWhereClause(filters: Record<string, any>): any {
  const where: any = {
    status: filters.status || 'ACTIVE',
  };
  
  if (filters.propertyType?.length > 0) {
    where.propertyType = { in: filters.propertyType };
  }
  
  if (filters.listingType) {
    where.listingType = filters.listingType;
  }
  
  if (filters.minPrice !== undefined || filters.maxPrice !== undefined) {
    where.price = {};
    if (filters.minPrice !== undefined) where.price.gte = filters.minPrice;
    if (filters.maxPrice !== undefined) where.price.lte = filters.maxPrice;
  }
  
  if (filters.minBedrooms !== undefined || filters.maxBedrooms !== undefined) {
    where.bedrooms = {};
    if (filters.minBedrooms !== undefined) where.bedrooms.gte = filters.minBedrooms;
    if (filters.maxBedrooms !== undefined) where.bedrooms.lte = filters.maxBedrooms;
  }
  
  if (filters.minBathrooms !== undefined) {
    where.bathrooms = { gte: filters.minBathrooms };
  }
  
  if (filters.minSquareFeet !== undefined || filters.maxSquareFeet !== undefined) {
    where.squareFeet = {};
    if (filters.minSquareFeet !== undefined) where.squareFeet.gte = filters.minSquareFeet;
    if (filters.maxSquareFeet !== undefined) where.squareFeet.lte = filters.maxSquareFeet;
  }
  
  if (filters.location?.city) {
    where.city = { contains: filters.location.city, mode: 'insensitive' };
  }
  
  if (filters.location?.state) {
    where.state = { contains: filters.location.state, mode: 'insensitive' };
  }
  
  if (filters.features?.length > 0) {
    where.features = { hasSome: filters.features };
  }
  
  if (filters.minVastuScore !== undefined) {
    where.vastuAnalysis = { overallScore: { gte: filters.minVastuScore } };
  }
  
  if (filters.maxClimateRiskScore !== undefined) {
    where.climateAnalysis = { overallRiskScore: { lte: filters.maxClimateRiskScore } };
  }
  
  return where;
}

function buildComparisonData(properties: any[]): any {
  const comparison: any = {
    categories: [],
    winner: null,
    scores: {},
  };
  
  // Basic info comparison
  comparison.categories.push({
    name: 'Basic Info',
    metrics: [
      {
        name: 'Price',
        values: properties.map(p => p.price),
        winner: properties.reduce((min, p) => p.price < min.price ? p : min, properties[0]).id,
        format: 'currency',
      },
      {
        name: 'Price/SqFt',
        values: properties.map(p => p.pricePerSqft),
        winner: properties.reduce((min, p) => (p.pricePerSqft || Infinity) < (min.pricePerSqft || Infinity) ? p : min, properties[0]).id,
        format: 'currency',
      },
      {
        name: 'Square Feet',
        values: properties.map(p => p.squareFeet),
        winner: properties.reduce((max, p) => (p.squareFeet || 0) > (max.squareFeet || 0) ? p : max, properties[0]).id,
        format: 'number',
      },
      {
        name: 'Bedrooms',
        values: properties.map(p => p.bedrooms),
        format: 'number',
      },
      {
        name: 'Bathrooms',
        values: properties.map(p => p.bathrooms),
        format: 'number',
      },
      {
        name: 'Year Built',
        values: properties.map(p => p.yearBuilt),
        winner: properties.reduce((max, p) => (p.yearBuilt || 0) > (max.yearBuilt || 0) ? p : max, properties[0]).id,
        format: 'year',
      },
    ],
  });
  
  // Vastu comparison
  if (properties.some(p => p.vastuAnalysis)) {
    comparison.categories.push({
      name: 'Vastu Shastra',
      metrics: [
        {
          name: 'Overall Score',
          values: properties.map(p => p.vastuAnalysis?.overallScore || null),
          winner: properties.reduce((max, p) => (p.vastuAnalysis?.overallScore || 0) > (max.vastuAnalysis?.overallScore || 0) ? p : max, properties[0]).id,
          format: 'score',
        },
        {
          name: 'Grade',
          values: properties.map(p => p.vastuAnalysis?.grade || 'N/A'),
          format: 'grade',
        },
        {
          name: 'Entrance Direction',
          values: properties.map(p => p.vastuAnalysis?.entranceDirection || 'N/A'),
          format: 'text',
        },
      ],
    });
  }
  
  // Climate comparison
  if (properties.some(p => p.climateAnalysis)) {
    comparison.categories.push({
      name: 'Climate Risk',
      metrics: [
        {
          name: 'Overall Risk',
          values: properties.map(p => p.climateAnalysis?.overallRiskScore || null),
          winner: properties.reduce((min, p) => (p.climateAnalysis?.overallRiskScore || 100) < (min.climateAnalysis?.overallRiskScore || 100) ? p : min, properties[0]).id,
          format: 'risk',
          lowerIsBetter: true,
        },
        {
          name: 'Risk Grade',
          values: properties.map(p => p.climateAnalysis?.riskGrade || 'N/A'),
          format: 'grade',
        },
        {
          name: 'Flood Risk 2030',
          values: properties.map(p => p.climateAnalysis?.floodRisk2030 || null),
          format: 'percent',
          lowerIsBetter: true,
        },
        {
          name: 'Wildfire Risk',
          values: properties.map(p => p.climateAnalysis?.wildfireRisk || null),
          format: 'percent',
          lowerIsBetter: true,
        },
      ],
    });
  }
  
  // Environmental comparison
  if (properties.some(p => p.environmentalData)) {
    comparison.categories.push({
      name: 'Environment',
      metrics: [
        {
          name: 'Air Quality (AQI)',
          values: properties.map(p => p.environmentalData?.aqiCurrent || null),
          winner: properties.reduce((min, p) => (p.environmentalData?.aqiCurrent || 500) < (min.environmentalData?.aqiCurrent || 500) ? p : min, properties[0]).id,
          format: 'number',
          lowerIsBetter: true,
        },
        {
          name: 'Noise Level (dB)',
          values: properties.map(p => p.environmentalData?.avgNoiseDecibels || null),
          format: 'number',
          lowerIsBetter: true,
        },
        {
          name: 'EMF Level',
          values: properties.map(p => p.environmentalData?.emfLevel || null),
          format: 'number',
          lowerIsBetter: true,
        },
      ],
    });
  }
  
  // Neighborhood comparison
  if (properties.some(p => p.neighborhood)) {
    comparison.categories.push({
      name: 'Neighborhood',
      metrics: [
        {
          name: 'Walk Score',
          values: properties.map(p => p.neighborhood?.walkabilityScore || null),
          winner: properties.reduce((max, p) => (p.neighborhood?.walkabilityScore || 0) > (max.neighborhood?.walkabilityScore || 0) ? p : max, properties[0]).id,
          format: 'score',
        },
        {
          name: 'Transit Score',
          values: properties.map(p => p.neighborhood?.transitScore || null),
          format: 'score',
        },
        {
          name: 'School Rating',
          values: properties.map(p => p.neighborhood?.schoolRating || null),
          format: 'rating',
        },
        {
          name: 'Crime Index',
          values: properties.map(p => p.neighborhood?.crimeIndex || null),
          format: 'number',
          lowerIsBetter: true,
        },
      ],
    });
  }
  
  // Energy comparison
  if (properties.some(p => p.energyAnalysis)) {
    comparison.categories.push({
      name: 'Energy',
      metrics: [
        {
          name: 'Efficiency Score',
          values: properties.map(p => p.energyAnalysis?.energyEfficiencyScore || null),
          winner: properties.reduce((max, p) => (p.energyAnalysis?.energyEfficiencyScore || 0) > (max.energyAnalysis?.energyEfficiencyScore || 0) ? p : max, properties[0]).id,
          format: 'score',
        },
        {
          name: 'Annual Electricity (kWh)',
          values: properties.map(p => p.energyAnalysis?.annualElectricityKwh || null),
          format: 'number',
          lowerIsBetter: true,
        },
        {
          name: 'Solar Potential (kWh)',
          values: properties.map(p => p.energyAnalysis?.solarPotentialKwh || null),
          format: 'number',
        },
        {
          name: 'Carbon Footprint (tons)',
          values: properties.map(p => p.energyAnalysis?.carbonFootprintTons || null),
          format: 'number',
          lowerIsBetter: true,
        },
      ],
    });
  }
  
  // Calculate overall winner based on weighted scoring
  const scores: Record<string, number> = {};
  properties.forEach(p => {
    scores[p.id] = 0;
    
    // Price efficiency (30% weight)
    const avgPrice = properties.reduce((sum, prop) => sum + prop.price, 0) / properties.length;
    scores[p.id] += (1 - p.price / avgPrice) * 30;
    
    // Vastu score (25% weight)
    if (p.vastuAnalysis?.overallScore) {
      scores[p.id] += (p.vastuAnalysis.overallScore / 100) * 25;
    }
    
    // Climate safety (20% weight)
    if (p.climateAnalysis?.overallRiskScore !== undefined) {
      scores[p.id] += (1 - p.climateAnalysis.overallRiskScore / 100) * 20;
    }
    
    // Size value (15% weight)
    const avgSqft = properties.reduce((sum, prop) => sum + (prop.squareFeet || 0), 0) / properties.length;
    if (p.squareFeet) {
      scores[p.id] += (p.squareFeet / avgSqft) * 15;
    }
    
    // Neighborhood (10% weight)
    if (p.neighborhood?.walkabilityScore) {
      scores[p.id] += (p.neighborhood.walkabilityScore / 100) * 10;
    }
  });
  
  comparison.scores = scores;
  comparison.winner = Object.entries(scores).sort((a, b) => b[1] - a[1])[0][0];
  
  return comparison;
}

export default router;
Messages · TS
import { Router, Request, Response } from 'express';
import { z } from 'zod';
import { prisma } from '../utils/prisma';
import { redis, redisPub } from '../utils/redis';
import { authenticate } from '../middleware/auth';
import { asyncHandler, BadRequestError, NotFoundError, ForbiddenError } from '../middleware/errorHandler';

const router = Router();

// ============================================================================
// SCHEMAS
// ============================================================================

const sendMessageSchema = z.object({
  recipientId: z.string().uuid(),
  content: z.string().min(1).max(5000),
  messageType: z.enum(['TEXT', 'IMAGE', 'DOCUMENT', 'VOICE', 'VIDEO']).default('TEXT'),
  propertyId: z.string().uuid().optional(),
  leadId: z.string().uuid().optional(),
  attachmentUrl: z.string().url().optional(),
});

const updateMessageSchema = z.object({
  read: z.boolean().optional(),
});

// ============================================================================
// CONVERSATIONS
// ============================================================================

// Get all conversations
router.get('/conversations', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const userId = (req as any).user.id;
  
  // Get all unique conversation partners
  const sentMessages = await prisma.message.findMany({
    where: { senderId: userId },
    select: {
      recipientId: true,
      propertyId: true,
      leadId: true,
    },
    distinct: ['recipientId'],
  });
  
  const receivedMessages = await prisma.message.findMany({
    where: { recipientId: userId },
    select: {
      senderId: true,
      propertyId: true,
      leadId: true,
    },
    distinct: ['senderId'],
  });
  
  // Combine unique partners
  const partnerIds = new Set([
    ...sentMessages.map(m => m.recipientId),
    ...receivedMessages.map(m => m.senderId),
  ]);
  
  // Get conversation details for each partner
  const conversations = await Promise.all(
    Array.from(partnerIds).map(async (partnerId) => {
      // Get partner info
      const partner = await prisma.user.findUnique({
        where: { id: partnerId },
        select: {
          id: true,
          firstName: true,
          lastName: true,
          email: true,
          userType: true,
          agent: {
            select: {
              brokerage: true,
              isVerified: true,
            },
          },
        },
      });
      
      // Get last message
      const lastMessage = await prisma.message.findFirst({
        where: {
          OR: [
            { senderId: userId, recipientId: partnerId },
            { senderId: partnerId, recipientId: userId },
          ],
        },
        orderBy: { createdAt: 'desc' },
        select: {
          id: true,
          content: true,
          messageType: true,
          createdAt: true,
          senderId: true,
          read: true,
        },
      });
      
      // Get unread count
      const unreadCount = await prisma.message.count({
        where: {
          senderId: partnerId,
          recipientId: userId,
          read: false,
        },
      });
      
      // Get associated property if any
      const propertyMessage = await prisma.message.findFirst({
        where: {
          OR: [
            { senderId: userId, recipientId: partnerId },
            { senderId: partnerId, recipientId: userId },
          ],
          propertyId: { not: null },
        },
        orderBy: { createdAt: 'desc' },
        include: {
          property: {
            select: {
              id: true,
              title: true,
              address: true,
              photos: {
                where: { isPrimary: true },
                take: 1,
              },
            },
          },
        },
      });
      
      return {
        partnerId,
        partner,
        lastMessage,
        unreadCount,
        property: propertyMessage?.property || null,
        updatedAt: lastMessage?.createdAt,
      };
    })
  );
  
  // Sort by most recent
  conversations.sort((a, b) => {
    const dateA = a.updatedAt ? new Date(a.updatedAt).getTime() : 0;
    const dateB = b.updatedAt ? new Date(b.updatedAt).getTime() : 0;
    return dateB - dateA;
  });
  
  // Get total unread count
  const totalUnread = conversations.reduce((sum, c) => sum + c.unreadCount, 0);
  
  res.json({
    success: true,
    data: {
      conversations,
      totalUnread,
    },
  });
}));

// Get conversation with specific user
router.get('/conversations/:partnerId', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const userId = (req as any).user.id;
  const { partnerId } = req.params;
  const page = parseInt(req.query.page as string) || 1;
  const limit = Math.min(parseInt(req.query.limit as string) || 50, 100);
  const before = req.query.before as string;
  
  // Get partner info
  const partner = await prisma.user.findUnique({
    where: { id: partnerId },
    select: {
      id: true,
      firstName: true,
      lastName: true,
      email: true,
      userType: true,
      agent: {
        select: {
          brokerage: true,
          isVerified: true,
          responseTime: true,
        },
      },
    },
  });
  
  if (!partner) {
    throw new NotFoundError('User not found');
  }
  
  // Build query
  const where: any = {
    OR: [
      { senderId: userId, recipientId: partnerId },
      { senderId: partnerId, recipientId: userId },
    ],
  };
  
  if (before) {
    where.createdAt = { lt: new Date(before) };
  }
  
  // Get messages
  const [messages, total] = await Promise.all([
    prisma.message.findMany({
      where,
      orderBy: { createdAt: 'desc' },
      take: limit,
      include: {
        sender: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
          },
        },
        property: {
          select: {
            id: true,
            title: true,
            address: true,
            price: true,
            photos: {
              where: { isPrimary: true },
              take: 1,
            },
          },
        },
      },
    }),
    prisma.message.count({ where }),
  ]);
  
  // Mark messages as read
  await prisma.message.updateMany({
    where: {
      senderId: partnerId,
      recipientId: userId,
      read: false,
    },
    data: { read: true },
  });
  
  // Publish read receipt via Redis
  await redisPub.publish(`user:${partnerId}:messages`, JSON.stringify({
    type: 'READ_RECEIPT',
    conversationWith: userId,
    timestamp: new Date().toISOString(),
  }));
  
  res.json({
    success: true,
    data: {
      partner,
      messages: messages.reverse(), // Return in chronological order
      pagination: {
        total,
        hasMore: total > page * limit,
        oldestMessageDate: messages.length > 0 ? messages[messages.length - 1].createdAt : null,
      },
    },
  });
}));

// ============================================================================
// MESSAGES
// ============================================================================

// Send message
router.post('/', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const senderId = (req as any).user.id;
  const validated = sendMessageSchema.parse(req.body);
  
  // Verify recipient exists
  const recipient = await prisma.user.findUnique({
    where: { id: validated.recipientId },
    select: {
      id: true,
      firstName: true,
      lastName: true,
      email: true,
    },
  });
  
  if (!recipient) {
    throw new NotFoundError('Recipient not found');
  }
  
  // Can't message yourself
  if (senderId === validated.recipientId) {
    throw new BadRequestError('Cannot send message to yourself');
  }
  
  // Verify property if provided
  if (validated.propertyId) {
    const property = await prisma.property.findUnique({
      where: { id: validated.propertyId },
    });
    if (!property) {
      throw new NotFoundError('Property not found');
    }
  }
  
  // Verify lead if provided
  if (validated.leadId) {
    const lead = await prisma.lead.findUnique({
      where: { id: validated.leadId },
    });
    if (!lead) {
      throw new NotFoundError('Lead not found');
    }
  }
  
  // Create message
  const message = await prisma.message.create({
    data: {
      senderId,
      recipientId: validated.recipientId,
      content: validated.content,
      messageType: validated.messageType,
      propertyId: validated.propertyId,
      leadId: validated.leadId,
      read: false,
    },
    include: {
      sender: {
        select: {
          id: true,
          firstName: true,
          lastName: true,
        },
      },
      property: {
        select: {
          id: true,
          title: true,
          address: true,
        },
      },
    },
  });
  
  // Publish message via Redis for real-time delivery
  await redisPub.publish(`user:${validated.recipientId}:messages`, JSON.stringify({
    type: 'NEW_MESSAGE',
    message,
  }));
  
  // Create notification for recipient
  await prisma.notification.create({
    data: {
      userId: validated.recipientId,
      type: 'MESSAGE',
      title: `New message from ${(req as any).user.firstName}`,
      message: validated.content.substring(0, 100) + (validated.content.length > 100 ? '...' : ''),
      data: {
        senderId,
        messageId: message.id,
        propertyId: validated.propertyId,
      },
      actionUrl: `/messages/${senderId}`,
    },
  });
  
  // Update lead activity if lead is associated
  if (validated.leadId) {
    await prisma.lead.update({
      where: { id: validated.leadId },
      data: { updatedAt: new Date() },
    });
  }
  
  res.status(201).json({
    success: true,
    data: { message },
  });
}));

// Get all messages (paginated)
router.get('/', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const userId = (req as any).user.id;
  const page = parseInt(req.query.page as string) || 1;
  const limit = Math.min(parseInt(req.query.limit as string) || 50, 100);
  const unreadOnly = req.query.unreadOnly === 'true';
  
  const where: any = {
    OR: [
      { senderId: userId },
      { recipientId: userId },
    ],
  };
  
  if (unreadOnly) {
    where.recipientId = userId;
    where.read = false;
  }
  
  const [messages, total] = await Promise.all([
    prisma.message.findMany({
      where,
      orderBy: { createdAt: 'desc' },
      skip: (page - 1) * limit,
      take: limit,
      include: {
        sender: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
          },
        },
        recipient: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
          },
        },
        property: {
          select: {
            id: true,
            title: true,
          },
        },
      },
    }),
    prisma.message.count({ where }),
  ]);
  
  res.json({
    success: true,
    data: {
      messages,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit),
      },
    },
  });
}));

// Get single message
router.get('/:id', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const userId = (req as any).user.id;
  const { id } = req.params;
  
  const message = await prisma.message.findUnique({
    where: { id },
    include: {
      sender: {
        select: {
          id: true,
          firstName: true,
          lastName: true,
        },
      },
      recipient: {
        select: {
          id: true,
          firstName: true,
          lastName: true,
        },
      },
      property: {
        select: {
          id: true,
          title: true,
          address: true,
          photos: {
            where: { isPrimary: true },
            take: 1,
          },
        },
      },
    },
  });
  
  if (!message) {
    throw new NotFoundError('Message not found');
  }
  
  // Verify user is sender or recipient
  if (message.senderId !== userId && message.recipientId !== userId) {
    throw new ForbiddenError('Not authorized to view this message');
  }
  
  // Mark as read if recipient
  if (message.recipientId === userId && !message.read) {
    await prisma.message.update({
      where: { id },
      data: { read: true },
    });
    
    // Publish read receipt
    await redisPub.publish(`user:${message.senderId}:messages`, JSON.stringify({
      type: 'READ_RECEIPT',
      messageId: id,
      timestamp: new Date().toISOString(),
    }));
  }
  
  res.json({
    success: true,
    data: { message },
  });
}));

// Mark message as read
router.put('/:id/read', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const userId = (req as any).user.id;
  const { id } = req.params;
  
  const message = await prisma.message.findUnique({
    where: { id },
  });
  
  if (!message) {
    throw new NotFoundError('Message not found');
  }
  
  if (message.recipientId !== userId) {
    throw new ForbiddenError('Not authorized to mark this message as read');
  }
  
  if (!message.read) {
    await prisma.message.update({
      where: { id },
      data: { read: true },
    });
    
    // Publish read receipt
    await redisPub.publish(`user:${message.senderId}:messages`, JSON.stringify({
      type: 'READ_RECEIPT',
      messageId: id,
      timestamp: new Date().toISOString(),
    }));
  }
  
  res.json({
    success: true,
    message: 'Message marked as read',
  });
}));

// Mark all messages in conversation as read
router.put('/conversations/:partnerId/read-all', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const userId = (req as any).user.id;
  const { partnerId } = req.params;
  
  const updated = await prisma.message.updateMany({
    where: {
      senderId: partnerId,
      recipientId: userId,
      read: false,
    },
    data: { read: true },
  });
  
  // Publish read receipt
  await redisPub.publish(`user:${partnerId}:messages`, JSON.stringify({
    type: 'READ_ALL_RECEIPT',
    conversationWith: userId,
    timestamp: new Date().toISOString(),
  }));
  
  res.json({
    success: true,
    message: `${updated.count} messages marked as read`,
  });
}));

// Delete message (soft delete - just removes for sender)
router.delete('/:id', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const userId = (req as any).user.id;
  const { id } = req.params;
  
  const message = await prisma.message.findUnique({
    where: { id },
  });
  
  if (!message) {
    throw new NotFoundError('Message not found');
  }
  
  // Only sender can delete
  if (message.senderId !== userId) {
    throw new ForbiddenError('Not authorized to delete this message');
  }
  
  // For now, hard delete (in production, would soft delete)
  await prisma.message.delete({ where: { id } });
  
  res.json({
    success: true,
    message: 'Message deleted',
  });
}));

// ============================================================================
// TYPING INDICATORS
// ============================================================================

// Send typing indicator
router.post('/typing', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const userId = (req as any).user.id;
  const { recipientId, isTyping } = req.body;
  
  if (!recipientId) {
    throw new BadRequestError('recipientId is required');
  }
  
  // Publish typing indicator via Redis
  await redisPub.publish(`user:${recipientId}:messages`, JSON.stringify({
    type: 'TYPING_INDICATOR',
    senderId: userId,
    isTyping: !!isTyping,
    timestamp: new Date().toISOString(),
  }));
  
  res.json({
    success: true,
  });
}));

// ============================================================================
// QUICK REPLIES
// ============================================================================

// Get quick reply templates
router.get('/quick-replies', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const userType = (req as any).user.userType;
  
  let quickReplies: Array<{ id: string; label: string; message: string }> = [];
  
  if (userType === 'AGENT') {
    quickReplies = [
      { id: 'available', label: 'Property Available', message: 'Yes, this property is still available! When would you like to schedule a viewing?' },
      { id: 'schedule', label: 'Schedule Viewing', message: 'I\'d be happy to arrange a viewing. What times work best for you this week?' },
      { id: 'more_info', label: 'Send More Info', message: 'I\'ll send you the full property details including the Vastu analysis and climate report shortly.' },
      { id: 'price_drop', label: 'Price Negotiable', message: 'The seller may be open to negotiation. Would you like to discuss making an offer?' },
      { id: 'similar', label: 'Similar Properties', message: 'I have a few similar properties that might interest you. Would you like me to share them?' },
      { id: 'vastu_certified', label: 'Vastu Certified', message: 'This property has been certified as Vastu-compliant with a score of [X]/100. I can share the full analysis report.' },
      { id: 'climate_safe', label: 'Climate Safe', message: 'This property has a low climate risk rating with minimal flood and fire exposure projected through 2050.' },
      { id: 'thank_you', label: 'Thank You', message: 'Thank you for your interest! Please don\'t hesitate to reach out if you have any questions.' },
    ];
  } else {
    quickReplies = [
      { id: 'interested', label: 'I\'m Interested', message: 'I\'m very interested in this property. Can you tell me more about it?' },
      { id: 'schedule', label: 'Schedule Viewing', message: 'I\'d like to schedule a viewing. What times are available?' },
      { id: 'vastu', label: 'Vastu Info', message: 'Can you share the Vastu analysis for this property?' },
      { id: 'climate', label: 'Climate Report', message: 'I\'d like to see the climate risk assessment for this property.' },
      { id: 'price', label: 'Price Question', message: 'Is the price negotiable? What\'s the best offer you\'ve received?' },
      { id: 'similar', label: 'Similar Properties', message: 'Do you have similar properties in this area?' },
      { id: 'financing', label: 'Financing', message: 'What financing options are available for this property?' },
      { id: 'thank_you', label: 'Thank You', message: 'Thank you for the information! I\'ll get back to you soon.' },
    ];
  }
  
  res.json({
    success: true,
    data: { quickReplies },
  });
}));

export default router;
Notifications · TS
import { Router, Request, Response } from 'express';
import { z } from 'zod';
import { prisma } from '../utils/prisma';
import { redis, redisPub } from '../utils/redis';
import { authenticate } from '../middleware/auth';
import { asyncHandler, BadRequestError, NotFoundError, ForbiddenError } from '../middleware/errorHandler';

const router = Router();

// ============================================================================
// SCHEMAS
// ============================================================================

const notificationPreferencesSchema = z.object({
  email: z.object({
    newListings: z.boolean().default(true),
    priceChanges: z.boolean().default(true),
    messages: z.boolean().default(true),
    showingReminders: z.boolean().default(true),
    auspiciousDates: z.boolean().default(true),
    climateAlerts: z.boolean().default(true),
    sensorAlerts: z.boolean().default(false),
    weeklyDigest: z.boolean().default(true),
  }).optional(),
  push: z.object({
    newListings: z.boolean().default(true),
    priceChanges: z.boolean().default(true),
    messages: z.boolean().default(true),
    showingReminders: z.boolean().default(true),
    auspiciousDates: z.boolean().default(false),
    climateAlerts: z.boolean().default(true),
    sensorAlerts: z.boolean().default(false),
  }).optional(),
  sms: z.object({
    messages: z.boolean().default(false),
    showingReminders: z.boolean().default(true),
    urgentAlerts: z.boolean().default(true),
  }).optional(),
});

const createNotificationSchema = z.object({
  userId: z.string().uuid(),
  type: z.enum([
    'NEW_LISTING', 'PRICE_CHANGE', 'NEW_LEAD', 'MESSAGE', 
    'SHOWING_REMINDER', 'AUSPICIOUS_DATE', 'CLIMATE_ALERT', 
    'SENSOR_ALERT', 'SYSTEM', 'PROPERTY_UPDATE', 'OFFER_RECEIVED',
    'OFFER_ACCEPTED', 'OFFER_REJECTED', 'DOCUMENT_READY',
    'VASTU_CERTIFICATE', 'TOKEN_REWARD', 'DAO_PROPOSAL'
  ]),
  title: z.string().min(1).max(200),
  message: z.string().min(1).max(1000),
  data: z.record(z.any()).optional(),
  actionUrl: z.string().optional(),
  priority: z.enum(['LOW', 'NORMAL', 'HIGH', 'URGENT']).default('NORMAL'),
});

// ============================================================================
// NOTIFICATIONS
// ============================================================================

// Get all notifications for user
router.get('/', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const userId = (req as any).user.id;
  const page = parseInt(req.query.page as string) || 1;
  const limit = Math.min(parseInt(req.query.limit as string) || 20, 100);
  const unreadOnly = req.query.unreadOnly === 'true';
  const type = req.query.type as string;
  
  const where: any = { userId };
  
  if (unreadOnly) {
    where.read = false;
  }
  
  if (type) {
    where.type = type;
  }
  
  const [notifications, total, unreadCount] = await Promise.all([
    prisma.notification.findMany({
      where,
      orderBy: { createdAt: 'desc' },
      skip: (page - 1) * limit,
      take: limit,
    }),
    prisma.notification.count({ where }),
    prisma.notification.count({ where: { userId, read: false } }),
  ]);
  
  res.json({
    success: true,
    data: {
      notifications,
      unreadCount,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit),
      },
    },
  });
}));

// Get notification by ID
router.get('/:id', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const userId = (req as any).user.id;
  const { id } = req.params;
  
  const notification = await prisma.notification.findUnique({
    where: { id },
  });
  
  if (!notification) {
    throw new NotFoundError('Notification not found');
  }
  
  if (notification.userId !== userId) {
    throw new ForbiddenError('Not authorized to view this notification');
  }
  
  // Mark as read
  if (!notification.read) {
    await prisma.notification.update({
      where: { id },
      data: { read: true },
    });
  }
  
  res.json({
    success: true,
    data: { notification },
  });
}));

// Mark notification as read
router.put('/:id/read', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const userId = (req as any).user.id;
  const { id } = req.params;
  
  const notification = await prisma.notification.findUnique({
    where: { id },
  });
  
  if (!notification) {
    throw new NotFoundError('Notification not found');
  }
  
  if (notification.userId !== userId) {
    throw new ForbiddenError('Not authorized to update this notification');
  }
  
  await prisma.notification.update({
    where: { id },
    data: { read: true },
  });
  
  res.json({
    success: true,
    message: 'Notification marked as read',
  });
}));

// Mark all notifications as read
router.put('/read-all', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const userId = (req as any).user.id;
  const type = req.query.type as string;
  
  const where: any = { userId, read: false };
  if (type) {
    where.type = type;
  }
  
  const result = await prisma.notification.updateMany({
    where,
    data: { read: true },
  });
  
  res.json({
    success: true,
    message: `${result.count} notifications marked as read`,
  });
}));

// Delete notification
router.delete('/:id', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const userId = (req as any).user.id;
  const { id } = req.params;
  
  const notification = await prisma.notification.findUnique({
    where: { id },
  });
  
  if (!notification) {
    throw new NotFoundError('Notification not found');
  }
  
  if (notification.userId !== userId) {
    throw new ForbiddenError('Not authorized to delete this notification');
  }
  
  await prisma.notification.delete({ where: { id } });
  
  res.json({
    success: true,
    message: 'Notification deleted',
  });
}));

// Delete all read notifications
router.delete('/clear-read', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const userId = (req as any).user.id;
  
  const result = await prisma.notification.deleteMany({
    where: { userId, read: true },
  });
  
  res.json({
    success: true,
    message: `${result.count} notifications deleted`,
  });
}));

// Get unread count
router.get('/count/unread', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const userId = (req as any).user.id;
  
  const [total, byType] = await Promise.all([
    prisma.notification.count({ where: { userId, read: false } }),
    prisma.notification.groupBy({
      by: ['type'],
      where: { userId, read: false },
      _count: true,
    }),
  ]);
  
  const typeBreakdown = byType.reduce((acc, item) => {
    acc[item.type] = item._count;
    return acc;
  }, {} as Record<string, number>);
  
  res.json({
    success: true,
    data: {
      total,
      byType: typeBreakdown,
    },
  });
}));

// ============================================================================
// NOTIFICATION PREFERENCES
// ============================================================================

// Get notification preferences
router.get('/preferences', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const userId = (req as any).user.id;
  
  // Get or create preferences
  let preferences = await redis.get(`user:${userId}:notification_preferences`);
  
  if (!preferences) {
    // Default preferences
    preferences = JSON.stringify({
      email: {
        newListings: true,
        priceChanges: true,
        messages: true,
        showingReminders: true,
        auspiciousDates: true,
        climateAlerts: true,
        sensorAlerts: false,
        weeklyDigest: true,
      },
      push: {
        newListings: true,
        priceChanges: true,
        messages: true,
        showingReminders: true,
        auspiciousDates: false,
        climateAlerts: true,
        sensorAlerts: false,
      },
      sms: {
        messages: false,
        showingReminders: true,
        urgentAlerts: true,
      },
    });
  }
  
  res.json({
    success: true,
    data: { preferences: JSON.parse(preferences as string) },
  });
}));

// Update notification preferences
router.put('/preferences', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const userId = (req as any).user.id;
  const validated = notificationPreferencesSchema.parse(req.body);
  
  // Get existing preferences
  let existing = await redis.get(`user:${userId}:notification_preferences`);
  let preferences = existing ? JSON.parse(existing as string) : {};
  
  // Merge with updates
  if (validated.email) {
    preferences.email = { ...preferences.email, ...validated.email };
  }
  if (validated.push) {
    preferences.push = { ...preferences.push, ...validated.push };
  }
  if (validated.sms) {
    preferences.sms = { ...preferences.sms, ...validated.sms };
  }
  
  // Save preferences
  await redis.setex(`user:${userId}:notification_preferences`, 86400 * 365, JSON.stringify(preferences));
  
  res.json({
    success: true,
    data: { preferences },
  });
}));

// ============================================================================
// ADMIN: CREATE NOTIFICATION
// ============================================================================

router.post('/admin/create', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const adminUser = (req as any).user;
  
  // Check if admin
  if (adminUser.userType !== 'ADMIN') {
    throw new ForbiddenError('Admin access required');
  }
  
  const validated = createNotificationSchema.parse(req.body);
  
  const notification = await prisma.notification.create({
    data: validated,
  });
  
  // Publish via Redis for real-time delivery
  await redisPub.publish(`user:${validated.userId}:notifications`, JSON.stringify({
    type: 'NEW_NOTIFICATION',
    notification,
  }));
  
  res.status(201).json({
    success: true,
    data: { notification },
  });
}));

// Broadcast notification to all users
router.post('/admin/broadcast', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const adminUser = (req as any).user;
  
  // Check if admin
  if (adminUser.userType !== 'ADMIN') {
    throw new ForbiddenError('Admin access required');
  }
  
  const { title, message, type = 'SYSTEM', data, actionUrl, userFilter } = req.body;
  
  if (!title || !message) {
    throw new BadRequestError('Title and message are required');
  }
  
  // Build user filter
  const where: any = {};
  if (userFilter?.userType) {
    where.userType = userFilter.userType;
  }
  
  // Get all matching users
  const users = await prisma.user.findMany({
    where,
    select: { id: true },
  });
  
  // Create notifications in batch
  const notifications = await prisma.notification.createMany({
    data: users.map(user => ({
      userId: user.id,
      type,
      title,
      message,
      data,
      actionUrl,
    })),
  });
  
  res.json({
    success: true,
    data: {
      sent: notifications.count,
      message: `Notification broadcast to ${notifications.count} users`,
    },
  });
}));

// ============================================================================
// NOTIFICATION TEMPLATES
// ============================================================================

// Get notification templates
router.get('/templates', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const templates = {
    NEW_LISTING: {
      title: 'New Listing Alert',
      message: 'A new property matching your search criteria has been listed: {propertyTitle} in {city}',
      variables: ['propertyTitle', 'city', 'price', 'bedrooms'],
    },
    PRICE_CHANGE: {
      title: 'Price Drop Alert',
      message: '{propertyTitle} has dropped in price from {oldPrice} to {newPrice} - a {percentChange}% reduction!',
      variables: ['propertyTitle', 'oldPrice', 'newPrice', 'percentChange'],
    },
    SHOWING_REMINDER: {
      title: 'Showing Reminder',
      message: 'Reminder: You have a showing scheduled for {propertyTitle} at {time} on {date}',
      variables: ['propertyTitle', 'time', 'date', 'agentName'],
    },
    AUSPICIOUS_DATE: {
      title: 'Auspicious Date Alert',
      message: '{date} is an auspicious day for {eventType} based on Vedic astrology. Consider scheduling your {eventType} on this date.',
      variables: ['date', 'eventType', 'nakshatra', 'tithi'],
    },
    CLIMATE_ALERT: {
      title: 'Climate Risk Update',
      message: 'Climate risk assessment has been updated for properties in {area}. {count} saved properties may be affected.',
      variables: ['area', 'count', 'riskType'],
    },
    SENSOR_ALERT: {
      title: 'Environmental Alert',
      message: '{sensorType} reading at {propertyAddress} has exceeded threshold: {reading} {unit}',
      variables: ['sensorType', 'propertyAddress', 'reading', 'unit', 'threshold'],
    },
    VASTU_CERTIFICATE: {
      title: 'Vastu Certificate Ready',
      message: 'The Vastu compliance certificate for {propertyTitle} is ready. Overall score: {score}/100 ({grade})',
      variables: ['propertyTitle', 'score', 'grade'],
    },
    TOKEN_REWARD: {
      title: 'Token Reward',
      message: 'You earned {amount} DHARMA tokens for {reason}. Your new balance is {balance}.',
      variables: ['amount', 'reason', 'balance'],
    },
    DAO_PROPOSAL: {
      title: 'New DAO Proposal',
      message: 'A new governance proposal has been submitted: "{proposalTitle}". Voting ends {endDate}.',
      variables: ['proposalTitle', 'endDate', 'proposalType'],
    },
  };
  
  res.json({
    success: true,
    data: { templates },
  });
}));

// ============================================================================
// HELPER: Send notification with template
// ============================================================================

export async function sendNotification(
  userId: string,
  type: string,
  variables: Record<string, any>,
  options?: {
    actionUrl?: string;
    priority?: 'LOW' | 'NORMAL' | 'HIGH' | 'URGENT';
  }
): Promise<void> {
  const templates: Record<string, { title: string; message: string }> = {
    NEW_LISTING: {
      title: 'New Listing Alert',
      message: `A new property matching your search: ${variables.propertyTitle} in ${variables.city}`,
    },
    PRICE_CHANGE: {
      title: 'Price Drop Alert',
      message: `${variables.propertyTitle} price dropped to ${variables.newPrice}`,
    },
    MESSAGE: {
      title: `New message from ${variables.senderName}`,
      message: variables.preview || 'You have a new message',
    },
    SHOWING_REMINDER: {
      title: 'Showing Reminder',
      message: `Showing for ${variables.propertyTitle} at ${variables.time}`,
    },
    AUSPICIOUS_DATE: {
      title: 'Auspicious Date',
      message: `${variables.date} is favorable for ${variables.eventType}`,
    },
  };
  
  const template = templates[type] || { title: type, message: JSON.stringify(variables) };
  
  const notification = await prisma.notification.create({
    data: {
      userId,
      type: type as any,
      title: template.title,
      message: template.message,
      data: variables,
      actionUrl: options?.actionUrl,
    },
  });
  
  // Publish for real-time delivery
  await redisPub.publish(`user:${userId}:notifications`, JSON.stringify({
    type: 'NEW_NOTIFICATION',
    notification,
  }));
}

export default router;
Astrology · TS
import { Router, Request, Response } from 'express';
import { z } from 'zod';
import { prisma } from '../utils/prisma';
import { redis, cacheKeys, cacheTTL } from '../utils/redis';
import { authenticate } from '../middleware/auth';
import { asyncHandler, BadRequestError, NotFoundError } from '../middleware/errorHandler';

const router = Router();

// ============================================================================
// SCHEMAS
// ============================================================================

const birthDetailsSchema = z.object({
  dateOfBirth: z.string().datetime().or(z.string().regex(/^\d{4}-\d{2}-\d{2}$/)),
  timeOfBirth: z.string().regex(/^([01]?[0-9]|2[0-3]):[0-5][0-9]$/),
  placeOfBirth: z.object({
    city: z.string(),
    state: z.string().optional(),
    country: z.string(),
    latitude: z.number().optional(),
    longitude: z.number().optional(),
  }),
});

const auspiciousDatesSchema = z.object({
  eventType: z.enum([
    'PROPERTY_VIEWING', 'MAKING_OFFER', 'SIGNING_CONTRACT', 
    'CLOSING', 'GRIHA_PRAVESH', 'RENOVATION_START', 
    'BHOOMI_PUJA', 'MOVING_IN'
  ]),
  startDate: z.string().datetime().or(z.string().regex(/^\d{4}-\d{2}-\d{2}$/)),
  endDate: z.string().datetime().or(z.string().regex(/^\d{4}-\d{2}-\d{2}$/)),
  birthDetails: birthDetailsSchema.optional(),
});

const muhuratSchema = z.object({
  eventType: z.enum([
    'PROPERTY_VIEWING', 'MAKING_OFFER', 'SIGNING_CONTRACT', 
    'CLOSING', 'GRIHA_PRAVESH', 'RENOVATION_START',
    'BHOOMI_PUJA', 'MOVING_IN'
  ]),
  date: z.string().datetime().or(z.string().regex(/^\d{4}-\d{2}-\d{2}$/)),
  birthDetails: birthDetailsSchema.optional(),
});

const propertyMatchSchema = z.object({
  propertyId: z.string().uuid(),
  buyerBirthDetails: birthDetailsSchema,
});

// ============================================================================
// VEDIC ASTROLOGY DATA
// ============================================================================

const NAKSHATRAS = [
  { name: 'Ashwini', deity: 'Ashwini Kumaras', element: 'Ketu', nature: 'Swift', goodFor: ['new beginnings', 'travel', 'medical'] },
  { name: 'Bharani', deity: 'Yama', element: 'Venus', nature: 'Fierce', goodFor: ['cremation', 'destruction'] },
  { name: 'Krittika', deity: 'Agni', element: 'Sun', nature: 'Mixed', goodFor: ['fire ceremonies', 'cooking'] },
  { name: 'Rohini', deity: 'Brahma', element: 'Moon', nature: 'Fixed', goodFor: ['agriculture', 'marriage', 'property purchase'] },
  { name: 'Mrigashira', deity: 'Soma', element: 'Mars', nature: 'Soft', goodFor: ['travel', 'gardens', 'art'] },
  { name: 'Ardra', deity: 'Rudra', element: 'Rahu', nature: 'Sharp', goodFor: ['destruction', 'surgery'] },
  { name: 'Punarvasu', deity: 'Aditi', element: 'Jupiter', nature: 'Movable', goodFor: ['travel', 'returning home', 'griha pravesh'] },
  { name: 'Pushya', deity: 'Brihaspati', element: 'Saturn', nature: 'Light', goodFor: ['all auspicious activities', 'property', 'investment'] },
  { name: 'Ashlesha', deity: 'Nagas', element: 'Mercury', nature: 'Sharp', goodFor: ['administering poison', 'filing lawsuits'] },
  { name: 'Magha', deity: 'Pitris', element: 'Ketu', nature: 'Fierce', goodFor: ['ancestral rites', 'government work'] },
  { name: 'Purva Phalguni', deity: 'Bhaga', element: 'Venus', nature: 'Fierce', goodFor: ['marriage', 'romance', 'relaxation'] },
  { name: 'Uttara Phalguni', deity: 'Aryaman', element: 'Sun', nature: 'Fixed', goodFor: ['marriage', 'agreements', 'property'] },
  { name: 'Hasta', deity: 'Savitar', element: 'Moon', nature: 'Light', goodFor: ['crafts', 'business', 'trading'] },
  { name: 'Chitra', deity: 'Tvashtar', element: 'Mars', nature: 'Soft', goodFor: ['decorating', 'jewelry', 'art'] },
  { name: 'Swati', deity: 'Vayu', element: 'Rahu', nature: 'Movable', goodFor: ['trade', 'travel', 'learning'] },
  { name: 'Vishakha', deity: 'Indra-Agni', element: 'Jupiter', nature: 'Mixed', goodFor: ['marriage', 'ceremonies'] },
  { name: 'Anuradha', deity: 'Mitra', element: 'Saturn', nature: 'Soft', goodFor: ['friendship', 'activities in foreign lands'] },
  { name: 'Jyeshtha', deity: 'Indra', element: 'Mercury', nature: 'Sharp', goodFor: ['administration', 'occult'] },
  { name: 'Mula', deity: 'Nirriti', element: 'Ketu', nature: 'Sharp', goodFor: ['agriculture', 'herbalism'] },
  { name: 'Purva Ashadha', deity: 'Apas', element: 'Venus', nature: 'Fierce', goodFor: ['water activities', 'confrontation'] },
  { name: 'Uttara Ashadha', deity: 'Vishvadevas', element: 'Sun', nature: 'Fixed', goodFor: ['permanent activities', 'property purchase'] },
  { name: 'Shravana', deity: 'Vishnu', element: 'Moon', nature: 'Movable', goodFor: ['learning', 'travel', 'taking medicine'] },
  { name: 'Dhanishta', deity: 'Vasus', element: 'Mars', nature: 'Movable', goodFor: ['moving', 'ceremonies'] },
  { name: 'Shatabhisha', deity: 'Varuna', element: 'Rahu', nature: 'Movable', goodFor: ['healing', 'aquatic activities'] },
  { name: 'Purva Bhadrapada', deity: 'Aja Ekapada', element: 'Jupiter', nature: 'Fierce', goodFor: ['agriculture', 'dealing with fire'] },
  { name: 'Uttara Bhadrapada', deity: 'Ahir Budhnya', element: 'Saturn', nature: 'Fixed', goodFor: ['marriage', 'property', 'spiritual activities'] },
  { name: 'Revati', deity: 'Pushan', element: 'Mercury', nature: 'Soft', goodFor: ['travel', 'dealing with animals', 'healing'] },
];

const TITHIS = [
  { name: 'Pratipada', paksha: 'Shukla', deity: 'Agni', nature: 'Nanda', goodFor: ['beginning tasks'] },
  { name: 'Dwitiya', paksha: 'Shukla', deity: 'Brahma', nature: 'Bhadra', goodFor: ['laying foundation', 'building'] },
  { name: 'Tritiya', paksha: 'Shukla', deity: 'Gauri', nature: 'Jaya', goodFor: ['all auspicious works'] },
  { name: 'Chaturthi', paksha: 'Shukla', deity: 'Yama/Ganesha', nature: 'Rikta', goodFor: ['cruel actions'] },
  { name: 'Panchami', paksha: 'Shukla', deity: 'Nagas', nature: 'Purna', goodFor: ['medicine', 'good deeds'] },
  { name: 'Shashthi', paksha: 'Shukla', deity: 'Kartikeya', nature: 'Nanda', goodFor: ['coronation', 'favorable activities'] },
  { name: 'Saptami', paksha: 'Shukla', deity: 'Surya', nature: 'Bhadra', goodFor: ['travel', 'vehicles'] },
  { name: 'Ashtami', paksha: 'Shukla', deity: 'Rudra', nature: 'Jaya', goodFor: ['warfare'] },
  { name: 'Navami', paksha: 'Shukla', deity: 'Durga', nature: 'Rikta', goodFor: ['destroying enemies'] },
  { name: 'Dashami', paksha: 'Shukla', deity: 'Dharma', nature: 'Purna', goodFor: ['all auspicious', 'griha pravesh'] },
  { name: 'Ekadashi', paksha: 'Shukla', deity: 'Vishvadeva', nature: 'Nanda', goodFor: ['fasting', 'spiritual'] },
  { name: 'Dwadashi', paksha: 'Shukla', deity: 'Vishnu', nature: 'Bhadra', goodFor: ['religious ceremonies'] },
  { name: 'Trayodashi', paksha: 'Shukla', deity: 'Kamadeva', nature: 'Jaya', goodFor: ['friendship', 'pleasure'] },
  { name: 'Chaturdashi', paksha: 'Shukla', deity: 'Rudra', nature: 'Rikta', goodFor: ['administering poison'] },
  { name: 'Purnima', paksha: 'Shukla', deity: 'Soma', nature: 'Purna', goodFor: ['all auspicious', 'property purchase'] },
];

const YOGAS = [
  { name: 'Vishkumbha', nature: 'Inauspicious', description: 'Obstacles in work' },
  { name: 'Priti', nature: 'Auspicious', description: 'Love and affection' },
  { name: 'Ayushman', nature: 'Auspicious', description: 'Long life, good health' },
  { name: 'Saubhagya', nature: 'Very Auspicious', description: 'Good fortune' },
  { name: 'Shobhana', nature: 'Auspicious', description: 'Splendor, beauty' },
  { name: 'Atiganda', nature: 'Inauspicious', description: 'Danger' },
  { name: 'Sukarma', nature: 'Very Auspicious', description: 'Good deeds succeed' },
  { name: 'Dhriti', nature: 'Auspicious', description: 'Determination, steadiness' },
  { name: 'Shula', nature: 'Inauspicious', description: 'Pain, suffering' },
  { name: 'Ganda', nature: 'Inauspicious', description: 'Danger, obstacles' },
  { name: 'Vriddhi', nature: 'Very Auspicious', description: 'Growth, prosperity' },
  { name: 'Dhruva', nature: 'Auspicious', description: 'Permanence, stability' },
  { name: 'Vyaghata', nature: 'Inauspicious', description: 'Destruction' },
  { name: 'Harshana', nature: 'Auspicious', description: 'Joy, happiness' },
  { name: 'Vajra', nature: 'Mixed', description: 'Hard, diamond-like' },
  { name: 'Siddhi', nature: 'Very Auspicious', description: 'Success, accomplishment' },
  { name: 'Vyatipata', nature: 'Very Inauspicious', description: 'Calamity' },
  { name: 'Variyan', nature: 'Auspicious', description: 'Excellence' },
  { name: 'Parigha', nature: 'Inauspicious', description: 'Obstruction' },
  { name: 'Shiva', nature: 'Very Auspicious', description: 'Auspiciousness' },
  { name: 'Siddha', nature: 'Very Auspicious', description: 'Perfection' },
  { name: 'Sadhya', nature: 'Auspicious', description: 'Accomplishment' },
  { name: 'Shubha', nature: 'Very Auspicious', description: 'Auspiciousness' },
  { name: 'Shukla', nature: 'Auspicious', description: 'Brightness, purity' },
  { name: 'Brahma', nature: 'Auspicious', description: 'Divine knowledge' },
  { name: 'Indra', nature: 'Very Auspicious', description: 'Power, authority' },
  { name: 'Vaidhriti', nature: 'Very Inauspicious', description: 'Bad luck' },
];

// Event-specific Muhurat requirements
const MUHURAT_REQUIREMENTS: Record<string, any> = {
  PROPERTY_VIEWING: {
    preferredNakshatras: ['Rohini', 'Mrigashira', 'Pushya', 'Uttara Phalguni', 'Hasta', 'Swati', 'Anuradha', 'Uttara Ashadha', 'Shravana', 'Uttara Bhadrapada', 'Revati'],
    avoidNakshatras: ['Bharani', 'Krittika', 'Ardra', 'Ashlesha', 'Magha', 'Jyeshtha', 'Mula'],
    preferredTithis: ['Dwitiya', 'Tritiya', 'Panchami', 'Saptami', 'Dashami', 'Dwadashi', 'Trayodashi'],
    avoidTithis: ['Chaturthi', 'Navami', 'Chaturdashi', 'Amavasya'],
    preferredWeekdays: [1, 2, 3, 4, 5], // Mon-Fri
    avoidWeekdays: [6], // Saturday
  },
  GRIHA_PRAVESH: {
    preferredNakshatras: ['Rohini', 'Mrigashira', 'Punarvasu', 'Pushya', 'Uttara Phalguni', 'Hasta', 'Swati', 'Anuradha', 'Uttara Ashadha', 'Shravana', 'Dhanishta', 'Uttara Bhadrapada', 'Revati'],
    avoidNakshatras: ['Bharani', 'Krittika', 'Ardra', 'Ashlesha', 'Magha', 'Pubba', 'Vishakha', 'Jyeshtha', 'Mula', 'Purva Ashadha', 'Purva Bhadrapada'],
    preferredTithis: ['Dwitiya', 'Tritiya', 'Panchami', 'Saptami', 'Dashami', 'Ekadashi', 'Dwadashi', 'Trayodashi', 'Purnima'],
    avoidTithis: ['Pratipada', 'Chaturthi', 'Shashthi', 'Ashtami', 'Navami', 'Chaturdashi', 'Amavasya'],
    preferredWeekdays: [1, 3, 4, 5], // Mon, Wed, Thu, Fri
    avoidWeekdays: [2, 6], // Tue, Sat
    requiresLagna: true,
    preferredLagnas: ['Taurus', 'Cancer', 'Leo', 'Virgo', 'Sagittarius', 'Aquarius', 'Pisces'],
  },
  CLOSING: {
    preferredNakshatras: ['Rohini', 'Pushya', 'Uttara Phalguni', 'Hasta', 'Anuradha', 'Uttara Ashadha', 'Shravana', 'Uttara Bhadrapada'],
    avoidNakshatras: ['Bharani', 'Ardra', 'Ashlesha', 'Jyeshtha', 'Mula'],
    preferredTithis: ['Dwitiya', 'Tritiya', 'Panchami', 'Saptami', 'Dashami', 'Dwadashi', 'Purnima'],
    avoidTithis: ['Chaturthi', 'Ashtami', 'Navami', 'Chaturdashi', 'Amavasya'],
    preferredWeekdays: [1, 3, 4, 5],
    avoidWeekdays: [2, 6],
  },
  BHOOMI_PUJA: {
    preferredNakshatras: ['Rohini', 'Mrigashira', 'Pushya', 'Uttara Phalguni', 'Hasta', 'Chitra', 'Swati', 'Anuradha', 'Uttara Ashadha', 'Shravana', 'Uttara Bhadrapada', 'Revati'],
    avoidNakshatras: ['Bharani', 'Krittika', 'Ardra', 'Ashlesha', 'Magha', 'Jyeshtha', 'Mula'],
    preferredTithis: ['Dwitiya', 'Tritiya', 'Panchami', 'Saptami', 'Dashami', 'Ekadashi', 'Dwadashi', 'Trayodashi', 'Purnima'],
    avoidTithis: ['Pratipada', 'Chaturthi', 'Shashthi', 'Ashtami', 'Navami', 'Chaturdashi', 'Amavasya'],
    preferredWeekdays: [1, 3, 4, 5],
    avoidWeekdays: [2, 6],
  },
};

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

function calculateNakshatra(date: Date): typeof NAKSHATRAS[0] {
  // Simplified calculation - in production, use Swiss Ephemeris
  const dayOfYear = Math.floor((date.getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / (24 * 60 * 60 * 1000));
  const index = (dayOfYear + date.getDate()) % 27;
  return NAKSHATRAS[index];
}

function calculateTithi(date: Date): typeof TITHIS[0] {
  // Simplified calculation based on lunar phase
  const lunarDay = Math.floor((date.getTime() / (24 * 60 * 60 * 1000)) % 30);
  const index = lunarDay % 15;
  return TITHIS[index];
}

function calculateYoga(date: Date): typeof YOGAS[0] {
  // Simplified calculation
  const dayNumber = Math.floor(date.getTime() / (24 * 60 * 60 * 1000));
  const index = dayNumber % 27;
  return YOGAS[index];
}

function calculateRahuKaal(date: Date): { start: string; end: string } {
  const dayOfWeek = date.getDay();
  const rahuKaalTimes: Record<number, { start: string; end: string }> = {
    0: { start: '16:30', end: '18:00' }, // Sunday
    1: { start: '07:30', end: '09:00' }, // Monday
    2: { start: '15:00', end: '16:30' }, // Tuesday
    3: { start: '12:00', end: '13:30' }, // Wednesday
    4: { start: '13:30', end: '15:00' }, // Thursday
    5: { start: '10:30', end: '12:00' }, // Friday
    6: { start: '09:00', end: '10:30' }, // Saturday
  };
  return rahuKaalTimes[dayOfWeek];
}

function calculateLifePathNumber(dateOfBirth: string): number {
  const digits = dateOfBirth.replace(/\D/g, '').split('').map(Number);
  let sum = digits.reduce((a, b) => a + b, 0);
  
  // Reduce to single digit unless master number
  while (sum > 9 && sum !== 11 && sum !== 22 && sum !== 33) {
    sum = sum.toString().split('').map(Number).reduce((a, b) => a + b, 0);
  }
  
  return sum;
}

function calculateMoonSign(dateOfBirth: Date, timeOfBirth?: string): string {
  // Simplified - in production would use ephemeris
  const signs = ['Aries', 'Taurus', 'Gemini', 'Cancer', 'Leo', 'Virgo', 'Libra', 'Scorpio', 'Sagittarius', 'Capricorn', 'Aquarius', 'Pisces'];
  const dayOfYear = Math.floor((dateOfBirth.getTime() - new Date(dateOfBirth.getFullYear(), 0, 0).getTime()) / (24 * 60 * 60 * 1000));
  const index = Math.floor((dayOfYear * 12) / 365) % 12;
  return signs[index];
}

function calculatePropertyCompatibility(buyerDetails: any, propertyDetails: any): any {
  // Calculate compatibility based on various factors
  const compatibility: any = {
    overall: 0,
    factors: [],
  };
  
  // Direction compatibility (based on moon sign)
  const moonSign = calculateMoonSign(new Date(buyerDetails.dateOfBirth));
  const directionCompatibility: Record<string, string[]> = {
    'Aries': ['EAST', 'NORTH'],
    'Taurus': ['SOUTH', 'SOUTH_WEST'],
    'Gemini': ['WEST', 'NORTH_WEST'],
    'Cancer': ['NORTH', 'NORTH_EAST'],
    'Leo': ['EAST', 'SOUTH_EAST'],
    'Virgo': ['SOUTH', 'WEST'],
    'Libra': ['WEST', 'NORTH'],
    'Scorpio': ['NORTH', 'EAST'],
    'Sagittarius': ['EAST', 'SOUTH'],
    'Capricorn': ['SOUTH', 'WEST'],
    'Aquarius': ['WEST', 'NORTH'],
    'Pisces': ['NORTH', 'EAST'],
  };
  
  const favorableDirections = directionCompatibility[moonSign] || ['NORTH_EAST'];
  const entranceMatch = favorableDirections.includes(propertyDetails.entranceDirection);
  
  compatibility.factors.push({
    name: 'Entrance Direction',
    score: entranceMatch ? 100 : 50,
    description: entranceMatch 
      ? `Entrance direction ${propertyDetails.entranceDirection} is favorable for your moon sign ${moonSign}`
      : `Your favorable directions are ${favorableDirections.join(', ')}. Property entrance is ${propertyDetails.entranceDirection}`,
  });
  
  // Numerology compatibility
  const lifePathNumber = calculateLifePathNumber(buyerDetails.dateOfBirth);
  const addressNumber = propertyDetails.address 
    ? propertyDetails.address.split('').filter((c: string) => /\d/.test(c)).reduce((a: number, b: string) => a + parseInt(b), 0) % 9 || 9
    : 1;
  
  const numerologyCompatible = {
    1: [1, 2, 3, 9],
    2: [1, 2, 6],
    3: [1, 3, 6, 9],
    4: [1, 4, 6, 7],
    5: [1, 5, 6, 9],
    6: [2, 3, 4, 5, 6, 9],
    7: [4, 7],
    8: [1, 4, 8],
    9: [1, 3, 5, 6, 9],
  };
  
  const numMatch = (numerologyCompatible[lifePathNumber as keyof typeof numerologyCompatible] || []).includes(addressNumber);
  
  compatibility.factors.push({
    name: 'Numerology',
    score: numMatch ? 90 : 60,
    description: `Your life path number is ${lifePathNumber}. Property number reduces to ${addressNumber}. ${numMatch ? 'Good match!' : 'Neutral compatibility.'}`,
  });
  
  // Vastu score factor
  if (propertyDetails.vastuScore) {
    compatibility.factors.push({
      name: 'Vastu Score',
      score: propertyDetails.vastuScore,
      description: `Property Vastu score: ${propertyDetails.vastuScore}/100`,
    });
  }
  
  // Calculate overall score
  compatibility.overall = Math.round(
    compatibility.factors.reduce((sum: number, f: any) => sum + f.score, 0) / compatibility.factors.length
  );
  
  return compatibility;
}

// ============================================================================
// ROUTES
// ============================================================================

// Generate birth chart (Kundali)
router.post('/birth-chart', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const validated = birthDetailsSchema.parse(req.body);
  const userId = (req as any).user.id;
  
  const dob = new Date(validated.dateOfBirth);
  
  // Calculate astrological details
  const moonSign = calculateMoonSign(dob, validated.timeOfBirth);
  const nakshatra = calculateNakshatra(dob);
  const lifePathNumber = calculateLifePathNumber(validated.dateOfBirth);
  
  // Determine favorable directions based on moon sign
  const directionRecommendations: Record<string, any> = {
    'Aries': { best: ['EAST'], good: ['NORTH', 'NORTH_EAST'], avoid: ['WEST', 'SOUTH_WEST'] },
    'Taurus': { best: ['SOUTH'], good: ['SOUTH_WEST', 'SOUTH_EAST'], avoid: ['NORTH', 'NORTH_WEST'] },
    'Gemini': { best: ['WEST'], good: ['NORTH_WEST', 'NORTH'], avoid: ['SOUTH', 'SOUTH_EAST'] },
    'Cancer': { best: ['NORTH'], good: ['NORTH_EAST', 'EAST'], avoid: ['SOUTH', 'SOUTH_WEST'] },
    'Leo': { best: ['EAST'], good: ['SOUTH_EAST', 'SOUTH'], avoid: ['WEST', 'NORTH_WEST'] },
    'Virgo': { best: ['SOUTH'], good: ['WEST', 'SOUTH_WEST'], avoid: ['NORTH', 'NORTH_EAST'] },
    'Libra': { best: ['WEST'], good: ['NORTH', 'NORTH_WEST'], avoid: ['EAST', 'SOUTH_EAST'] },
    'Scorpio': { best: ['NORTH'], good: ['EAST', 'NORTH_EAST'], avoid: ['SOUTH', 'SOUTH_WEST'] },
    'Sagittarius': { best: ['EAST'], good: ['SOUTH', 'SOUTH_EAST'], avoid: ['WEST', 'NORTH_WEST'] },
    'Capricorn': { best: ['SOUTH'], good: ['WEST', 'SOUTH_WEST'], avoid: ['NORTH', 'NORTH_EAST'] },
    'Aquarius': { best: ['WEST'], good: ['NORTH', 'NORTH_WEST'], avoid: ['EAST', 'SOUTH_EAST'] },
    'Pisces': { best: ['NORTH'], good: ['EAST', 'NORTH_EAST'], avoid: ['SOUTH', 'SOUTH_WEST'] },
  };
  
  const directions = directionRecommendations[moonSign];
  
  // Store birth details for user if not already stored
  await prisma.user.update({
    where: { id: userId },
    data: {
      dateOfBirth: dob,
      birthTime: validated.timeOfBirth,
      birthPlace: validated.placeOfBirth.city,
      lifePathNumber,
    },
  });
  
  const birthChart = {
    birthDetails: validated,
    moonSign,
    nakshatra: nakshatra.name,
    nakshatraDetails: nakshatra,
    lifePathNumber,
    favorableDirections: directions,
    propertyRecommendations: {
      idealEntrances: directions.best,
      goodEntrances: directions.good,
      avoidEntrances: directions.avoid,
      bestPropertyTypes: moonSign === 'Cancer' ? ['HOUSE', 'VILLA'] : ['CONDO', 'APARTMENT'],
      elementBalance: nakshatra.element,
    },
    generalGuidance: `As a ${moonSign} moon sign born in ${nakshatra.name} nakshatra, properties with entrances facing ${directions.best.join(' or ')} will be most beneficial for you. Your life path number ${lifePathNumber} suggests affinity with properties whose address numbers reduce to compatible numbers.`,
  };
  
  res.json({
    success: true,
    data: { birthChart },
  });
}));

// Get auspicious dates for property activities
router.post('/auspicious-dates', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const validated = auspiciousDatesSchema.parse(req.body);
  
  const startDate = new Date(validated.startDate);
  const endDate = new Date(validated.endDate);
  const eventType = validated.eventType;
  
  const requirements = MUHURAT_REQUIREMENTS[eventType] || MUHURAT_REQUIREMENTS['PROPERTY_VIEWING'];
  
  const auspiciousDates: any[] = [];
  let currentDate = new Date(startDate);
  
  while (currentDate <= endDate) {
    const dayOfWeek = currentDate.getDay();
    const nakshatra = calculateNakshatra(currentDate);
    const tithi = calculateTithi(currentDate);
    const yoga = calculateYoga(currentDate);
    const rahuKaal = calculateRahuKaal(currentDate);
    
    // Check if day is suitable
    const isWeekdayGood = !requirements.avoidWeekdays?.includes(dayOfWeek);
    const isNakshatraGood = requirements.preferredNakshatras?.includes(nakshatra.name) || !requirements.avoidNakshatras?.includes(nakshatra.name);
    const isTithiGood = requirements.preferredTithis?.includes(tithi.name) || !requirements.avoidTithis?.includes(tithi.name);
    const isYogaGood = yoga.nature !== 'Very Inauspicious' && yoga.nature !== 'Inauspicious';
    
    // Calculate overall auspiciousness score
    let score = 50; // Base score
    if (requirements.preferredWeekdays?.includes(dayOfWeek)) score += 10;
    if (requirements.avoidWeekdays?.includes(dayOfWeek)) score -= 30;
    if (requirements.preferredNakshatras?.includes(nakshatra.name)) score += 20;
    if (requirements.avoidNakshatras?.includes(nakshatra.name)) score -= 25;
    if (requirements.preferredTithis?.includes(tithi.name)) score += 15;
    if (requirements.avoidTithis?.includes(tithi.name)) score -= 20;
    if (yoga.nature === 'Very Auspicious') score += 15;
    if (yoga.nature === 'Auspicious') score += 10;
    if (yoga.nature === 'Inauspicious') score -= 15;
    if (yoga.nature === 'Very Inauspicious') score -= 25;
    
    score = Math.max(0, Math.min(100, score));
    
    if (isWeekdayGood && isNakshatraGood && isTithiGood && isYogaGood && score >= 50) {
      // Generate auspicious windows (avoiding Rahu Kaal)
      const windows = [];
      const morningStart = '06:00';
      const morningEnd = rahuKaal.start;
      const afternoonStart = rahuKaal.end;
      const eveningEnd = '18:00';
      
      if (morningStart < morningEnd) {
        windows.push({ start: morningStart, end: morningEnd, quality: 'Good' });
      }
      if (afternoonStart < eveningEnd) {
        windows.push({ start: afternoonStart, end: eveningEnd, quality: 'Excellent' });
      }
      
      auspiciousDates.push({
        date: currentDate.toISOString().split('T')[0],
        dayOfWeek: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][dayOfWeek],
        score,
        quality: score >= 80 ? 'Excellent' : score >= 65 ? 'Good' : 'Fair',
        nakshatra: nakshatra.name,
        tithi: tithi.name,
        yoga: yoga.name,
        rahuKaal,
        windows,
        reasons: [
          `${nakshatra.name} nakshatra is ${requirements.preferredNakshatras?.includes(nakshatra.name) ? 'highly favorable' : 'acceptable'} for ${eventType.toLowerCase().replace(/_/g, ' ')}`,
          `${tithi.name} tithi has ${tithi.nature} nature`,
          `${yoga.name} yoga is ${yoga.nature.toLowerCase()}`,
        ],
      });
    }
    
    currentDate.setDate(currentDate.getDate() + 1);
  }
  
  // Sort by score
  auspiciousDates.sort((a, b) => b.score - a.score);
  
  // Get event-specific guidance
  const eventGuidance: Record<string, string> = {
    PROPERTY_VIEWING: 'For property viewings, mornings are generally more auspicious. Avoid viewing during Rahu Kaal as perceptions may be clouded.',
    MAKING_OFFER: 'Making offers during auspicious times increases the likelihood of acceptance. Thursday and Friday are particularly favorable for negotiations.',
    SIGNING_CONTRACT: 'Contract signing should be done during stable nakshatras like Rohini or Uttara Phalguni. Avoid eclipses and Amavasya.',
    CLOSING: 'Closing on fixed nakshatras ensures permanence and stability in the transaction. Pushya nakshatra is considered most auspicious.',
    GRIHA_PRAVESH: 'Griha Pravesh (house warming) should be performed during Shubh Muhurat. The ceremony should begin during Brahma Muhurat or shortly after sunrise.',
    RENOVATION_START: 'Begin renovations during Rohini, Mrigashira, or Uttara Phalguni nakshatra. Avoid starting during inauspicious tithis.',
    BHOOMI_PUJA: 'Bhoomi Puja for new construction should be performed on Pushya, Rohini, or Uttara Bhadrapada nakshatra.',
    MOVING_IN: 'Moving should be completed during daytime hours on auspicious days. Bring water and rice into the new home first.',
  };
  
  res.json({
    success: true,
    data: {
      eventType,
      dateRange: { start: validated.startDate, end: validated.endDate },
      auspiciousDates: auspiciousDates.slice(0, 10), // Top 10
      totalFound: auspiciousDates.length,
      guidance: eventGuidance[eventType],
      generalTips: [
        'Avoid Rahu Kaal for important activities',
        'Prefer Shukla Paksha (waxing moon) over Krishna Paksha',
        'Check for any eclipses during the period',
        'Consider your personal birth chart for additional refinement',
      ],
    },
  });
}));

// Calculate Muhurat for specific date
router.post('/muhurat', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const validated = muhuratSchema.parse(req.body);
  const date = new Date(validated.date);
  
  const nakshatra = calculateNakshatra(date);
  const tithi = calculateTithi(date);
  const yoga = calculateYoga(date);
  const rahuKaal = calculateRahuKaal(date);
  const dayOfWeek = date.getDay();
  
  const requirements = MUHURAT_REQUIREMENTS[validated.eventType] || MUHURAT_REQUIREMENTS['PROPERTY_VIEWING'];
  
  // Calculate detailed muhurat windows
  const muhuratWindows = [];
  
  // Brahma Muhurat (1.5 hours before sunrise, ~4:30-6:00 AM)
  muhuratWindows.push({
    name: 'Brahma Muhurat',
    start: '04:30',
    end: '06:00',
    quality: 'Most Auspicious',
    description: 'Best time for spiritual activities and important beginnings',
  });
  
  // Abhijit Muhurat (around noon, 48 minutes)
  muhuratWindows.push({
    name: 'Abhijit Muhurat',
    start: '11:45',
    end: '12:33',
    quality: 'Highly Auspicious',
    description: 'Overcomes all doshas, universally auspicious',
  });
  
  // Exclude Rahu Kaal
  const goodPeriods = [];
  const dayStart = 6;
  const dayEnd = 18;
  const rahuStart = parseInt(rahuKaal.start.split(':')[0]);
  const rahuEnd = parseInt(rahuKaal.end.split(':')[0]);
  
  if (dayStart < rahuStart) {
    goodPeriods.push({
      start: `0${dayStart}:00`,
      end: rahuKaal.start,
      quality: 'Good',
    });
  }
  if (rahuEnd < dayEnd) {
    goodPeriods.push({
      start: rahuKaal.end,
      end: `${dayEnd}:00`,
      quality: 'Good',
    });
  }
  
  // Calculate overall suitability
  let overallScore = 50;
  const issues: string[] = [];
  const positives: string[] = [];
  
  if (requirements.preferredWeekdays?.includes(dayOfWeek)) {
    overallScore += 10;
    positives.push(`${['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][dayOfWeek]} is favorable`);
  }
  if (requirements.avoidWeekdays?.includes(dayOfWeek)) {
    overallScore -= 20;
    issues.push(`${['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][dayOfWeek]} is not recommended`);
  }
  
  if (requirements.preferredNakshatras?.includes(nakshatra.name)) {
    overallScore += 20;
    positives.push(`${nakshatra.name} nakshatra is highly favorable`);
  }
  if (requirements.avoidNakshatras?.includes(nakshatra.name)) {
    overallScore -= 25;
    issues.push(`${nakshatra.name} nakshatra should be avoided`);
  }
  
  if (requirements.preferredTithis?.includes(tithi.name)) {
    overallScore += 15;
    positives.push(`${tithi.name} tithi is auspicious`);
  }
  if (requirements.avoidTithis?.includes(tithi.name)) {
    overallScore -= 20;
    issues.push(`${tithi.name} tithi is inauspicious`);
  }
  
  if (yoga.nature.includes('Auspicious')) {
    overallScore += yoga.nature === 'Very Auspicious' ? 15 : 10;
    positives.push(`${yoga.name} yoga is ${yoga.nature.toLowerCase()}`);
  }
  if (yoga.nature.includes('Inauspicious')) {
    overallScore -= yoga.nature === 'Very Inauspicious' ? 20 : 10;
    issues.push(`${yoga.name} yoga is ${yoga.nature.toLowerCase()}`);
  }
  
  overallScore = Math.max(0, Math.min(100, overallScore));
  
  const verdict = overallScore >= 75 ? 'Highly Recommended' : overallScore >= 60 ? 'Favorable' : overallScore >= 45 ? 'Neutral' : 'Not Recommended';
  
  res.json({
    success: true,
    data: {
      date: validated.date,
      eventType: validated.eventType,
      panchang: {
        nakshatra: { name: nakshatra.name, deity: nakshatra.deity, nature: nakshatra.nature },
        tithi: { name: tithi.name, paksha: tithi.paksha, nature: tithi.nature },
        yoga: { name: yoga.name, nature: yoga.nature },
        karana: 'Bava', // Simplified
        vara: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][dayOfWeek],
      },
      rahuKaal,
      specialMuhurats: muhuratWindows,
      auspiciousWindows: goodPeriods,
      analysis: {
        overallScore,
        verdict,
        positives,
        issues,
      },
      recommendation: overallScore >= 60 
        ? `This date is ${verdict.toLowerCase()} for ${validated.eventType.toLowerCase().replace(/_/g, ' ')}. Best times are ${goodPeriods.map(p => `${p.start}-${p.end}`).join(' or ')}.`
        : `Consider choosing a different date for ${validated.eventType.toLowerCase().replace(/_/g, ' ')}. Check our auspicious dates API for better alternatives.`,
    },
  });
}));

// Property-buyer compatibility analysis
router.post('/property-match', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const validated = propertyMatchSchema.parse(req.body);
  
  // Get property details
  const property = await prisma.property.findUnique({
    where: { id: validated.propertyId },
    include: {
      vastuAnalysis: true,
    },
  });
  
  if (!property) {
    throw new NotFoundError('Property not found');
  }
  
  const propertyDetails = {
    address: property.address,
    entranceDirection: property.vastuAnalysis?.entranceDirection || 'NORTH_EAST',
    vastuScore: property.vastuAnalysis?.overallScore || 70,
    yearBuilt: property.yearBuilt,
    constructionDate: property.constructionDate,
  };
  
  const compatibility = calculatePropertyCompatibility(validated.buyerBirthDetails, propertyDetails);
  
  // Add construction date compatibility if available
  if (property.constructionDate) {
    const constructionNakshatra = calculateNakshatra(new Date(property.constructionDate));
    const buyerNakshatra = calculateNakshatra(new Date(validated.buyerBirthDetails.dateOfBirth));
    
    // Check nakshatra compatibility (simplified)
    const nakshatraMatch = constructionNakshatra.element === buyerNakshatra.element;
    
    compatibility.factors.push({
      name: 'Construction Nakshatra',
      score: nakshatraMatch ? 85 : 65,
      description: `Property was constructed during ${constructionNakshatra.name} nakshatra. ${nakshatraMatch ? 'Compatible with your birth nakshatra!' : 'Neutral compatibility.'}`,
    });
    
    // Recalculate overall
    compatibility.overall = Math.round(
      compatibility.factors.reduce((sum: number, f: any) => sum + f.score, 0) / compatibility.factors.length
    );
  }
  
  // Generate recommendation
  const recommendation = compatibility.overall >= 80 
    ? 'Excellent Match! This property aligns well with your astrological profile.'
    : compatibility.overall >= 65 
    ? 'Good Match. This property is compatible with minor considerations.'
    : compatibility.overall >= 50 
    ? 'Moderate Match. Consider the suggested remedies to enhance harmony.'
    : 'Consider Other Options. Look for properties with more favorable alignments.';
  
  res.json({
    success: true,
    data: {
      propertyId: validated.propertyId,
      propertyTitle: property.title,
      buyerMoonSign: calculateMoonSign(new Date(validated.buyerBirthDetails.dateOfBirth)),
      buyerNakshatra: calculateNakshatra(new Date(validated.buyerBirthDetails.dateOfBirth)).name,
      compatibility,
      recommendation,
      remedies: compatibility.overall < 70 ? [
        'Place a Vastu pyramid near the entrance',
        'Keep a copper pot filled with water in the North-East',
        'Light a diya (lamp) during evening hours',
        'Chant Vastu Shanti mantras before moving in',
      ] : [],
    },
  });
}));

export default router;
















Uploads · TS
import { Router, Request, Response } from 'express';
import { z } from 'zod';
import { PrismaClient } from '@prisma/client';
import { S3Client, PutObjectCommand, DeleteObjectCommand, GetObjectCommand } from '@aws-sdk/client-s3';
import { getSignedUrl } from '@aws-sdk/s3-request-presigner';
import multer from 'multer';
import sharp from 'sharp';
import { v4 as uuidv4 } from 'uuid';
import path from 'path';
import { authenticate, optionalAuthenticate } from '../middleware/auth';
import { asyncHandler } from '../utils/asyncHandler';
import { redis } from '../utils/redis';

const router = Router();
const prisma = new PrismaClient();

// S3 Configuration
const s3Client = new S3Client({
  region: process.env.AWS_REGION || 'us-east-1',
  credentials: {
    accessKeyId: process.env.AWS_ACCESS_KEY_ID!,
    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY!,
  },
});

const BUCKET_NAME = process.env.S3_BUCKET_NAME || 'dharma-realty-uploads';
const CDN_URL = process.env.CDN_URL || `https://${BUCKET_NAME}.s3.amazonaws.com`;

// Multer configuration for memory storage
const storage = multer.memoryStorage();

const fileFilter = (req: Request, file: Express.Multer.File, cb: multer.FileFilterCallback) => {
  const allowedImageTypes = ['image/jpeg', 'image/png', 'image/webp', 'image/heic'];
  const allowedDocTypes = ['application/pdf', 'application/msword', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'];
  const allowedTypes = [...allowedImageTypes, ...allowedDocTypes];
  
  if (allowedTypes.includes(file.mimetype)) {
    cb(null, true);
  } else {
    cb(new Error(`File type ${file.mimetype} not allowed`));
  }
};

const upload = multer({
  storage,
  fileFilter,
  limits: {
    fileSize: 50 * 1024 * 1024, // 50MB max
  },
});

// Image processing configurations
const IMAGE_SIZES = {
  thumbnail: { width: 150, height: 150 },
  small: { width: 400, height: 300 },
  medium: { width: 800, height: 600 },
  large: { width: 1200, height: 900 },
  original: null,
};

// Upload types and their S3 paths
const UPLOAD_PATHS = {
  PROPERTY_PHOTO: 'properties/photos',
  PROPERTY_FLOORPLAN: 'properties/floorplans',
  PROPERTY_DOCUMENT: 'properties/documents',
  PROPERTY_3D_TOUR: 'properties/3d-tours',
  AGENT_PHOTO: 'agents/photos',
  AGENT_DOCUMENT: 'agents/documents',
  USER_AVATAR: 'users/avatars',
  VASTU_DIAGRAM: 'vastu/diagrams',
  MESSAGE_ATTACHMENT: 'messages/attachments',
  INSPECTION_REPORT: 'inspections/reports',
  TRANSACTION_DOCUMENT: 'transactions/documents',
};

// ============================================
// PROPERTY PHOTO UPLOADS
// ============================================

// Upload property photos (multiple)
router.post('/properties/:propertyId/photos', authenticate, upload.array('photos', 20), asyncHandler(async (req: Request, res: Response) => {
  const { propertyId } = req.params;
  const userId = req.user!.id;
  const files = req.files as Express.Multer.File[];
  
  if (!files || files.length === 0) {
    return res.status(400).json({ error: 'No files uploaded' });
  }

  // Verify property ownership
  const property = await prisma.property.findFirst({
    where: {
      id: propertyId,
      OR: [
        { ownerId: userId },
        { agentId: userId },
      ],
    },
    include: { photos: true },
  });

  if (!property) {
    return res.status(404).json({ error: 'Property not found or unauthorized' });
  }

  // Check photo limit (max 50 per property)
  if (property.photos.length + files.length > 50) {
    return res.status(400).json({ 
      error: 'Photo limit exceeded',
      current: property.photos.length,
      max: 50,
      trying: files.length,
    });
  }

  const uploadedPhotos = [];

  for (const file of files) {
    const photoId = uuidv4();
    const basePath = `${UPLOAD_PATHS.PROPERTY_PHOTO}/${propertyId}/${photoId}`;
    const urls: Record<string, string> = {};

    // Process and upload different sizes
    for (const [sizeName, dimensions] of Object.entries(IMAGE_SIZES)) {
      let processedBuffer: Buffer;
      
      if (dimensions) {
        processedBuffer = await sharp(file.buffer)
          .resize(dimensions.width, dimensions.height, { fit: 'cover' })
          .jpeg({ quality: 85 })
          .toBuffer();
      } else {
        // Original - just optimize
        processedBuffer = await sharp(file.buffer)
          .jpeg({ quality: 90 })
          .toBuffer();
      }

      const key = `${basePath}/${sizeName}.jpg`;
      
      await s3Client.send(new PutObjectCommand({
        Bucket: BUCKET_NAME,
        Key: key,
        Body: processedBuffer,
        ContentType: 'image/jpeg',
        CacheControl: 'max-age=31536000',
        Metadata: {
          propertyId,
          uploadedBy: userId,
          originalName: file.originalname,
        },
      }));

      urls[sizeName] = `${CDN_URL}/${key}`;
    }

    // Extract image metadata
    const metadata = await sharp(file.buffer).metadata();

    // Save to database
    const photo = await prisma.propertyPhoto.create({
      data: {
        propertyId,
        url: urls.large,
        thumbnailUrl: urls.thumbnail,
        caption: '',
        isPrimary: property.photos.length === 0 && uploadedPhotos.length === 0,
        order: property.photos.length + uploadedPhotos.length,
        width: metadata.width,
        height: metadata.height,
        size: file.size,
        mimeType: 'image/jpeg',
        s3Key: `${basePath}/original.jpg`,
        variants: urls,
      },
    });

    uploadedPhotos.push(photo);
  }

  // Invalidate cache
  await redis.del(`property:${propertyId}:photos`);

  res.status(201).json({
    message: `${uploadedPhotos.length} photos uploaded successfully`,
    photos: uploadedPhotos,
  });
}));

// Get property photos
router.get('/properties/:propertyId/photos', asyncHandler(async (req: Request, res: Response) => {
  const { propertyId } = req.params;

  // Check cache
  const cached = await redis.get(`property:${propertyId}:photos`);
  if (cached) {
    return res.json(JSON.parse(cached));
  }

  const photos = await prisma.propertyPhoto.findMany({
    where: { propertyId },
    orderBy: [
      { isPrimary: 'desc' },
      { order: 'asc' },
    ],
  });

  await redis.setex(`property:${propertyId}:photos`, 3600, JSON.stringify(photos));

  res.json(photos);
}));

// Update photo metadata
router.put('/photos/:photoId', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const { photoId } = req.params;
  const userId = req.user!.id;

  const updateSchema = z.object({
    caption: z.string().max(500).optional(),
    altText: z.string().max(200).optional(),
    isPrimary: z.boolean().optional(),
    order: z.number().int().min(0).optional(),
    room: z.string().optional(),
    tags: z.array(z.string()).optional(),
  });

  const data = updateSchema.parse(req.body);

  // Verify ownership
  const photo = await prisma.propertyPhoto.findUnique({
    where: { id: photoId },
    include: {
      property: true,
    },
  });

  if (!photo) {
    return res.status(404).json({ error: 'Photo not found' });
  }

  if (photo.property.ownerId !== userId && photo.property.agentId !== userId) {
    return res.status(403).json({ error: 'Not authorized' });
  }

  // If setting as primary, unset others
  if (data.isPrimary) {
    await prisma.propertyPhoto.updateMany({
      where: { propertyId: photo.propertyId, isPrimary: true },
      data: { isPrimary: false },
    });
  }

  const updated = await prisma.propertyPhoto.update({
    where: { id: photoId },
    data,
  });

  await redis.del(`property:${photo.propertyId}:photos`);

  res.json(updated);
}));

// Reorder photos
router.put('/properties/:propertyId/photos/reorder', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const { propertyId } = req.params;
  const userId = req.user!.id;

  const reorderSchema = z.object({
    photoIds: z.array(z.string()),
  });

  const { photoIds } = reorderSchema.parse(req.body);

  // Verify ownership
  const property = await prisma.property.findFirst({
    where: {
      id: propertyId,
      OR: [{ ownerId: userId }, { agentId: userId }],
    },
  });

  if (!property) {
    return res.status(404).json({ error: 'Property not found or unauthorized' });
  }

  // Update order
  await Promise.all(
    photoIds.map((photoId, index) =>
      prisma.propertyPhoto.update({
        where: { id: photoId },
        data: { order: index },
      })
    )
  );

  await redis.del(`property:${propertyId}:photos`);

  res.json({ message: 'Photos reordered successfully' });
}));

// Delete photo
router.delete('/photos/:photoId', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const { photoId } = req.params;
  const userId = req.user!.id;

  const photo = await prisma.propertyPhoto.findUnique({
    where: { id: photoId },
    include: { property: true },
  });

  if (!photo) {
    return res.status(404).json({ error: 'Photo not found' });
  }

  if (photo.property.ownerId !== userId && photo.property.agentId !== userId) {
    return res.status(403).json({ error: 'Not authorized' });
  }

  // Delete from S3 (all variants)
  if (photo.variants) {
    const variants = photo.variants as Record<string, string>;
    for (const url of Object.values(variants)) {
      const key = url.replace(`${CDN_URL}/`, '');
      try {
        await s3Client.send(new DeleteObjectCommand({
          Bucket: BUCKET_NAME,
          Key: key,
        }));
      } catch (err) {
        console.error(`Failed to delete S3 object: ${key}`, err);
      }
    }
  }

  // Delete from database
  await prisma.propertyPhoto.delete({ where: { id: photoId } });

  // If was primary, set next photo as primary
  if (photo.isPrimary) {
    const nextPhoto = await prisma.propertyPhoto.findFirst({
      where: { propertyId: photo.propertyId },
      orderBy: { order: 'asc' },
    });
    if (nextPhoto) {
      await prisma.propertyPhoto.update({
        where: { id: nextPhoto.id },
        data: { isPrimary: true },
      });
    }
  }

  await redis.del(`property:${photo.propertyId}:photos`);

  res.json({ message: 'Photo deleted successfully' });
}));

// ============================================
// FLOOR PLAN UPLOADS
// ============================================

router.post('/properties/:propertyId/floorplan', authenticate, upload.single('floorplan'), asyncHandler(async (req: Request, res: Response) => {
  const { propertyId } = req.params;
  const userId = req.user!.id;
  const file = req.file;

  if (!file) {
    return res.status(400).json({ error: 'No file uploaded' });
  }

  // Verify ownership
  const property = await prisma.property.findFirst({
    where: {
      id: propertyId,
      OR: [{ ownerId: userId }, { agentId: userId }],
    },
  });

  if (!property) {
    return res.status(404).json({ error: 'Property not found or unauthorized' });
  }

  const floorplanId = uuidv4();
  const basePath = `${UPLOAD_PATHS.PROPERTY_FLOORPLAN}/${propertyId}`;
  const isImage = file.mimetype.startsWith('image/');

  let key: string;
  let processedBuffer: Buffer = file.buffer;

  if (isImage) {
    // Process as image
    processedBuffer = await sharp(file.buffer)
      .resize(2000, 2000, { fit: 'inside', withoutEnlargement: true })
      .png()
      .toBuffer();
    key = `${basePath}/${floorplanId}.png`;
  } else {
    // Keep as PDF
    key = `${basePath}/${floorplanId}.pdf`;
  }

  await s3Client.send(new PutObjectCommand({
    Bucket: BUCKET_NAME,
    Key: key,
    Body: processedBuffer,
    ContentType: isImage ? 'image/png' : 'application/pdf',
    CacheControl: 'max-age=31536000',
  }));

  const url = `${CDN_URL}/${key}`;

  // Update property with floor plan URL
  const updated = await prisma.property.update({
    where: { id: propertyId },
    data: {
      floorPlanUrl: url,
    },
  });

  res.status(201).json({
    message: 'Floor plan uploaded successfully',
    url,
    property: updated,
  });
}));

// ============================================
// DOCUMENT UPLOADS
// ============================================

// Upload property documents
router.post('/properties/:propertyId/documents', authenticate, upload.single('document'), asyncHandler(async (req: Request, res: Response) => {
  const { propertyId } = req.params;
  const userId = req.user!.id;
  const file = req.file;

  const bodySchema = z.object({
    title: z.string().min(1).max(200),
    type: z.enum(['DEED', 'TITLE', 'SURVEY', 'INSPECTION', 'APPRAISAL', 'TAX', 'HOA', 'DISCLOSURE', 'CONTRACT', 'OTHER']),
    description: z.string().max(1000).optional(),
    isPublic: z.boolean().optional().default(false),
  });

  const data = bodySchema.parse(req.body);

  if (!file) {
    return res.status(400).json({ error: 'No file uploaded' });
  }

  // Verify ownership
  const property = await prisma.property.findFirst({
    where: {
      id: propertyId,
      OR: [{ ownerId: userId }, { agentId: userId }],
    },
  });

  if (!property) {
    return res.status(404).json({ error: 'Property not found or unauthorized' });
  }

  const docId = uuidv4();
  const ext = path.extname(file.originalname) || '.pdf';
  const key = `${UPLOAD_PATHS.PROPERTY_DOCUMENT}/${propertyId}/${docId}${ext}`;

  await s3Client.send(new PutObjectCommand({
    Bucket: BUCKET_NAME,
    Key: key,
    Body: file.buffer,
    ContentType: file.mimetype,
    Metadata: {
      title: data.title,
      type: data.type,
      uploadedBy: userId,
    },
  }));

  const url = `${CDN_URL}/${key}`;

  const document = await prisma.propertyDocument.create({
    data: {
      propertyId,
      title: data.title,
      type: data.type,
      description: data.description,
      url,
      s3Key: key,
      fileName: file.originalname,
      fileSize: file.size,
      mimeType: file.mimetype,
      isPublic: data.isPublic,
      uploadedById: userId,
    },
  });

  res.status(201).json({
    message: 'Document uploaded successfully',
    document,
  });
}));

// Get property documents
router.get('/properties/:propertyId/documents', optionalAuthenticate, asyncHandler(async (req: Request, res: Response) => {
  const { propertyId } = req.params;
  const userId = req.user?.id;

  const property = await prisma.property.findUnique({
    where: { id: propertyId },
  });

  if (!property) {
    return res.status(404).json({ error: 'Property not found' });
  }

  const isOwner = userId && (property.ownerId === userId || property.agentId === userId);

  const documents = await prisma.propertyDocument.findMany({
    where: {
      propertyId,
      ...(isOwner ? {} : { isPublic: true }),
    },
    orderBy: { createdAt: 'desc' },
    include: {
      uploadedBy: {
        select: { id: true, firstName: true, lastName: true },
      },
    },
  });

  res.json(documents);
}));

// Get signed URL for private document access
router.get('/documents/:documentId/download', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const { documentId } = req.params;
  const userId = req.user!.id;

  const document = await prisma.propertyDocument.findUnique({
    where: { id: documentId },
    include: { property: true },
  });

  if (!document) {
    return res.status(404).json({ error: 'Document not found' });
  }

  // Check access
  const isOwner = document.property.ownerId === userId || document.property.agentId === userId;
  if (!document.isPublic && !isOwner) {
    return res.status(403).json({ error: 'Not authorized to access this document' });
  }

  // Generate signed URL (valid for 1 hour)
  const command = new GetObjectCommand({
    Bucket: BUCKET_NAME,
    Key: document.s3Key,
  });

  const signedUrl = await getSignedUrl(s3Client, command, { expiresIn: 3600 });

  res.json({
    url: signedUrl,
    expiresIn: 3600,
    fileName: document.fileName,
  });
}));

// Delete document
router.delete('/documents/:documentId', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const { documentId } = req.params;
  const userId = req.user!.id;

  const document = await prisma.propertyDocument.findUnique({
    where: { id: documentId },
    include: { property: true },
  });

  if (!document) {
    return res.status(404).json({ error: 'Document not found' });
  }

  if (document.property.ownerId !== userId && document.property.agentId !== userId) {
    return res.status(403).json({ error: 'Not authorized' });
  }

  // Delete from S3
  await s3Client.send(new DeleteObjectCommand({
    Bucket: BUCKET_NAME,
    Key: document.s3Key,
  }));

  // Delete from database
  await prisma.propertyDocument.delete({ where: { id: documentId } });

  res.json({ message: 'Document deleted successfully' });
}));

// ============================================
// AGENT UPLOADS
// ============================================

// Upload agent profile photo
router.post('/agents/photo', authenticate, upload.single('photo'), asyncHandler(async (req: Request, res: Response) => {
  const userId = req.user!.id;
  const file = req.file;

  if (!file) {
    return res.status(400).json({ error: 'No file uploaded' });
  }

  const agent = await prisma.agent.findUnique({
    where: { userId },
  });

  if (!agent) {
    return res.status(404).json({ error: 'Agent profile not found' });
  }

  const photoId = uuidv4();
  const basePath = `${UPLOAD_PATHS.AGENT_PHOTO}/${agent.id}`;
  const urls: Record<string, string> = {};

  // Process and upload different sizes
  const agentSizes = {
    thumbnail: { width: 100, height: 100 },
    medium: { width: 300, height: 300 },
    large: { width: 600, height: 600 },
  };

  for (const [sizeName, dimensions] of Object.entries(agentSizes)) {
    const processedBuffer = await sharp(file.buffer)
      .resize(dimensions.width, dimensions.height, { fit: 'cover' })
      .jpeg({ quality: 90 })
      .toBuffer();

    const key = `${basePath}/${photoId}-${sizeName}.jpg`;
    
    await s3Client.send(new PutObjectCommand({
      Bucket: BUCKET_NAME,
      Key: key,
      Body: processedBuffer,
      ContentType: 'image/jpeg',
      CacheControl: 'max-age=31536000',
    }));

    urls[sizeName] = `${CDN_URL}/${key}`;
  }

  // Delete old photos if exists
  if (agent.avatarUrl) {
    const oldKey = agent.avatarUrl.replace(`${CDN_URL}/`, '');
    try {
      await s3Client.send(new DeleteObjectCommand({
        Bucket: BUCKET_NAME,
        Key: oldKey,
      }));
    } catch (err) {
      console.error('Failed to delete old agent photo', err);
    }
  }

  // Update agent
  const updated = await prisma.agent.update({
    where: { id: agent.id },
    data: {
      avatarUrl: urls.large,
    },
  });

  res.json({
    message: 'Profile photo updated successfully',
    urls,
    agent: updated,
  });
}));

// Upload agent certification/license documents
router.post('/agents/certifications', authenticate, upload.single('document'), asyncHandler(async (req: Request, res: Response) => {
  const userId = req.user!.id;
  const file = req.file;

  const bodySchema = z.object({
    type: z.enum(['LICENSE', 'CERTIFICATION', 'VASTU_CERT', 'AWARD', 'DEGREE', 'OTHER']),
    name: z.string().min(1).max(200),
    issuedBy: z.string().max(200).optional(),
    issuedDate: z.string().optional(),
    expiryDate: z.string().optional(),
  });

  const data = bodySchema.parse(req.body);

  if (!file) {
    return res.status(400).json({ error: 'No file uploaded' });
  }

  const agent = await prisma.agent.findUnique({
    where: { userId },
  });

  if (!agent) {
    return res.status(404).json({ error: 'Agent profile not found' });
  }

  const docId = uuidv4();
  const ext = path.extname(file.originalname) || '.pdf';
  const key = `${UPLOAD_PATHS.AGENT_DOCUMENT}/${agent.id}/${docId}${ext}`;

  await s3Client.send(new PutObjectCommand({
    Bucket: BUCKET_NAME,
    Key: key,
    Body: file.buffer,
    ContentType: file.mimetype,
  }));

  const url = `${CDN_URL}/${key}`;

  const certification = await prisma.agentCertification.create({
    data: {
      agentId: agent.id,
      type: data.type,
      name: data.name,
      issuedBy: data.issuedBy,
      issuedDate: data.issuedDate ? new Date(data.issuedDate) : undefined,
      expiryDate: data.expiryDate ? new Date(data.expiryDate) : undefined,
      documentUrl: url,
      s3Key: key,
      verified: false,
    },
  });

  res.status(201).json({
    message: 'Certification uploaded successfully',
    certification,
  });
}));

// ============================================
// USER AVATAR UPLOADS
// ============================================

router.post('/users/avatar', authenticate, upload.single('avatar'), asyncHandler(async (req: Request, res: Response) => {
  const userId = req.user!.id;
  const file = req.file;

  if (!file) {
    return res.status(400).json({ error: 'No file uploaded' });
  }

  const avatarId = uuidv4();
  const key = `${UPLOAD_PATHS.USER_AVATAR}/${userId}/${avatarId}.jpg`;

  const processedBuffer = await sharp(file.buffer)
    .resize(400, 400, { fit: 'cover' })
    .jpeg({ quality: 90 })
    .toBuffer();

  await s3Client.send(new PutObjectCommand({
    Bucket: BUCKET_NAME,
    Key: key,
    Body: processedBuffer,
    ContentType: 'image/jpeg',
    CacheControl: 'max-age=31536000',
  }));

  const url = `${CDN_URL}/${key}`;

  // Delete old avatar if exists
  const user = await prisma.user.findUnique({ where: { id: userId } });
  if (user?.avatarUrl) {
    const oldKey = user.avatarUrl.replace(`${CDN_URL}/`, '');
    try {
      await s3Client.send(new DeleteObjectCommand({
        Bucket: BUCKET_NAME,
        Key: oldKey,
      }));
    } catch (err) {
      console.error('Failed to delete old avatar', err);
    }
  }

  const updated = await prisma.user.update({
    where: { id: userId },
    data: { avatarUrl: url },
    select: {
      id: true,
      email: true,
      firstName: true,
      lastName: true,
      avatarUrl: true,
    },
  });

  res.json({
    message: 'Avatar updated successfully',
    user: updated,
  });
}));

// ============================================
// MESSAGE ATTACHMENT UPLOADS
// ============================================

router.post('/messages/attachments', authenticate, upload.single('attachment'), asyncHandler(async (req: Request, res: Response) => {
  const userId = req.user!.id;
  const file = req.file;

  if (!file) {
    return res.status(400).json({ error: 'No file uploaded' });
  }

  const attachmentId = uuidv4();
  const ext = path.extname(file.originalname);
  const key = `${UPLOAD_PATHS.MESSAGE_ATTACHMENT}/${userId}/${attachmentId}${ext}`;

  let processedBuffer = file.buffer;
  let contentType = file.mimetype;

  // Process images
  if (file.mimetype.startsWith('image/')) {
    processedBuffer = await sharp(file.buffer)
      .resize(1200, 1200, { fit: 'inside', withoutEnlargement: true })
      .jpeg({ quality: 85 })
      .toBuffer();
    contentType = 'image/jpeg';
  }

  await s3Client.send(new PutObjectCommand({
    Bucket: BUCKET_NAME,
    Key: key,
    Body: processedBuffer,
    ContentType: contentType,
    CacheControl: 'max-age=31536000',
  }));

  const url = `${CDN_URL}/${key}`;

  // Generate thumbnail for images
  let thumbnailUrl: string | undefined;
  if (file.mimetype.startsWith('image/')) {
    const thumbnailBuffer = await sharp(file.buffer)
      .resize(200, 200, { fit: 'cover' })
      .jpeg({ quality: 80 })
      .toBuffer();

    const thumbnailKey = `${UPLOAD_PATHS.MESSAGE_ATTACHMENT}/${userId}/${attachmentId}-thumb.jpg`;
    
    await s3Client.send(new PutObjectCommand({
      Bucket: BUCKET_NAME,
      Key: thumbnailKey,
      Body: thumbnailBuffer,
      ContentType: 'image/jpeg',
    }));

    thumbnailUrl = `${CDN_URL}/${thumbnailKey}`;
  }

  res.status(201).json({
    attachmentId,
    url,
    thumbnailUrl,
    fileName: file.originalname,
    fileSize: processedBuffer.length,
    mimeType: contentType,
  });
}));

// ============================================
// VASTU DIAGRAM UPLOADS
// ============================================

router.post('/vastu/:analysisId/diagram', authenticate, upload.single('diagram'), asyncHandler(async (req: Request, res: Response) => {
  const { analysisId } = req.params;
  const userId = req.user!.id;
  const file = req.file;

  if (!file) {
    return res.status(400).json({ error: 'No file uploaded' });
  }

  // Verify ownership
  const analysis = await prisma.vastuAnalysis.findUnique({
    where: { id: analysisId },
    include: { property: true },
  });

  if (!analysis) {
    return res.status(404).json({ error: 'Vastu analysis not found' });
  }

  if (analysis.property.ownerId !== userId && analysis.property.agentId !== userId) {
    return res.status(403).json({ error: 'Not authorized' });
  }

  const diagramId = uuidv4();
  const key = `${UPLOAD_PATHS.VASTU_DIAGRAM}/${analysisId}/${diagramId}.png`;

  const processedBuffer = await sharp(file.buffer)
    .resize(2000, 2000, { fit: 'inside', withoutEnlargement: true })
    .png()
    .toBuffer();

  await s3Client.send(new PutObjectCommand({
    Bucket: BUCKET_NAME,
    Key: key,
    Body: processedBuffer,
    ContentType: 'image/png',
  }));

  const url = `${CDN_URL}/${key}`;

  const updated = await prisma.vastuAnalysis.update({
    where: { id: analysisId },
    data: { floorPlanUrl: url },
  });

  res.json({
    message: 'Vastu diagram uploaded successfully',
    url,
    analysis: updated,
  });
}));

// ============================================
// PRESIGNED URL GENERATION
// ============================================

// Generate presigned URL for direct upload
router.post('/presigned-url', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const userId = req.user!.id;

  const schema = z.object({
    fileName: z.string(),
    fileType: z.string(),
    uploadType: z.enum([
      'PROPERTY_PHOTO',
      'PROPERTY_FLOORPLAN',
      'PROPERTY_DOCUMENT',
      'PROPERTY_3D_TOUR',
      'AGENT_PHOTO',
      'AGENT_DOCUMENT',
      'USER_AVATAR',
      'MESSAGE_ATTACHMENT',
    ]),
    entityId: z.string().optional(), // propertyId or agentId
  });

  const data = schema.parse(req.body);

  const fileId = uuidv4();
  const ext = path.extname(data.fileName);
  const basePath = UPLOAD_PATHS[data.uploadType];
  const entityPath = data.entityId || userId;
  const key = `${basePath}/${entityPath}/${fileId}${ext}`;

  const command = new PutObjectCommand({
    Bucket: BUCKET_NAME,
    Key: key,
    ContentType: data.fileType,
    Metadata: {
      uploadedBy: userId,
      originalName: data.fileName,
    },
  });

  const presignedUrl = await getSignedUrl(s3Client, command, { expiresIn: 3600 });

  res.json({
    presignedUrl,
    key,
    finalUrl: `${CDN_URL}/${key}`,
    expiresIn: 3600,
  });
}));

// ============================================
// BULK OPERATIONS
// ============================================

// Bulk delete photos
router.post('/properties/:propertyId/photos/bulk-delete', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const { propertyId } = req.params;
  const userId = req.user!.id;

  const schema = z.object({
    photoIds: z.array(z.string()).min(1).max(50),
  });

  const { photoIds } = schema.parse(req.body);

  // Verify ownership
  const property = await prisma.property.findFirst({
    where: {
      id: propertyId,
      OR: [{ ownerId: userId }, { agentId: userId }],
    },
  });

  if (!property) {
    return res.status(404).json({ error: 'Property not found or unauthorized' });
  }

  // Get photos to delete
  const photos = await prisma.propertyPhoto.findMany({
    where: {
      id: { in: photoIds },
      propertyId,
    },
  });

  // Delete from S3
  for (const photo of photos) {
    if (photo.variants) {
      const variants = photo.variants as Record<string, string>;
      for (const url of Object.values(variants)) {
        const key = url.replace(`${CDN_URL}/`, '');
        try {
          await s3Client.send(new DeleteObjectCommand({
            Bucket: BUCKET_NAME,
            Key: key,
          }));
        } catch (err) {
          console.error(`Failed to delete: ${key}`, err);
        }
      }
    }
  }

  // Delete from database
  await prisma.propertyPhoto.deleteMany({
    where: {
      id: { in: photoIds },
      propertyId,
    },
  });

  await redis.del(`property:${propertyId}:photos`);

  res.json({
    message: `${photos.length} photos deleted successfully`,
    deletedCount: photos.length,
  });
}));

// ============================================
// STORAGE STATS
// ============================================

router.get('/stats', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const userId = req.user!.id;

  // Get user's storage usage
  const [propertyPhotos, propertyDocs, agentDocs, messageAttachments] = await Promise.all([
    prisma.propertyPhoto.aggregate({
      where: {
        property: {
          OR: [{ ownerId: userId }, { agentId: userId }],
        },
      },
      _sum: { size: true },
      _count: true,
    }),
    prisma.propertyDocument.aggregate({
      where: {
        uploadedById: userId,
      },
      _sum: { fileSize: true },
      _count: true,
    }),
    prisma.agentCertification.aggregate({
      where: {
        agent: { userId },
      },
      _count: true,
    }),
    prisma.message.count({
      where: {
        senderId: userId,
        type: { in: ['IMAGE', 'DOCUMENT', 'VIDEO', 'VOICE'] },
      },
    }),
  ]);

  const totalSize = (propertyPhotos._sum.size || 0) + (propertyDocs._sum.fileSize || 0);
  const storageLimit = 5 * 1024 * 1024 * 1024; // 5GB default limit

  res.json({
    usage: {
      totalBytes: totalSize,
      totalMB: Math.round(totalSize / (1024 * 1024) * 100) / 100,
      limitBytes: storageLimit,
      limitGB: storageLimit / (1024 * 1024 * 1024),
      percentUsed: Math.round((totalSize / storageLimit) * 100 * 100) / 100,
    },
    breakdown: {
      propertyPhotos: {
        count: propertyPhotos._count,
        bytes: propertyPhotos._sum.size || 0,
      },
      propertyDocuments: {
        count: propertyDocs._count,
        bytes: propertyDocs._sum.fileSize || 0,
      },
      agentCertifications: {
        count: agentDocs._count,
      },
      messageAttachments: {
        count: messageAttachments,
      },
    },
  });
}));

export default router;
Subscriptions · TS
import { Router, Request, Response } from 'express';
import { z } from 'zod';
import { PrismaClient } from '@prisma/client';
import Stripe from 'stripe';
import { authenticate } from '../middleware/auth';
import { asyncHandler } from '../utils/asyncHandler';
import { redis } from '../utils/redis';

const router = Router();
const prisma = new PrismaClient();

// Stripe configuration
const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
  apiVersion: '2023-10-16',
});

// Subscription tiers configuration
const SUBSCRIPTION_TIERS = {
  FREE: {
    id: 'free',
    name: 'Starter',
    price: 0,
    priceId: null,
    features: {
      maxListings: 3,
      maxLeads: 10,
      maxPhotosPerListing: 10,
      vastuAnalysis: false,
      climateReports: false,
      aiValuation: false,
      prioritySupport: false,
      featuredListings: 0,
      virtualTours: false,
      apiAccess: false,
      teamMembers: 0,
      customBranding: false,
      analyticsAccess: 'basic',
      leadNotifications: 'daily',
      karmicRewards: false,
    },
  },
  BASIC: {
    id: 'basic',
    name: 'Professional',
    price: 49,
    priceId: process.env.STRIPE_BASIC_PRICE_ID || 'price_basic',
    features: {
      maxListings: 25,
      maxLeads: 100,
      maxPhotosPerListing: 30,
      vastuAnalysis: true,
      climateReports: true,
      aiValuation: false,
      prioritySupport: false,
      featuredListings: 2,
      virtualTours: true,
      apiAccess: false,
      teamMembers: 0,
      customBranding: false,
      analyticsAccess: 'standard',
      leadNotifications: 'instant',
      karmicRewards: true,
    },
  },
  PREMIUM: {
    id: 'premium',
    name: 'Premium',
    price: 149,
    priceId: process.env.STRIPE_PREMIUM_PRICE_ID || 'price_premium',
    features: {
      maxListings: 100,
      maxLeads: 500,
      maxPhotosPerListing: 50,
      vastuAnalysis: true,
      climateReports: true,
      aiValuation: true,
      prioritySupport: true,
      featuredListings: 10,
      virtualTours: true,
      apiAccess: true,
      teamMembers: 3,
      customBranding: true,
      analyticsAccess: 'advanced',
      leadNotifications: 'instant',
      karmicRewards: true,
    },
  },
  ENTERPRISE: {
    id: 'enterprise',
    name: 'Enterprise',
    price: 499,
    priceId: process.env.STRIPE_ENTERPRISE_PRICE_ID || 'price_enterprise',
    features: {
      maxListings: -1, // Unlimited
      maxLeads: -1,
      maxPhotosPerListing: 100,
      vastuAnalysis: true,
      climateReports: true,
      aiValuation: true,
      prioritySupport: true,
      featuredListings: -1,
      virtualTours: true,
      apiAccess: true,
      teamMembers: -1,
      customBranding: true,
      analyticsAccess: 'enterprise',
      leadNotifications: 'instant',
      karmicRewards: true,
      whiteLabel: true,
      dedicatedSupport: true,
      customIntegrations: true,
    },
  },
};

// Add-ons configuration
const ADD_ONS = {
  EXTRA_LISTINGS: {
    id: 'extra_listings',
    name: 'Extra Listings Pack',
    description: '10 additional property listings',
    price: 19,
    priceId: process.env.STRIPE_ADDON_LISTINGS_PRICE_ID || 'price_addon_listings',
    quantity: 10,
    type: 'listings',
  },
  EXTRA_LEADS: {
    id: 'extra_leads',
    name: 'Extra Leads Pack',
    description: '50 additional lead capacity',
    price: 29,
    priceId: process.env.STRIPE_ADDON_LEADS_PRICE_ID || 'price_addon_leads',
    quantity: 50,
    type: 'leads',
  },
  FEATURED_BOOST: {
    id: 'featured_boost',
    name: 'Featured Listing Boost',
    description: 'Feature one listing for 30 days',
    price: 49,
    priceId: process.env.STRIPE_ADDON_FEATURED_PRICE_ID || 'price_addon_featured',
    duration: 30,
    type: 'featured',
  },
  VASTU_CERTIFICATE: {
    id: 'vastu_certificate',
    name: 'Vastu Compliance Certificate',
    description: 'Official Vastu compliance certificate for a property',
    price: 99,
    priceId: process.env.STRIPE_ADDON_VASTU_CERT_PRICE_ID || 'price_addon_vastu',
    type: 'certificate',
  },
  CLIMATE_DEEP_ANALYSIS: {
    id: 'climate_deep_analysis',
    name: 'Deep Climate Analysis',
    description: '100-year climate projection for a property',
    price: 79,
    priceId: process.env.STRIPE_ADDON_CLIMATE_PRICE_ID || 'price_addon_climate',
    type: 'analysis',
  },
  AI_VALUATION: {
    id: 'ai_valuation',
    name: 'AI Property Valuation',
    description: 'Comprehensive AI-powered property valuation',
    price: 149,
    priceId: process.env.STRIPE_ADDON_VALUATION_PRICE_ID || 'price_addon_valuation',
    type: 'valuation',
  },
};

// ============================================
// SUBSCRIPTION PLANS
// ============================================

// Get available plans
router.get('/plans', asyncHandler(async (req: Request, res: Response) => {
  const plans = Object.values(SUBSCRIPTION_TIERS).map(tier => ({
    id: tier.id,
    name: tier.name,
    price: tier.price,
    priceFormatted: tier.price === 0 ? 'Free' : `$${tier.price}/month`,
    features: tier.features,
    popular: tier.id === 'premium',
  }));

  res.json(plans);
}));

// Get add-ons
router.get('/add-ons', asyncHandler(async (req: Request, res: Response) => {
  const addOns = Object.values(ADD_ONS).map(addon => ({
    id: addon.id,
    name: addon.name,
    description: addon.description,
    price: addon.price,
    priceFormatted: `$${addon.price}`,
  }));

  res.json(addOns);
}));

// ============================================
// SUBSCRIPTION MANAGEMENT
// ============================================

// Get current subscription
router.get('/current', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const userId = req.user!.id;

  const agent = await prisma.agent.findUnique({
    where: { userId },
    include: {
      subscription: true,
    },
  });

  if (!agent) {
    return res.status(404).json({ error: 'Agent profile not found' });
  }

  const subscription = agent.subscription;
  const tier = SUBSCRIPTION_TIERS[subscription?.tier || 'FREE'];

  // Get usage stats
  const [listingCount, leadCount] = await Promise.all([
    prisma.property.count({ where: { agentId: userId } }),
    prisma.lead.count({ where: { agentId: agent.id } }),
  ]);

  res.json({
    subscription: subscription ? {
      id: subscription.id,
      tier: subscription.tier,
      status: subscription.status,
      currentPeriodStart: subscription.currentPeriodStart,
      currentPeriodEnd: subscription.currentPeriodEnd,
      cancelAtPeriodEnd: subscription.cancelAtPeriodEnd,
      stripeSubscriptionId: subscription.stripeSubscriptionId,
    } : null,
    plan: {
      name: tier.name,
      price: tier.price,
      features: tier.features,
    },
    usage: {
      listings: {
        used: listingCount,
        limit: tier.features.maxListings,
        percentage: tier.features.maxListings > 0 
          ? Math.round((listingCount / tier.features.maxListings) * 100)
          : 0,
      },
      leads: {
        used: leadCount,
        limit: tier.features.maxLeads,
        percentage: tier.features.maxLeads > 0
          ? Math.round((leadCount / tier.features.maxLeads) * 100)
          : 0,
      },
    },
  });
}));

// Create checkout session for new subscription
router.post('/checkout', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const userId = req.user!.id;

  const schema = z.object({
    planId: z.enum(['basic', 'premium', 'enterprise']),
    successUrl: z.string().url(),
    cancelUrl: z.string().url(),
  });

  const { planId, successUrl, cancelUrl } = schema.parse(req.body);

  const user = await prisma.user.findUnique({
    where: { id: userId },
    include: {
      agent: {
        include: { subscription: true },
      },
    },
  });

  if (!user) {
    return res.status(404).json({ error: 'User not found' });
  }

  if (!user.agent) {
    return res.status(400).json({ error: 'Agent profile required' });
  }

  // Check if already subscribed
  if (user.agent.subscription?.status === 'ACTIVE') {
    return res.status(400).json({ 
      error: 'Already has active subscription',
      message: 'Use the portal to manage your subscription',
    });
  }

  const tier = SUBSCRIPTION_TIERS[planId.toUpperCase() as keyof typeof SUBSCRIPTION_TIERS];
  if (!tier || !tier.priceId) {
    return res.status(400).json({ error: 'Invalid plan' });
  }

  // Create or retrieve Stripe customer
  let stripeCustomerId = user.stripeCustomerId;
  
  if (!stripeCustomerId) {
    const customer = await stripe.customers.create({
      email: user.email,
      name: `${user.firstName} ${user.lastName}`,
      metadata: {
        userId: user.id,
        agentId: user.agent.id,
      },
    });
    stripeCustomerId = customer.id;

    await prisma.user.update({
      where: { id: userId },
      data: { stripeCustomerId },
    });
  }

  // Create checkout session
  const session = await stripe.checkout.sessions.create({
    customer: stripeCustomerId,
    mode: 'subscription',
    payment_method_types: ['card'],
    line_items: [
      {
        price: tier.priceId,
        quantity: 1,
      },
    ],
    success_url: `${successUrl}?session_id={CHECKOUT_SESSION_ID}`,
    cancel_url: cancelUrl,
    subscription_data: {
      metadata: {
        userId: user.id,
        agentId: user.agent.id,
        tier: planId,
      },
      trial_period_days: 14, // 14-day free trial
    },
    allow_promotion_codes: true,
    billing_address_collection: 'auto',
    customer_update: {
      address: 'auto',
      name: 'auto',
    },
  });

  res.json({
    sessionId: session.id,
    url: session.url,
  });
}));

// Create portal session for subscription management
router.post('/portal', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const userId = req.user!.id;

  const schema = z.object({
    returnUrl: z.string().url(),
  });

  const { returnUrl } = schema.parse(req.body);

  const user = await prisma.user.findUnique({
    where: { id: userId },
  });

  if (!user?.stripeCustomerId) {
    return res.status(400).json({ error: 'No billing account found' });
  }

  const session = await stripe.billingPortal.sessions.create({
    customer: user.stripeCustomerId,
    return_url: returnUrl,
  });

  res.json({
    url: session.url,
  });
}));

// Upgrade/downgrade subscription
router.post('/change-plan', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const userId = req.user!.id;

  const schema = z.object({
    newPlanId: z.enum(['free', 'basic', 'premium', 'enterprise']),
  });

  const { newPlanId } = schema.parse(req.body);

  const user = await prisma.user.findUnique({
    where: { id: userId },
    include: {
      agent: {
        include: { subscription: true },
      },
    },
  });

  if (!user?.agent?.subscription) {
    return res.status(400).json({ error: 'No active subscription' });
  }

  const subscription = user.agent.subscription;

  // Handle downgrade to free
  if (newPlanId === 'free') {
    await stripe.subscriptions.cancel(subscription.stripeSubscriptionId!);
    
    await prisma.subscription.update({
      where: { id: subscription.id },
      data: {
        status: 'CANCELED',
        cancelAtPeriodEnd: true,
      },
    });

    return res.json({
      message: 'Subscription will be canceled at end of billing period',
      effectiveDate: subscription.currentPeriodEnd,
    });
  }

  const newTier = SUBSCRIPTION_TIERS[newPlanId.toUpperCase() as keyof typeof SUBSCRIPTION_TIERS];
  if (!newTier?.priceId) {
    return res.status(400).json({ error: 'Invalid plan' });
  }

  // Get current Stripe subscription
  const stripeSubscription = await stripe.subscriptions.retrieve(
    subscription.stripeSubscriptionId!
  );

  // Update subscription
  const updatedSubscription = await stripe.subscriptions.update(
    subscription.stripeSubscriptionId!,
    {
      items: [
        {
          id: stripeSubscription.items.data[0].id,
          price: newTier.priceId,
        },
      ],
      proration_behavior: 'create_prorations',
      metadata: {
        tier: newPlanId,
      },
    }
  );

  await prisma.subscription.update({
    where: { id: subscription.id },
    data: {
      tier: newPlanId.toUpperCase(),
    },
  });

  res.json({
    message: `Subscription updated to ${newTier.name}`,
    subscription: {
      tier: newPlanId,
      nextBillingDate: new Date(updatedSubscription.current_period_end * 1000),
    },
  });
}));

// Cancel subscription
router.post('/cancel', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const userId = req.user!.id;

  const schema = z.object({
    cancelImmediately: z.boolean().optional().default(false),
    reason: z.string().max(500).optional(),
  });

  const { cancelImmediately, reason } = schema.parse(req.body);

  const user = await prisma.user.findUnique({
    where: { id: userId },
    include: {
      agent: {
        include: { subscription: true },
      },
    },
  });

  if (!user?.agent?.subscription) {
    return res.status(400).json({ error: 'No active subscription' });
  }

  const subscription = user.agent.subscription;

  if (cancelImmediately) {
    await stripe.subscriptions.cancel(subscription.stripeSubscriptionId!);
    
    await prisma.subscription.update({
      where: { id: subscription.id },
      data: {
        status: 'CANCELED',
        canceledAt: new Date(),
        cancelReason: reason,
      },
    });

    return res.json({
      message: 'Subscription canceled immediately',
      effectiveDate: new Date(),
    });
  } else {
    await stripe.subscriptions.update(subscription.stripeSubscriptionId!, {
      cancel_at_period_end: true,
    });

    await prisma.subscription.update({
      where: { id: subscription.id },
      data: {
        cancelAtPeriodEnd: true,
        cancelReason: reason,
      },
    });

    return res.json({
      message: 'Subscription will be canceled at end of billing period',
      effectiveDate: subscription.currentPeriodEnd,
    });
  }
}));

// Resume canceled subscription
router.post('/resume', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const userId = req.user!.id;

  const user = await prisma.user.findUnique({
    where: { id: userId },
    include: {
      agent: {
        include: { subscription: true },
      },
    },
  });

  if (!user?.agent?.subscription) {
    return res.status(400).json({ error: 'No subscription found' });
  }

  const subscription = user.agent.subscription;

  if (!subscription.cancelAtPeriodEnd) {
    return res.status(400).json({ error: 'Subscription is not scheduled for cancellation' });
  }

  await stripe.subscriptions.update(subscription.stripeSubscriptionId!, {
    cancel_at_period_end: false,
  });

  await prisma.subscription.update({
    where: { id: subscription.id },
    data: {
      cancelAtPeriodEnd: false,
      cancelReason: null,
    },
  });

  res.json({
    message: 'Subscription resumed successfully',
  });
}));

// ============================================
// ADD-ONS PURCHASE
// ============================================

// Purchase add-on
router.post('/add-ons/purchase', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const userId = req.user!.id;

  const schema = z.object({
    addOnId: z.enum(['extra_listings', 'extra_leads', 'featured_boost', 'vastu_certificate', 'climate_deep_analysis', 'ai_valuation']),
    propertyId: z.string().optional(), // For property-specific add-ons
    successUrl: z.string().url(),
    cancelUrl: z.string().url(),
  });

  const { addOnId, propertyId, successUrl, cancelUrl } = schema.parse(req.body);

  const user = await prisma.user.findUnique({
    where: { id: userId },
    include: { agent: true },
  });

  if (!user) {
    return res.status(404).json({ error: 'User not found' });
  }

  const addOn = ADD_ONS[addOnId.toUpperCase() as keyof typeof ADD_ONS];
  if (!addOn) {
    return res.status(400).json({ error: 'Invalid add-on' });
  }

  // Create or retrieve Stripe customer
  let stripeCustomerId = user.stripeCustomerId;
  
  if (!stripeCustomerId) {
    const customer = await stripe.customers.create({
      email: user.email,
      name: `${user.firstName} ${user.lastName}`,
      metadata: { userId: user.id },
    });
    stripeCustomerId = customer.id;

    await prisma.user.update({
      where: { id: userId },
      data: { stripeCustomerId },
    });
  }

  // Create checkout session for one-time purchase
  const session = await stripe.checkout.sessions.create({
    customer: stripeCustomerId,
    mode: 'payment',
    payment_method_types: ['card'],
    line_items: [
      {
        price: addOn.priceId,
        quantity: 1,
      },
    ],
    success_url: `${successUrl}?session_id={CHECKOUT_SESSION_ID}`,
    cancel_url: cancelUrl,
    metadata: {
      userId: user.id,
      agentId: user.agent?.id,
      addOnId: addOn.id,
      propertyId: propertyId || '',
      type: 'addon',
    },
  });

  res.json({
    sessionId: session.id,
    url: session.url,
  });
}));

// ============================================
// INVOICES & BILLING HISTORY
// ============================================

// Get billing history
router.get('/invoices', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const userId = req.user!.id;
  const { limit = 10 } = req.query;

  const user = await prisma.user.findUnique({
    where: { id: userId },
  });

  if (!user?.stripeCustomerId) {
    return res.json({ invoices: [] });
  }

  const invoices = await stripe.invoices.list({
    customer: user.stripeCustomerId,
    limit: Number(limit),
  });

  const formattedInvoices = invoices.data.map(invoice => ({
    id: invoice.id,
    number: invoice.number,
    status: invoice.status,
    amount: invoice.amount_due / 100,
    amountPaid: invoice.amount_paid / 100,
    currency: invoice.currency.toUpperCase(),
    created: new Date(invoice.created * 1000),
    dueDate: invoice.due_date ? new Date(invoice.due_date * 1000) : null,
    paidAt: invoice.status_transitions?.paid_at 
      ? new Date(invoice.status_transitions.paid_at * 1000) 
      : null,
    invoiceUrl: invoice.hosted_invoice_url,
    pdfUrl: invoice.invoice_pdf,
    description: invoice.lines.data[0]?.description,
  }));

  res.json({ invoices: formattedInvoices });
}));

// Get upcoming invoice
router.get('/invoices/upcoming', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const userId = req.user!.id;

  const user = await prisma.user.findUnique({
    where: { id: userId },
    include: {
      agent: {
        include: { subscription: true },
      },
    },
  });

  if (!user?.stripeCustomerId || !user.agent?.subscription?.stripeSubscriptionId) {
    return res.json({ upcomingInvoice: null });
  }

  try {
    const upcomingInvoice = await stripe.invoices.retrieveUpcoming({
      customer: user.stripeCustomerId,
      subscription: user.agent.subscription.stripeSubscriptionId,
    });

    res.json({
      upcomingInvoice: {
        amount: upcomingInvoice.amount_due / 100,
        currency: upcomingInvoice.currency.toUpperCase(),
        dueDate: upcomingInvoice.next_payment_attempt
          ? new Date(upcomingInvoice.next_payment_attempt * 1000)
          : null,
        lineItems: upcomingInvoice.lines.data.map(item => ({
          description: item.description,
          amount: item.amount / 100,
          period: item.period,
        })),
      },
    });
  } catch (err: any) {
    if (err.code === 'invoice_upcoming_none') {
      return res.json({ upcomingInvoice: null });
    }
    throw err;
  }
}));

// ============================================
// PAYMENT METHODS
// ============================================

// Get payment methods
router.get('/payment-methods', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const userId = req.user!.id;

  const user = await prisma.user.findUnique({
    where: { id: userId },
  });

  if (!user?.stripeCustomerId) {
    return res.json({ paymentMethods: [] });
  }

  const paymentMethods = await stripe.paymentMethods.list({
    customer: user.stripeCustomerId,
    type: 'card',
  });

  // Get default payment method
  const customer = await stripe.customers.retrieve(user.stripeCustomerId);
  const defaultPaymentMethodId = typeof customer !== 'string' && !customer.deleted
    ? customer.invoice_settings.default_payment_method
    : null;

  const formattedMethods = paymentMethods.data.map(pm => ({
    id: pm.id,
    brand: pm.card?.brand,
    last4: pm.card?.last4,
    expMonth: pm.card?.exp_month,
    expYear: pm.card?.exp_year,
    isDefault: pm.id === defaultPaymentMethodId,
  }));

  res.json({ paymentMethods: formattedMethods });
}));

// Add payment method
router.post('/payment-methods', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const userId = req.user!.id;

  const schema = z.object({
    paymentMethodId: z.string(),
    setAsDefault: z.boolean().optional().default(true),
  });

  const { paymentMethodId, setAsDefault } = schema.parse(req.body);

  const user = await prisma.user.findUnique({
    where: { id: userId },
  });

  if (!user?.stripeCustomerId) {
    return res.status(400).json({ error: 'No billing account found' });
  }

  // Attach payment method to customer
  await stripe.paymentMethods.attach(paymentMethodId, {
    customer: user.stripeCustomerId,
  });

  // Set as default if requested
  if (setAsDefault) {
    await stripe.customers.update(user.stripeCustomerId, {
      invoice_settings: {
        default_payment_method: paymentMethodId,
      },
    });
  }

  res.json({ message: 'Payment method added successfully' });
}));

// Remove payment method
router.delete('/payment-methods/:paymentMethodId', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const { paymentMethodId } = req.params;
  const userId = req.user!.id;

  const user = await prisma.user.findUnique({
    where: { id: userId },
  });

  if (!user?.stripeCustomerId) {
    return res.status(400).json({ error: 'No billing account found' });
  }

  // Verify payment method belongs to customer
  const paymentMethod = await stripe.paymentMethods.retrieve(paymentMethodId);
  if (paymentMethod.customer !== user.stripeCustomerId) {
    return res.status(403).json({ error: 'Not authorized' });
  }

  await stripe.paymentMethods.detach(paymentMethodId);

  res.json({ message: 'Payment method removed successfully' });
}));

// Set default payment method
router.put('/payment-methods/:paymentMethodId/default', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const { paymentMethodId } = req.params;
  const userId = req.user!.id;

  const user = await prisma.user.findUnique({
    where: { id: userId },
  });

  if (!user?.stripeCustomerId) {
    return res.status(400).json({ error: 'No billing account found' });
  }

  await stripe.customers.update(user.stripeCustomerId, {
    invoice_settings: {
      default_payment_method: paymentMethodId,
    },
  });

  res.json({ message: 'Default payment method updated' });
}));

// ============================================
// COUPONS & PROMOTIONS
// ============================================

// Validate coupon
router.post('/coupons/validate', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const schema = z.object({
    code: z.string(),
  });

  const { code } = schema.parse(req.body);

  try {
    const promotionCodes = await stripe.promotionCodes.list({
      code,
      active: true,
      limit: 1,
    });

    if (promotionCodes.data.length === 0) {
      return res.status(404).json({ 
        valid: false, 
        error: 'Invalid or expired coupon code' 
      });
    }

    const promotionCode = promotionCodes.data[0];
    const coupon = await stripe.coupons.retrieve(promotionCode.coupon.id);

    res.json({
      valid: true,
      coupon: {
        id: coupon.id,
        name: coupon.name,
        percentOff: coupon.percent_off,
        amountOff: coupon.amount_off ? coupon.amount_off / 100 : null,
        duration: coupon.duration,
        durationInMonths: coupon.duration_in_months,
      },
    });
  } catch (err) {
    return res.status(404).json({ 
      valid: false, 
      error: 'Invalid coupon code' 
    });
  }
}));

// ============================================
// USAGE TRACKING
// ============================================

// Get feature usage
router.get('/usage', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const userId = req.user!.id;

  const user = await prisma.user.findUnique({
    where: { id: userId },
    include: {
      agent: {
        include: { subscription: true },
      },
    },
  });

  if (!user?.agent) {
    return res.status(404).json({ error: 'Agent profile not found' });
  }

  const tier = SUBSCRIPTION_TIERS[user.agent.subscription?.tier || 'FREE'];

  // Get current usage
  const [
    listingCount,
    leadCount,
    featuredCount,
    vastuAnalysisCount,
    climateReportCount,
    aiValuationCount,
  ] = await Promise.all([
    prisma.property.count({ where: { agentId: userId } }),
    prisma.lead.count({ where: { agentId: user.agent.id } }),
    prisma.property.count({ 
      where: { 
        agentId: userId,
        isFeatured: true,
      } 
    }),
    prisma.vastuAnalysis.count({
      where: {
        property: { agentId: userId },
        createdAt: {
          gte: new Date(new Date().setDate(1)), // This month
        },
      },
    }),
    prisma.climateAnalysis.count({
      where: {
        property: { agentId: userId },
        createdAt: {
          gte: new Date(new Date().setDate(1)),
        },
      },
    }),
    prisma.propertyValuation.count({
      where: {
        property: { agentId: userId },
        createdAt: {
          gte: new Date(new Date().setDate(1)),
        },
      },
    }),
  ]);

  res.json({
    tier: tier.name,
    usage: {
      listings: {
        used: listingCount,
        limit: tier.features.maxListings,
        unlimited: tier.features.maxListings === -1,
      },
      leads: {
        used: leadCount,
        limit: tier.features.maxLeads,
        unlimited: tier.features.maxLeads === -1,
      },
      featuredListings: {
        used: featuredCount,
        limit: tier.features.featuredListings,
        unlimited: tier.features.featuredListings === -1,
      },
      vastuAnalysis: {
        available: tier.features.vastuAnalysis,
        usedThisMonth: vastuAnalysisCount,
      },
      climateReports: {
        available: tier.features.climateReports,
        usedThisMonth: climateReportCount,
      },
      aiValuation: {
        available: tier.features.aiValuation,
        usedThisMonth: aiValuationCount,
      },
    },
    resetDate: new Date(new Date().getFullYear(), new Date().getMonth() + 1, 1),
  });
}));

// Check feature access
router.get('/access/:feature', authenticate, asyncHandler(async (req: Request, res: Response) => {
  const { feature } = req.params;
  const userId = req.user!.id;

  const user = await prisma.user.findUnique({
    where: { id: userId },
    include: {
      agent: {
        include: { subscription: true },
      },
    },
  });

  if (!user?.agent) {
    return res.status(404).json({ error: 'Agent profile not found' });
  }

  const tier = SUBSCRIPTION_TIERS[user.agent.subscription?.tier || 'FREE'];
  const features = tier.features as Record<string, any>;

  if (!(feature in features)) {
    return res.status(400).json({ error: 'Unknown feature' });
  }

  const featureValue = features[feature];
  let hasAccess = false;
  let reason = '';

  if (typeof featureValue === 'boolean') {
    hasAccess = featureValue;
    reason = hasAccess ? '' : `Upgrade to access ${feature}`;
  } else if (typeof featureValue === 'number') {
    if (featureValue === -1) {
      hasAccess = true;
    } else {
      // Check current usage
      let currentUsage = 0;
      if (feature === 'maxListings') {
        currentUsage = await prisma.property.count({ where: { agentId: userId } });
      } else if (feature === 'maxLeads') {
        currentUsage = await prisma.lead.count({ where: { agentId: user.agent.id } });
      }
      hasAccess = currentUsage < featureValue;
      reason = hasAccess ? '' : `Limit reached (${currentUsage}/${featureValue})`;
    }
  } else {
    hasAccess = true;
  }

  res.json({
    feature,
    hasAccess,
    reason,
    value: featureValue,
    upgradeTier: hasAccess ? null : getNextTierWithFeature(feature, tier.id),
  });
}));

// Helper function to find next tier with feature
function getNextTierWithFeature(feature: string, currentTierId: string): string | null {
  const tierOrder = ['free', 'basic', 'premium', 'enterprise'];
  const currentIndex = tierOrder.indexOf(currentTierId);
  
  for (let i = currentIndex + 1; i < tierOrder.length; i++) {
    const tier = SUBSCRIPTION_TIERS[tierOrder[i].toUpperCase() as keyof typeof SUBSCRIPTION_TIERS];
    const features = tier.features as Record<string, any>;
    
    if (features[feature] === true || features[feature] === -1 || 
        (typeof features[feature] === 'number' && features[feature] > 0)) {
      return tierOrder[i];
    }
  }
  
  return null;
}

export default router;
Webhooks · TS
import { Router, Request, Response } from 'express';
import { z } from 'zod';
import { PrismaClient } from '@prisma/client';
import Stripe from 'stripe';
import crypto from 'crypto';
import { asyncHandler } from '../utils/asyncHandler';
import { redis } from '../utils/redis';

const router = Router();
const prisma = new PrismaClient();

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
  apiVersion: '2023-10-16',
});

// ============================================
// STRIPE WEBHOOKS
// ============================================

router.post('/stripe', asyncHandler(async (req: Request, res: Response) => {
  const sig = req.headers['stripe-signature'] as string;
  const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET!;

  let event: Stripe.Event;

  try {
    // Verify webhook signature
    event = stripe.webhooks.constructEvent(
      req.body, // Raw body
      sig,
      webhookSecret
    );
  } catch (err: any) {
    console.error('Webhook signature verification failed:', err.message);
    return res.status(400).json({ error: 'Invalid signature' });
  }

  // Handle the event
  try {
    switch (event.type) {
      case 'checkout.session.completed':
        await handleCheckoutCompleted(event.data.object as Stripe.Checkout.Session);
        break;

      case 'customer.subscription.created':
        await handleSubscriptionCreated(event.data.object as Stripe.Subscription);
        break;

      case 'customer.subscription.updated':
        await handleSubscriptionUpdated(event.data.object as Stripe.Subscription);
        break;

      case 'customer.subscription.deleted':
        await handleSubscriptionDeleted(event.data.object as Stripe.Subscription);
        break;

      case 'invoice.paid':
        await handleInvoicePaid(event.data.object as Stripe.Invoice);
        break;

      case 'invoice.payment_failed':
        await handleInvoicePaymentFailed(event.data.object as Stripe.Invoice);
        break;

      case 'customer.subscription.trial_will_end':
        await handleTrialWillEnd(event.data.object as Stripe.Subscription);
        break;

      case 'payment_intent.succeeded':
        await handlePaymentSucceeded(event.data.object as Stripe.PaymentIntent);
        break;

      case 'payment_intent.payment_failed':
        await handlePaymentFailed(event.data.object as Stripe.PaymentIntent);
        break;

      default:
        console.log(`Unhandled event type: ${event.type}`);
    }

    res.json({ received: true });
  } catch (err) {
    console.error('Webhook handler error:', err);
    res.status(500).json({ error: 'Webhook handler failed' });
  }
}));

// Stripe webhook handlers
async function handleCheckoutCompleted(session: Stripe.Checkout.Session) {
  const { userId, agentId, tier, addOnId, propertyId, type } = session.metadata || {};

  if (type === 'addon') {
    // Handle add-on purchase
    await processAddOnPurchase(userId!, agentId!, addOnId!, propertyId);
    return;
  }

  // Handle subscription checkout
  if (!agentId || !tier) return;

  // Subscription will be handled by customer.subscription.created
  console.log(`Checkout completed for agent ${agentId}, tier ${tier}`);
}

async function handleSubscriptionCreated(subscription: Stripe.Subscription) {
  const { userId, agentId, tier } = subscription.metadata;

  if (!agentId || !tier) return;

  // Check if subscription record already exists
  const existing = await prisma.subscription.findFirst({
    where: { agentId },
  });

  if (existing) {
    await prisma.subscription.update({
      where: { id: existing.id },
      data: {
        tier: tier.toUpperCase(),
        status: 'ACTIVE',
        stripeSubscriptionId: subscription.id,
        currentPeriodStart: new Date(subscription.current_period_start * 1000),
        currentPeriodEnd: new Date(subscription.current_period_end * 1000),
        cancelAtPeriodEnd: false,
      },
    });
  } else {
    await prisma.subscription.create({
      data: {
        agentId,
        tier: tier.toUpperCase(),
        status: 'ACTIVE',
        stripeSubscriptionId: subscription.id,
        currentPeriodStart: new Date(subscription.current_period_start * 1000),
        currentPeriodEnd: new Date(subscription.current_period_end * 1000),
      },
    });
  }

  // Create notification
  if (userId) {
    await createNotification(userId, 'SYSTEM', 'Subscription Activated', 
      `Your ${tier} subscription is now active. Enjoy all the premium features!`);
  }

  // Update agent tier
  await prisma.agent.update({
    where: { id: agentId },
    data: { tier: tier.toUpperCase() },
  });
}

async function handleSubscriptionUpdated(subscription: Stripe.Subscription) {
  const sub = await prisma.subscription.findFirst({
    where: { stripeSubscriptionId: subscription.id },
    include: { agent: { include: { user: true } } },
  });

  if (!sub) return;

  const status = mapStripeStatus(subscription.status);

  await prisma.subscription.update({
    where: { id: sub.id },
    data: {
      status,
      tier: subscription.metadata.tier?.toUpperCase() || sub.tier,
      currentPeriodStart: new Date(subscription.current_period_start * 1000),
      currentPeriodEnd: new Date(subscription.current_period_end * 1000),
      cancelAtPeriodEnd: subscription.cancel_at_period_end,
    },
  });

  // Notify if tier changed
  if (subscription.metadata.tier && subscription.metadata.tier.toUpperCase() !== sub.tier) {
    await createNotification(
      sub.agent.userId,
      'SYSTEM',
      'Subscription Updated',
      `Your subscription has been updated to ${subscription.metadata.tier}`
    );
  }
}

async function handleSubscriptionDeleted(subscription: Stripe.Subscription) {
  const sub = await prisma.subscription.findFirst({
    where: { stripeSubscriptionId: subscription.id },
    include: { agent: { include: { user: true } } },
  });

  if (!sub) return;

  await prisma.subscription.update({
    where: { id: sub.id },
    data: {
      status: 'CANCELED',
      canceledAt: new Date(),
    },
  });

  // Downgrade agent to free tier
  await prisma.agent.update({
    where: { id: sub.agentId },
    data: { tier: 'FREE' },
  });

  await createNotification(
    sub.agent.userId,
    'SYSTEM',
    'Subscription Canceled',
    'Your subscription has been canceled. You have been moved to the free tier.'
  );
}

async function handleInvoicePaid(invoice: Stripe.Invoice) {
  const subscriptionId = invoice.subscription as string;
  
  if (!subscriptionId) return;

  const sub = await prisma.subscription.findFirst({
    where: { stripeSubscriptionId: subscriptionId },
  });

  if (sub) {
    await prisma.subscription.update({
      where: { id: sub.id },
      data: { status: 'ACTIVE' },
    });
  }

  // Log payment
  await prisma.paymentLog.create({
    data: {
      stripeInvoiceId: invoice.id,
      amount: invoice.amount_paid / 100,
      currency: invoice.currency.toUpperCase(),
      status: 'PAID',
      paidAt: new Date(),
      subscriptionId: sub?.id,
    },
  });
}

async function handleInvoicePaymentFailed(invoice: Stripe.Invoice) {
  const subscriptionId = invoice.subscription as string;
  
  if (!subscriptionId) return;

  const sub = await prisma.subscription.findFirst({
    where: { stripeSubscriptionId: subscriptionId },
    include: { agent: { include: { user: true } } },
  });

  if (!sub) return;

  await prisma.subscription.update({
    where: { id: sub.id },
    data: { status: 'PAST_DUE' },
  });

  await createNotification(
    sub.agent.userId,
    'SYSTEM',
    'Payment Failed',
    'Your subscription payment failed. Please update your payment method to avoid service interruption.',
    { priority: 'HIGH', actionUrl: '/dashboard/billing' }
  );
}

async function handleTrialWillEnd(subscription: Stripe.Subscription) {
  const sub = await prisma.subscription.findFirst({
    where: { stripeSubscriptionId: subscription.id },
    include: { agent: { include: { user: true } } },
  });

  if (!sub) return;

  const trialEnd = new Date(subscription.trial_end! * 1000);
  const daysLeft = Math.ceil((trialEnd.getTime() - Date.now()) / (1000 * 60 * 60 * 24));

  await createNotification(
    sub.agent.userId,
    'SYSTEM',
    'Trial Ending Soon',
    `Your free trial ends in ${daysLeft} days. Add a payment method to continue enjoying premium features.`,
    { priority: 'HIGH', actionUrl: '/dashboard/billing' }
  );
}

async function handlePaymentSucceeded(paymentIntent: Stripe.PaymentIntent) {
  console.log('Payment succeeded:', paymentIntent.id);
}

async function handlePaymentFailed(paymentIntent: Stripe.PaymentIntent) {
  console.log('Payment failed:', paymentIntent.id);
}

async function processAddOnPurchase(userId: string, agentId: string, addOnId: string, propertyId?: string) {
  // Record the purchase
  await prisma.addOnPurchase.create({
    data: {
      agentId,
      addOnType: addOnId,
      propertyId: propertyId || null,
      purchasedAt: new Date(),
      expiresAt: addOnId === 'featured_boost' 
        ? new Date(Date.now() + 30 * 24 * 60 * 60 * 1000) // 30 days
        : null,
    },
  });

  // Apply add-on effects
  switch (addOnId) {
    case 'extra_listings':
      await prisma.agent.update({
        where: { id: agentId },
        data: { extraListingsQuota: { increment: 10 } },
      });
      break;

    case 'extra_leads':
      await prisma.agent.update({
        where: { id: agentId },
        data: { extraLeadsQuota: { increment: 50 } },
      });
      break;

    case 'featured_boost':
      if (propertyId) {
        await prisma.property.update({
          where: { id: propertyId },
          data: {
            isFeatured: true,
            featuredUntil: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),
          },
        });
      }
      break;
  }

  await createNotification(userId, 'SYSTEM', 'Add-On Purchased',
    `Your ${addOnId.replace(/_/g, ' ')} has been activated.`);
}

function mapStripeStatus(status: string): string {
  const statusMap: Record<string, string> = {
    active: 'ACTIVE',
    past_due: 'PAST_DUE',
    canceled: 'CANCELED',
    unpaid: 'UNPAID',
    trialing: 'TRIALING',
    incomplete: 'INCOMPLETE',
    incomplete_expired: 'EXPIRED',
  };
  return statusMap[status] || 'UNKNOWN';
}

// ============================================
// MLS FEED WEBHOOKS
// ============================================

// Signature verification for MLS webhook
function verifyMLSSignature(payload: string, signature: string, secret: string): boolean {
  const computedSignature = crypto
    .createHmac('sha256', secret)
    .update(payload)
    .digest('hex');
  return crypto.timingSafeEqual(
    Buffer.from(signature),
    Buffer.from(computedSignature)
  );
}

router.post('/mls', asyncHandler(async (req: Request, res: Response) => {
  const signature = req.headers['x-mls-signature'] as string;
  const mlsSecret = process.env.MLS_WEBHOOK_SECRET!;

  // Verify signature
  if (!verifyMLSSignature(JSON.stringify(req.body), signature, mlsSecret)) {
    return res.status(401).json({ error: 'Invalid signature' });
  }

  const eventSchema = z.object({
    eventType: z.enum(['listing.created', 'listing.updated', 'listing.deleted', 'listing.status_changed', 'listing.price_changed']),
    listingId: z.string(),
    mlsNumber: z.string(),
    data: z.any(),
    timestamp: z.string(),
  });

  const event = eventSchema.parse(req.body);

  try {
    switch (event.eventType) {
      case 'listing.created':
        await handleMLSListingCreated(event);
        break;

      case 'listing.updated':
        await handleMLSListingUpdated(event);
        break;

      case 'listing.deleted':
        await handleMLSListingDeleted(event);
        break;

      case 'listing.status_changed':
        await handleMLSStatusChanged(event);
        break;

      case 'listing.price_changed':
        await handleMLSPriceChanged(event);
        break;
    }

    res.json({ received: true });
  } catch (err) {
    console.error('MLS webhook error:', err);
    res.status(500).json({ error: 'Processing failed' });
  }
}));

async function handleMLSListingCreated(event: any) {
  const { listingId, mlsNumber, data } = event;

  // Check if already exists
  const existing = await prisma.property.findFirst({
    where: { mlsNumber },
  });

  if (existing) return;

  // Map MLS data to our schema
  const propertyData = mapMLSToProperty(data);

  // Find or create default system agent for MLS imports
  let systemAgent = await prisma.agent.findFirst({
    where: { isSystemAgent: true },
  });

  if (!systemAgent) {
    const systemUser = await prisma.user.create({
      data: {
        email: 'mls-import@dharma-realty.com',
        firstName: 'MLS',
        lastName: 'Import',
        userType: 'AGENT',
      },
    });
    systemAgent = await prisma.agent.create({
      data: {
        userId: systemUser.id,
        licenseNumber: 'SYSTEM-MLS',
        isSystemAgent: true,
      },
    });
  }

  await prisma.property.create({
    data: {
      ...propertyData,
      mlsNumber,
      mlsId: listingId,
      agentId: systemAgent.userId,
      source: 'MLS',
      lastMLSSync: new Date(),
    },
  });

  // Notify agents with matching saved searches
  await notifyMatchingSavedSearches(propertyData);
}

async function handleMLSListingUpdated(event: any) {
  const { mlsNumber, data } = event;

  const property = await prisma.property.findFirst({
    where: { mlsNumber },
  });

  if (!property) return;

  const propertyData = mapMLSToProperty(data);

  await prisma.property.update({
    where: { id: property.id },
    data: {
      ...propertyData,
      lastMLSSync: new Date(),
    },
  });

  // Invalidate cache
  await redis.del(`property:${property.id}`);
}

async function handleMLSListingDeleted(event: any) {
  const { mlsNumber } = event;

  const property = await prisma.property.findFirst({
    where: { mlsNumber },
  });

  if (!property) return;

  // Soft delete - mark as inactive
  await prisma.property.update({
    where: { id: property.id },
    data: {
      status: 'WITHDRAWN',
      isActive: false,
    },
  });

  await redis.del(`property:${property.id}`);
}

async function handleMLSStatusChanged(event: any) {
  const { mlsNumber, data } = event;

  const property = await prisma.property.findFirst({
    where: { mlsNumber },
    include: { favorites: { include: { user: true } } },
  });

  if (!property) return;

  const statusMap: Record<string, string> = {
    'A': 'ACTIVE',
    'P': 'PENDING',
    'S': 'SOLD',
    'W': 'WITHDRAWN',
    'C': 'CANCELED',
  };

  const newStatus = statusMap[data.status] || data.status;

  await prisma.property.update({
    where: { id: property.id },
    data: {
      status: newStatus,
      lastMLSSync: new Date(),
    },
  });

  // Notify users who favorited this property
  for (const favorite of property.favorites) {
    await createNotification(
      favorite.userId,
      'PROPERTY_UPDATE',
      'Property Status Changed',
      `A property you saved has a new status: ${newStatus}`,
      { propertyId: property.id }
    );
  }
}

async function handleMLSPriceChanged(event: any) {
  const { mlsNumber, data } = event;

  const property = await prisma.property.findFirst({
    where: { mlsNumber },
    include: { favorites: { include: { user: true } } },
  });

  if (!property) return;

  const oldPrice = property.price;
  const newPrice = data.listPrice;
  const priceChange = newPrice - oldPrice;
  const percentChange = Math.round((priceChange / oldPrice) * 100);

  // Record price history
  await prisma.priceHistory.create({
    data: {
      propertyId: property.id,
      price: newPrice,
      previousPrice: oldPrice,
      changeAmount: priceChange,
      changePercent: percentChange,
      source: 'MLS',
    },
  });

  await prisma.property.update({
    where: { id: property.id },
    data: {
      price: newPrice,
      priceReduced: priceChange < 0,
      lastMLSSync: new Date(),
    },
  });

  // Notify users who favorited this property
  const changeType = priceChange < 0 ? 'reduced' : 'increased';
  for (const favorite of property.favorites) {
    await createNotification(
      favorite.userId,
      'PRICE_CHANGE',
      `Price ${changeType.charAt(0).toUpperCase() + changeType.slice(1)}`,
      `A property you saved has been ${changeType} by ${Math.abs(percentChange)}%`,
      { propertyId: property.id, priority: priceChange < 0 ? 'HIGH' : 'NORMAL' }
    );
  }

  await redis.del(`property:${property.id}`);
}

function mapMLSToProperty(mlsData: any): any {
  return {
    title: mlsData.publicRemarks?.substring(0, 100) || `${mlsData.propertyType} in ${mlsData.city}`,
    description: mlsData.publicRemarks || '',
    propertyType: mapPropertyType(mlsData.propertyType),
    listingType: mlsData.listingType === 'R' ? 'RENT' : 'SALE',
    price: mlsData.listPrice,
    bedrooms: mlsData.bedroomsTotal,
    bathrooms: mlsData.bathroomsTotal,
    squareFeet: mlsData.livingArea,
    lotSize: mlsData.lotSizeArea,
    yearBuilt: mlsData.yearBuilt,
    address: mlsData.streetAddress,
    city: mlsData.city,
    state: mlsData.stateOrProvince,
    zipCode: mlsData.postalCode,
    country: mlsData.country || 'USA',
    latitude: mlsData.latitude,
    longitude: mlsData.longitude,
    features: mlsData.features || [],
    amenities: mlsData.amenities || [],
  };
}

function mapPropertyType(mlsType: string): string {
  const typeMap: Record<string, string> = {
    'RES': 'SINGLE_FAMILY',
    'CND': 'CONDO',
    'TWN': 'TOWNHOUSE',
    'MUL': 'MULTI_FAMILY',
    'LND': 'LAND',
    'COM': 'COMMERCIAL',
  };
  return typeMap[mlsType] || 'OTHER';
}

async function notifyMatchingSavedSearches(propertyData: any) {
  // Find saved searches that match this property
  const savedSearches = await prisma.savedSearch.findMany({
    where: {
      isActive: true,
      alertFrequency: { not: 'NEVER' },
    },
    include: { user: true },
  });

  for (const search of savedSearches) {
    const filters = search.filters as any;
    
    // Basic matching logic
    let matches = true;
    
    if (filters.propertyType && filters.propertyType !== propertyData.propertyType) {
      matches = false;
    }
    if (filters.minPrice && propertyData.price < filters.minPrice) {
      matches = false;
    }
    if (filters.maxPrice && propertyData.price > filters.maxPrice) {
      matches = false;
    }
    if (filters.minBedrooms && propertyData.bedrooms < filters.minBedrooms) {
      matches = false;
    }
    if (filters.city && !propertyData.city.toLowerCase().includes(filters.city.toLowerCase())) {
      matches = false;
    }

    if (matches && search.alertFrequency === 'INSTANT') {
      await createNotification(
        search.userId,
        'NEW_LISTING',
        'New Property Match',
        `A new property matching your "${search.name}" search is available`,
        { searchId: search.id, priority: 'HIGH' }
      );
    }
  }
}

// ============================================
// IOT SENSOR WEBHOOKS
// ============================================

router.post('/iot', asyncHandler(async (req: Request, res: Response) => {
  const apiKey = req.headers['x-api-key'] as string;
  
  if (apiKey !== process.env.IOT_WEBHOOK_API_KEY) {
    return res.status(401).json({ error: 'Invalid API key' });
  }

  const dataSchema = z.object({
    deviceId: z.string(),
    propertyId: z.string(),
    sensorType: z.enum(['TEMPERATURE', 'HUMIDITY', 'AIR_QUALITY', 'WATER_LEAK', 'MOTION', 'DOOR_WINDOW', 'ENERGY', 'SMOKE', 'CO2', 'NOISE']),
    value: z.number(),
    unit: z.string(),
    timestamp: z.string(),
    batteryLevel: z.number().optional(),
    metadata: z.any().optional(),
  });

  const data = dataSchema.parse(req.body);

  try {
    // Store reading
    await prisma.sensorReading.create({
      data: {
        deviceId: data.deviceId,
        propertyId: data.propertyId,
        sensorType: data.sensorType,
        value: data.value,
        unit: data.unit,
        timestamp: new Date(data.timestamp),
        batteryLevel: data.batteryLevel,
        metadata: data.metadata,
      },
    });

    // Update device last seen
    await prisma.iotDevice.update({
      where: { id: data.deviceId },
      data: {
        lastSeen: new Date(),
        batteryLevel: data.batteryLevel,
        lastReading: data.value,
      },
    });

    // Check for alerts
    await checkSensorAlerts(data);

    // Update Redis cache for real-time display
    await redis.setex(
      `sensor:${data.deviceId}:latest`,
      3600,
      JSON.stringify(data)
    );

    res.json({ received: true });
  } catch (err) {
    console.error('IoT webhook error:', err);
    res.status(500).json({ error: 'Processing failed' });
  }
}));

async function checkSensorAlerts(data: any) {
  const property = await prisma.property.findUnique({
    where: { id: data.propertyId },
    include: { owner: true, agent: true },
  });

  if (!property) return;

  const alertThresholds: Record<string, { min?: number; max?: number; immediate?: boolean }> = {
    TEMPERATURE: { min: 10, max: 35 }, // Celsius
    HUMIDITY: { min: 20, max: 80 }, // Percent
    AIR_QUALITY: { max: 150 }, // AQI
    WATER_LEAK: { max: 0.1, immediate: true }, // Any detection
    SMOKE: { max: 0.5, immediate: true },
    CO2: { max: 1000 }, // PPM
    NOISE: { max: 70 }, // dB
  };

  const threshold = alertThresholds[data.sensorType];
  if (!threshold) return;

  let shouldAlert = false;
  let alertMessage = '';
  let priority: 'LOW' | 'NORMAL' | 'HIGH' | 'URGENT' = 'NORMAL';

  if (threshold.min !== undefined && data.value < threshold.min) {
    shouldAlert = true;
    alertMessage = `Low ${data.sensorType.toLowerCase()}: ${data.value}${data.unit}`;
    priority = 'HIGH';
  } else if (threshold.max !== undefined && data.value > threshold.max) {
    shouldAlert = true;
    alertMessage = `High ${data.sensorType.toLowerCase()}: ${data.value}${data.unit}`;
    priority = threshold.immediate ? 'URGENT' : 'HIGH';
  }

  if (shouldAlert) {
    // Create alert record
    await prisma.sensorAlert.create({
      data: {
        deviceId: data.deviceId,
        propertyId: data.propertyId,
        sensorType: data.sensorType,
        alertType: data.value > (threshold.max || 0) ? 'HIGH' : 'LOW',
        value: data.value,
        threshold: threshold.max || threshold.min,
        message: alertMessage,
        priority,
      },
    });

    // Notify owner
    if (property.ownerId) {
      await createNotification(
        property.ownerId,
        'SENSOR_ALERT',
        `Sensor Alert: ${data.sensorType}`,
        alertMessage,
        { 
          propertyId: property.id, 
          deviceId: data.deviceId,
          priority,
          requiresAction: threshold.immediate,
        }
      );
    }

    // Notify agent for urgent alerts
    if (threshold.immediate && property.agentId) {
      await createNotification(
        property.agentId,
        'SENSOR_ALERT',
        `URGENT: ${data.sensorType} Alert`,
        `${alertMessage} at ${property.address}`,
        { 
          propertyId: property.id, 
          priority: 'URGENT',
        }
      );
    }

    // Publish to real-time channel
    await redis.publish(`property:${property.id}:alerts`, JSON.stringify({
      type: 'SENSOR_ALERT',
      data: {
        sensorType: data.sensorType,
        value: data.value,
        message: alertMessage,
        priority,
        timestamp: new Date().toISOString(),
      },
    }));
  }
}

// Bulk IoT data ingestion endpoint
router.post('/iot/bulk', asyncHandler(async (req: Request, res: Response) => {
  const apiKey = req.headers['x-api-key'] as string;
  
  if (apiKey !== process.env.IOT_WEBHOOK_API_KEY) {
    return res.status(401).json({ error: 'Invalid API key' });
  }

  const bulkSchema = z.object({
    readings: z.array(z.object({
      deviceId: z.string(),
      propertyId: z.string(),
      sensorType: z.string(),
      value: z.number(),
      unit: z.string(),
      timestamp: z.string(),
    })),
  });

  const { readings } = bulkSchema.parse(req.body);

  // Batch insert
  await prisma.sensorReading.createMany({
    data: readings.map(r => ({
      deviceId: r.deviceId,
      propertyId: r.propertyId,
      sensorType: r.sensorType,
      value: r.value,
      unit: r.unit,
      timestamp: new Date(r.timestamp),
    })),
    skipDuplicates: true,
  });

  res.json({ received: readings.length });
}));

// ============================================
// CLIMATE DATA WEBHOOKS
// ============================================

router.post('/climate', asyncHandler(async (req: Request, res: Response) => {
  const apiKey = req.headers['x-api-key'] as string;
  
  if (apiKey !== process.env.CLIMATE_WEBHOOK_API_KEY) {
    return res.status(401).json({ error: 'Invalid API key' });
  }

  const dataSchema = z.object({
    eventType: z.enum(['weather_alert', 'flood_warning', 'wildfire_update', 'air_quality_update', 'hurricane_update']),
    region: z.object({
      latitude: z.number(),
      longitude: z.number(),
      radius: z.number(), // km
    }),
    severity: z.enum(['LOW', 'MODERATE', 'HIGH', 'EXTREME']),
    data: z.any(),
    expiresAt: z.string().optional(),
  });

  const event = dataSchema.parse(req.body);

  try {
    // Find properties in affected region
    const affectedProperties = await prisma.property.findMany({
      where: {
        latitude: {
          gte: event.region.latitude - (event.region.radius / 111),
          lte: event.region.latitude + (event.region.radius / 111),
        },
        longitude: {
          gte: event.region.longitude - (event.region.radius / 111),
          lte: event.region.longitude + (event.region.radius / 111),
        },
        isActive: true,
      },
      include: {
        owner: true,
        agent: true,
        favorites: { include: { user: true } },
      },
    });

    // Create climate event record
    await prisma.climateEvent.create({
      data: {
        type: event.eventType,
        severity: event.severity,
        latitude: event.region.latitude,
        longitude: event.region.longitude,
        radius: event.region.radius,
        data: event.data,
        affectedPropertyCount: affectedProperties.length,
        expiresAt: event.expiresAt ? new Date(event.expiresAt) : null,
      },
    });

    // Notify affected property owners and interested users
    const notifiedUsers = new Set<string>();

    for (const property of affectedProperties) {
      // Update property climate risk if severe
      if (event.severity === 'HIGH' || event.severity === 'EXTREME') {
        await prisma.climateAnalysis.updateMany({
          where: { propertyId: property.id },
          data: {
            hasActiveAlert: true,
            lastAlertType: event.eventType,
            lastAlertSeverity: event.severity,
          },
        });
      }

      // Notify owner
      if (property.ownerId && !notifiedUsers.has(property.ownerId)) {
        await createNotification(
          property.ownerId,
          'CLIMATE_ALERT',
          `Climate Alert: ${formatEventType(event.eventType)}`,
          `${event.severity} severity alert for your property at ${property.address}`,
          {
            propertyId: property.id,
            priority: event.severity === 'EXTREME' ? 'URGENT' : 'HIGH',
            data: event.data,
          }
        );
        notifiedUsers.add(property.ownerId);
      }

      // Notify agent
      if (property.agentId && !notifiedUsers.has(property.agentId)) {
        await createNotification(
          property.agentId,
          'CLIMATE_ALERT',
          `Climate Alert: ${formatEventType(event.eventType)}`,
          `${event.severity} alert affecting ${property.address}`,
          {
            propertyId: property.id,
            priority: event.severity === 'EXTREME' ? 'URGENT' : 'HIGH',
          }
        );
        notifiedUsers.add(property.agentId);
      }

      // Notify users who favorited
      for (const favorite of property.favorites) {
        if (!notifiedUsers.has(favorite.userId)) {
          await createNotification(
            favorite.userId,
            'CLIMATE_ALERT',
            `Climate Alert for Saved Property`,
            `${event.severity} ${formatEventType(event.eventType)} near a property you saved`,
            {
              propertyId: property.id,
              priority: event.severity === 'HIGH' || event.severity === 'EXTREME' ? 'HIGH' : 'NORMAL',
            }
          );
          notifiedUsers.add(favorite.userId);
        }
      }
    }

    res.json({ 
      received: true,
      affectedProperties: affectedProperties.length,
      notifiedUsers: notifiedUsers.size,
    });
  } catch (err) {
    console.error('Climate webhook error:', err);
    res.status(500).json({ error: 'Processing failed' });
  }
}));

function formatEventType(type: string): string {
  return type
    .split('_')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
}

// ============================================
// PANCHANG/ASTROLOGY WEBHOOKS
// ============================================

router.post('/panchang', asyncHandler(async (req: Request, res: Response) => {
  const apiKey = req.headers['x-api-key'] as string;
  
  if (apiKey !== process.env.PANCHANG_WEBHOOK_API_KEY) {
    return res.status(401).json({ error: 'Invalid API key' });
  }

  const dataSchema = z.object({
    date: z.string(),
    nakshatra: z.string(),
    tithi: z.string(),
    yoga: z.string(),
    karana: z.string(),
    rahuKaal: z.object({
      start: z.string(),
      end: z.string(),
    }),
    specialDay: z.string().optional(),
    isAuspicious: z.boolean(),
    auspiciousFor: z.array(z.string()).optional(),
  });

  const data = dataSchema.parse(req.body);

  try {
    // Store daily panchang
    await prisma.dailyPanchang.upsert({
      where: { date: new Date(data.date) },
      update: data,
      create: {
        ...data,
        date: new Date(data.date),
      },
    });

    // If it's an auspicious day, notify users with relevant events scheduled
    if (data.isAuspicious && data.auspiciousFor?.length) {
      const upcomingEvents = await prisma.propertyEvent.findMany({
        where: {
          scheduledDate: {
            gte: new Date(data.date),
            lt: new Date(new Date(data.date).getTime() + 24 * 60 * 60 * 1000),
          },
          eventType: {
            in: data.auspiciousFor,
          },
        },
        include: { property: { include: { owner: true } } },
      });

      for (const event of upcomingEvents) {
        if (event.property.ownerId) {
          await createNotification(
            event.property.ownerId,
            'AUSPICIOUS_DATE',
            'Auspicious Day for Your Event',
            `Today is especially favorable for ${event.eventType}. Nakshatra: ${data.nakshatra}, Tithi: ${data.tithi}`,
            {
              propertyId: event.propertyId,
              eventId: event.id,
              panchang: data,
            }
          );
        }
      }
    }

    // Cache for the day
    await redis.setex(
      `panchang:${data.date}`,
      86400,
      JSON.stringify(data)
    );

    res.json({ received: true });
  } catch (err) {
    console.error('Panchang webhook error:', err);
    res.status(500).json({ error: 'Processing failed' });
  }
}));

// ============================================
// HELPER FUNCTIONS
// ============================================

async function createNotification(
  userId: string,
  type: string,
  title: string,
  message: string,
  metadata?: any
) {
  try {
    const notification = await prisma.notification.create({
      data: {
        userId,
        type,
        title,
        message,
        priority: metadata?.priority || 'NORMAL',
        data: metadata,
      },
    });

    // Publish to real-time channel
    await redis.publish(`user:${userId}:notifications`, JSON.stringify({
      type: 'NEW_NOTIFICATION',
      notification,
    }));

    return notification;
  } catch (err) {
    console.error('Failed to create notification:', err);
  }
}

// Health check for webhook endpoints
router.get('/health', (req: Request, res: Response) => {
  res.json({
    status: 'healthy',
    endpoints: {
      stripe: '/webhooks/stripe',
      mls: '/webhooks/mls',
      iot: '/webhooks/iot',
      climate: '/webhooks/climate',
      panchang: '/webhooks/panchang',
    },
    timestamp: new Date().toISOString(),
  });
});

export default router;
Index · TS
import { Server as SocketIOServer, Socket } from 'socket.io';
import { Server as HTTPServer } from 'http';
import { PrismaClient } from '@prisma/client';
import jwt from 'jsonwebtoken';
import { redis } from '../utils/redis';

const prisma = new PrismaClient();

interface AuthenticatedSocket extends Socket {
  userId?: string;
  userType?: string;
  agentId?: string;
}

interface JWTPayload {
  userId: string;
  userType: string;
  agentId?: string;
}

// Room types
const ROOM_TYPES = {
  USER: 'user',
  PROPERTY: 'property',
  OPEN_HOUSE: 'openhouse',
  VIRTUAL_TOUR: 'tour',
  AUCTION: 'auction',
  AGENT_DASHBOARD: 'agent',
} as const;

export function initializeWebSocket(httpServer: HTTPServer): SocketIOServer {
  const io = new SocketIOServer(httpServer, {
    cors: {
      origin: process.env.CORS_ORIGIN?.split(',') || ['http://localhost:3000'],
      methods: ['GET', 'POST'],
      credentials: true,
    },
    pingInterval: 25000,
    pingTimeout: 60000,
  });

  // Authentication middleware
  io.use(async (socket: AuthenticatedSocket, next) => {
    try {
      const token = socket.handshake.auth.token || socket.handshake.headers.authorization?.replace('Bearer ', '');
      
      if (!token) {
        // Allow anonymous connections for public features
        socket.userId = `anon_${socket.id}`;
        return next();
      }

      const decoded = jwt.verify(token, process.env.JWT_SECRET!) as JWTPayload;
      socket.userId = decoded.userId;
      socket.userType = decoded.userType;
      socket.agentId = decoded.agentId;

      // Update user's online status
      await redis.setex(`user:${decoded.userId}:online`, 300, 'true');
      await redis.sadd('online_users', decoded.userId);

      next();
    } catch (err) {
      socket.userId = `anon_${socket.id}`;
      next();
    }
  });

  io.on('connection', (socket: AuthenticatedSocket) => {
    console.log(`Client connected: ${socket.id} (User: ${socket.userId})`);

    // Join user's personal room
    if (socket.userId && !socket.userId.startsWith('anon_')) {
      socket.join(`${ROOM_TYPES.USER}:${socket.userId}`);
      
      // Subscribe to Redis channels for this user
      subscribeToUserChannels(socket);
    }

    // ============================================
    // MESSAGING HANDLERS
    // ============================================

    socket.on('message:send', async (data: {
      recipientId: string;
      content: string;
      type?: string;
      propertyId?: string;
      attachments?: any[];
    }) => {
      if (!socket.userId || socket.userId.startsWith('anon_')) {
        socket.emit('error', { message: 'Authentication required' });
        return;
      }

      try {
        // Create message in database
        const message = await prisma.message.create({
          data: {
            senderId: socket.userId,
            recipientId: data.recipientId,
            content: data.content,
            type: data.type || 'TEXT',
            propertyId: data.propertyId,
            attachments: data.attachments,
          },
          include: {
            sender: {
              select: { id: true, firstName: true, lastName: true, avatarUrl: true },
            },
          },
        });

        // Send to recipient
        io.to(`${ROOM_TYPES.USER}:${data.recipientId}`).emit('message:new', message);

        // Confirm to sender
        socket.emit('message:sent', message);

        // Create notification
        await createMessageNotification(data.recipientId, socket.userId, data.content);
      } catch (err) {
        console.error('Message send error:', err);
        socket.emit('error', { message: 'Failed to send message' });
      }
    });

    socket.on('message:typing', (data: { recipientId: string; isTyping: boolean }) => {
      if (!socket.userId) return;
      
      io.to(`${ROOM_TYPES.USER}:${data.recipientId}`).emit('message:typing', {
        senderId: socket.userId,
        isTyping: data.isTyping,
      });
    });

    socket.on('message:read', async (data: { messageId: string }) => {
      if (!socket.userId) return;

      try {
        const message = await prisma.message.update({
          where: { id: data.messageId },
          data: { readAt: new Date() },
        });

        // Notify sender
        io.to(`${ROOM_TYPES.USER}:${message.senderId}`).emit('message:read', {
          messageId: data.messageId,
          readAt: message.readAt,
        });
      } catch (err) {
        console.error('Message read error:', err);
      }
    });

    // ============================================
    // PROPERTY UPDATES HANDLERS
    // ============================================

    socket.on('property:subscribe', (propertyId: string) => {
      socket.join(`${ROOM_TYPES.PROPERTY}:${propertyId}`);
      console.log(`${socket.userId} subscribed to property ${propertyId}`);
    });

    socket.on('property:unsubscribe', (propertyId: string) => {
      socket.leave(`${ROOM_TYPES.PROPERTY}:${propertyId}`);
    });

    // Broadcast property updates (called from webhooks/API)
    socket.on('property:update', async (data: { propertyId: string; update: any }) => {
      // Only allow authenticated agents/owners
      if (!socket.userId || socket.userId.startsWith('anon_')) return;

      const property = await prisma.property.findUnique({
        where: { id: data.propertyId },
      });

      if (property?.ownerId !== socket.userId && property?.agentId !== socket.userId) {
        return;
      }

      io.to(`${ROOM_TYPES.PROPERTY}:${data.propertyId}`).emit('property:updated', {
        propertyId: data.propertyId,
        ...data.update,
        timestamp: new Date(),
      });
    });

    // ============================================
    // OPEN HOUSE HANDLERS
    // ============================================

    socket.on('openhouse:join', async (data: { openHouseId: string; visitorInfo?: any }) => {
      socket.join(`${ROOM_TYPES.OPEN_HOUSE}:${data.openHouseId}`);

      // Track visitor
      const visitorKey = `openhouse:${data.openHouseId}:visitors`;
      await redis.sadd(visitorKey, socket.userId || socket.id);

      // Get current count
      const visitorCount = await redis.scard(visitorKey);

      // Broadcast to all in room
      io.to(`${ROOM_TYPES.OPEN_HOUSE}:${data.openHouseId}`).emit('openhouse:visitor_joined', {
        visitorCount,
        visitorId: socket.userId || socket.id,
      });

      // Log attendance if authenticated
      if (socket.userId && !socket.userId.startsWith('anon_')) {
        await prisma.openHouseAttendee.upsert({
          where: {
            openHouseId_visitorId: {
              openHouseId: data.openHouseId,
              visitorId: socket.userId,
            },
          },
          update: { lastSeenAt: new Date() },
          create: {
            openHouseId: data.openHouseId,
            visitorId: socket.userId,
            visitorInfo: data.visitorInfo,
          },
        });
      }
    });

    socket.on('openhouse:leave', async (openHouseId: string) => {
      socket.leave(`${ROOM_TYPES.OPEN_HOUSE}:${openHouseId}`);

      const visitorKey = `openhouse:${openHouseId}:visitors`;
      await redis.srem(visitorKey, socket.userId || socket.id);

      const visitorCount = await redis.scard(visitorKey);

      io.to(`${ROOM_TYPES.OPEN_HOUSE}:${openHouseId}`).emit('openhouse:visitor_left', {
        visitorCount,
      });
    });

    socket.on('openhouse:question', async (data: { openHouseId: string; question: string }) => {
      if (!socket.userId) return;

      const user = await prisma.user.findUnique({
        where: { id: socket.userId },
        select: { firstName: true, lastName: true },
      });

      io.to(`${ROOM_TYPES.OPEN_HOUSE}:${data.openHouseId}`).emit('openhouse:new_question', {
        questionId: `q_${Date.now()}`,
        question: data.question,
        askedBy: user ? `${user.firstName} ${user.lastName?.charAt(0)}.` : 'Anonymous',
        timestamp: new Date(),
      });
    });

    // ============================================
    // VIRTUAL TOUR HANDLERS
    // ============================================

    socket.on('tour:join', async (data: { tourId: string; propertyId: string }) => {
      socket.join(`${ROOM_TYPES.VIRTUAL_TOUR}:${data.tourId}`);

      const participantKey = `tour:${data.tourId}:participants`;
      await redis.sadd(participantKey, socket.userId || socket.id);

      const participants = await redis.smembers(participantKey);

      io.to(`${ROOM_TYPES.VIRTUAL_TOUR}:${data.tourId}`).emit('tour:participant_joined', {
        participantId: socket.userId || socket.id,
        participantCount: participants.length,
      });
    });

    socket.on('tour:leave', async (tourId: string) => {
      socket.leave(`${ROOM_TYPES.VIRTUAL_TOUR}:${tourId}`);

      const participantKey = `tour:${tourId}:participants`;
      await redis.srem(participantKey, socket.userId || socket.id);
    });

    // Sync tour position (for guided tours)
    socket.on('tour:position_update', (data: {
      tourId: string;
      position: { x: number; y: number; z: number };
      rotation: { x: number; y: number };
      room?: string;
    }) => {
      // Broadcast to other participants
      socket.to(`${ROOM_TYPES.VIRTUAL_TOUR}:${data.tourId}`).emit('tour:position_sync', {
        participantId: socket.userId || socket.id,
        ...data,
      });
    });

    // Tour annotations/comments
    socket.on('tour:annotation', async (data: {
      tourId: string;
      propertyId: string;
      position: { x: number; y: number; z: number };
      content: string;
      type: 'comment' | 'question' | 'highlight';
    }) => {
      if (!socket.userId) return;

      const annotation = await prisma.tourAnnotation.create({
        data: {
          tourId: data.tourId,
          propertyId: data.propertyId,
          userId: socket.userId,
          position: data.position,
          content: data.content,
          type: data.type,
        },
        include: {
          user: {
            select: { firstName: true, lastName: true },
          },
        },
      });

      io.to(`${ROOM_TYPES.VIRTUAL_TOUR}:${data.tourId}`).emit('tour:new_annotation', annotation);
    });

    // ============================================
    // AUCTION HANDLERS
    // ============================================

    socket.on('auction:join', async (auctionId: string) => {
      socket.join(`${ROOM_TYPES.AUCTION}:${auctionId}`);

      // Get current auction state
      const auctionState = await redis.get(`auction:${auctionId}:state`);
      
      if (auctionState) {
        socket.emit('auction:state', JSON.parse(auctionState));
      }

      // Track bidders
      if (socket.userId && !socket.userId.startsWith('anon_')) {
        await redis.sadd(`auction:${auctionId}:bidders`, socket.userId);
      }

      const bidderCount = await redis.scard(`auction:${auctionId}:bidders`);
      io.to(`${ROOM_TYPES.AUCTION}:${auctionId}`).emit('auction:bidder_count', { count: bidderCount });
    });

    socket.on('auction:bid', async (data: { auctionId: string; amount: number }) => {
      if (!socket.userId || socket.userId.startsWith('anon_')) {
        socket.emit('error', { message: 'Authentication required to bid' });
        return;
      }

      try {
        // Get current auction state
        const stateStr = await redis.get(`auction:${data.auctionId}:state`);
        const state = stateStr ? JSON.parse(stateStr) : null;

        if (!state || state.status !== 'ACTIVE') {
          socket.emit('auction:bid_rejected', { reason: 'Auction not active' });
          return;
        }

        // Validate bid
        const minBid = state.currentBid + state.minIncrement;
        if (data.amount < minBid) {
          socket.emit('auction:bid_rejected', { reason: `Minimum bid is $${minBid}` });
          return;
        }

        // Get bidder info
        const user = await prisma.user.findUnique({
          where: { id: socket.userId },
          select: { firstName: true, lastName: true },
        });

        // Record bid
        const bid = await prisma.auctionBid.create({
          data: {
            auctionId: data.auctionId,
            bidderId: socket.userId,
            amount: data.amount,
          },
        });

        // Update auction state
        const newState = {
          ...state,
          currentBid: data.amount,
          highestBidderId: socket.userId,
          bidCount: state.bidCount + 1,
          lastBidAt: new Date().toISOString(),
        };

        await redis.setex(`auction:${data.auctionId}:state`, 86400, JSON.stringify(newState));

        // Broadcast to all
        io.to(`${ROOM_TYPES.AUCTION}:${data.auctionId}`).emit('auction:new_bid', {
          bidId: bid.id,
          amount: data.amount,
          bidderName: user ? `${user.firstName} ${user.lastName?.charAt(0)}.` : 'Anonymous',
          timestamp: new Date(),
          bidCount: newState.bidCount,
        });

        // Confirm to bidder
        socket.emit('auction:bid_accepted', { bidId: bid.id, amount: data.amount });

        // Extend auction if bid in last 2 minutes
        const timeLeft = new Date(state.endsAt).getTime() - Date.now();
        if (timeLeft < 120000) { // 2 minutes
          const extendedEndsAt = new Date(Date.now() + 120000);
          newState.endsAt = extendedEndsAt.toISOString();
          await redis.setex(`auction:${data.auctionId}:state`, 86400, JSON.stringify(newState));
          
          io.to(`${ROOM_TYPES.AUCTION}:${data.auctionId}`).emit('auction:extended', {
            endsAt: extendedEndsAt,
            reason: 'Bid in final minutes',
          });
        }
      } catch (err) {
        console.error('Auction bid error:', err);
        socket.emit('error', { message: 'Failed to place bid' });
      }
    });

    socket.on('auction:leave', (auctionId: string) => {
      socket.leave(`${ROOM_TYPES.AUCTION}:${auctionId}`);
    });

    // ============================================
    // AGENT DASHBOARD HANDLERS
    // ============================================

    socket.on('agent:subscribe', async () => {
      if (!socket.agentId) {
        socket.emit('error', { message: 'Agent authentication required' });
        return;
      }

      socket.join(`${ROOM_TYPES.AGENT_DASHBOARD}:${socket.agentId}`);

      // Send initial dashboard data
      const dashboardData = await getAgentDashboardData(socket.agentId);
      socket.emit('agent:dashboard_data', dashboardData);
    });

    // ============================================
    // PRESENCE & STATUS
    // ============================================

    socket.on('presence:update', async (status: 'online' | 'away' | 'busy' | 'offline') => {
      if (!socket.userId || socket.userId.startsWith('anon_')) return;

      await redis.setex(`user:${socket.userId}:status`, 300, status);

      // Notify contacts (simplified - in production, get actual contacts)
      socket.broadcast.emit('presence:changed', {
        userId: socket.userId,
        status,
      });
    });

    socket.on('presence:check', async (userIds: string[]) => {
      const statuses: Record<string, string> = {};
      
      for (const userId of userIds) {
        const status = await redis.get(`user:${userId}:status`);
        statuses[userId] = status || 'offline';
      }

      socket.emit('presence:status', statuses);
    });

    // ============================================
    // DISCONNECT HANDLER
    // ============================================

    socket.on('disconnect', async () => {
      console.log(`Client disconnected: ${socket.id}`);

      if (socket.userId && !socket.userId.startsWith('anon_')) {
        // Update offline status
        await redis.del(`user:${socket.userId}:online`);
        await redis.srem('online_users', socket.userId);
        await redis.setex(`user:${socket.userId}:status`, 300, 'offline');

        // Clean up from any open houses/tours
        const openHouseKeys = await redis.keys('openhouse:*:visitors');
        for (const key of openHouseKeys) {
          await redis.srem(key, socket.userId);
        }

        const tourKeys = await redis.keys('tour:*:participants');
        for (const key of tourKeys) {
          await redis.srem(key, socket.userId);
        }
      }
    });
  });

  // Redis subscription for cross-server events
  setupRedisSubscriptions(io);

  return io;
}

// Subscribe to user-specific Redis channels
async function subscribeToUserChannels(socket: AuthenticatedSocket) {
  if (!socket.userId) return;

  const subscriber = redis.duplicate();
  await subscriber.subscribe(
    `user:${socket.userId}:messages`,
    `user:${socket.userId}:notifications`
  );

  subscriber.on('message', (channel, message) => {
    try {
      const data = JSON.parse(message);
      
      if (channel.endsWith(':messages')) {
        socket.emit(`message:${data.type.toLowerCase()}`, data);
      } else if (channel.endsWith(':notifications')) {
        socket.emit('notification:new', data.notification);
      }
    } catch (err) {
      console.error('Redis message parse error:', err);
    }
  });

  socket.on('disconnect', () => {
    subscriber.unsubscribe();
    subscriber.quit();
  });
}

// Setup Redis subscriptions for cross-server events
function setupRedisSubscriptions(io: SocketIOServer) {
  const subscriber = redis.duplicate();

  subscriber.psubscribe('property:*:updates', 'property:*:alerts');

  subscriber.on('pmessage', (pattern, channel, message) => {
    try {
      const data = JSON.parse(message);
      const propertyId = channel.split(':')[1];

      if (pattern.includes('updates')) {
        io.to(`${ROOM_TYPES.PROPERTY}:${propertyId}`).emit('property:updated', data);
      } else if (pattern.includes('alerts')) {
        io.to(`${ROOM_TYPES.PROPERTY}:${propertyId}`).emit('property:alert', data);
      }
    } catch (err) {
      console.error('Redis pmessage error:', err);
    }
  });
}

// Helper to create message notification
async function createMessageNotification(recipientId: string, senderId: string, content: string) {
  const sender = await prisma.user.findUnique({
    where: { id: senderId },
    select: { firstName: true, lastName: true },
  });

  await prisma.notification.create({
    data: {
      userId: recipientId,
      type: 'MESSAGE',
      title: 'New Message',
      message: `${sender?.firstName || 'Someone'} sent you a message: "${content.substring(0, 50)}${content.length > 50 ? '...' : ''}"`,
      data: { senderId, preview: content.substring(0, 100) },
    },
  });
}

// Get agent dashboard real-time data
async function getAgentDashboardData(agentId: string) {
  const [
    activeListings,
    pendingLeads,
    todayShowings,
    unreadMessages,
    recentActivity,
  ] = await Promise.all([
    prisma.property.count({
      where: { agentId, status: 'ACTIVE' },
    }),
    prisma.lead.count({
      where: { agentId, status: { in: ['NEW', 'CONTACTED'] } },
    }),
    prisma.showing.count({
      where: {
        property: { agentId },
        scheduledAt: {
          gte: new Date(new Date().setHours(0, 0, 0, 0)),
          lt: new Date(new Date().setHours(23, 59, 59, 999)),
        },
        status: 'SCHEDULED',
      },
    }),
    prisma.message.count({
      where: { recipientId: agentId, readAt: null },
    }),
    prisma.activity.findMany({
      where: { agentId },
      orderBy: { createdAt: 'desc' },
      take: 10,
    }),
  ]);

  return {
    stats: {
      activeListings,
      pendingLeads,
      todayShowings,
      unreadMessages,
    },
    recentActivity,
    lastUpdated: new Date(),
  };
}

// Export types for use in other modules
export type { AuthenticatedSocket };

Index · TS
import Queue, { Job } from 'bull';
import { PrismaClient } from '@prisma/client';
import { redis } from '../utils/redis';

const prisma = new PrismaClient();

// Redis configuration for Bull
const redisConfig = {
  host: process.env.REDIS_HOST || 'localhost',
  port: parseInt(process.env.REDIS_PORT || '6379'),
  password: process.env.REDIS_PASSWORD,
};

// ============================================
// QUEUE DEFINITIONS
// ============================================

export const queues = {
  mlsSync: new Queue('mls-sync', { redis: redisConfig }),
  alertProcessor: new Queue('alert-processor', { redis: redisConfig }),
  climateUpdater: new Queue('climate-updater', { redis: redisConfig }),
  iotAggregator: new Queue('iot-aggregator', { redis: redisConfig }),
  karmicCalculator: new Queue('karmic-calculator', { redis: redisConfig }),
  tokenDistributor: new Queue('token-distributor', { redis: redisConfig }),
  listingExpiry: new Queue('listing-expiry', { redis: redisConfig }),
  performanceMetrics: new Queue('performance-metrics', { redis: redisConfig }),
  emailSender: new Queue('email-sender', { redis: redisConfig }),
  reportGenerator: new Queue('report-generator', { redis: redisConfig }),
  imageProcessor: new Queue('image-processor', { redis: redisConfig }),
  searchIndexer: new Queue('search-indexer', { redis: redisConfig }),
};

// ============================================
// MLS SYNC JOB (Every 15 minutes)
// ============================================

queues.mlsSync.process(async (job: Job) => {
  console.log('Starting MLS sync job...');
  
  try {
    // Fetch from MLS API (simulated)
    const mlsApiUrl = process.env.MLS_API_URL;
    const mlsApiKey = process.env.MLS_API_KEY;

    if (!mlsApiUrl) {
      console.log('MLS API not configured, skipping sync');
      return { skipped: true };
    }

    // Get last sync timestamp
    const lastSync = await redis.get('mls:last_sync');
    const lastSyncDate = lastSync ? new Date(lastSync) : new Date(Date.now() - 24 * 60 * 60 * 1000);

    // Fetch updated listings from MLS
    // In production, this would be an actual API call
    console.log(`Fetching MLS updates since ${lastSyncDate.toISOString()}`);

    // Process updates
    const updates = {
      created: 0,
      updated: 0,
      deleted: 0,
    };

    // Update last sync timestamp
    await redis.set('mls:last_sync', new Date().toISOString());

    return { success: true, ...updates };
  } catch (err) {
    console.error('MLS sync error:', err);
    throw err;
  }
});

// ============================================
// ALERT PROCESSOR (Instant, Daily, Weekly)
// ============================================

queues.alertProcessor.process(async (job: Job<{ frequency: string }>) => {
  const { frequency } = job.data;
  console.log(`Processing ${frequency} alerts...`);

  try {
    // Get saved searches with matching frequency
    const savedSearches = await prisma.savedSearch.findMany({
      where: {
        isActive: true,
        alertFrequency: frequency.toUpperCase(),
      },
      include: {
        user: {
          select: { id: true, email: true, firstName: true },
        },
      },
    });

    let alertsSent = 0;

    for (const search of savedSearches) {
      // Find new matches since last alert
      const filters = search.filters as any;
      const lastAlert = search.lastAlertSent || search.createdAt;

      // Build query based on filters
      const whereClause: any = {
        createdAt: { gt: lastAlert },
        isActive: true,
        status: 'ACTIVE',
      };

      if (filters.propertyType) whereClause.propertyType = filters.propertyType;
      if (filters.listingType) whereClause.listingType = filters.listingType;
      if (filters.minPrice) whereClause.price = { gte: filters.minPrice };
      if (filters.maxPrice) whereClause.price = { ...whereClause.price, lte: filters.maxPrice };
      if (filters.minBedrooms) whereClause.bedrooms = { gte: filters.minBedrooms };
      if (filters.city) whereClause.city = { contains: filters.city, mode: 'insensitive' };

      const newMatches = await prisma.property.findMany({
        where: whereClause,
        take: 10,
        orderBy: { createdAt: 'desc' },
      });

      if (newMatches.length > 0) {
        // Create notification
        await prisma.notification.create({
          data: {
            userId: search.userId,
            type: 'NEW_LISTING',
            title: `${newMatches.length} new properties match "${search.name}"`,
            message: `We found ${newMatches.length} new properties matching your saved search.`,
            data: {
              searchId: search.id,
              matchCount: newMatches.length,
              propertyIds: newMatches.map(p => p.id),
            },
          },
        });

        // Queue email
        await queues.emailSender.add({
          type: 'saved_search_alert',
          to: search.user.email,
          data: {
            userName: search.user.firstName,
            searchName: search.name,
            matchCount: newMatches.length,
            properties: newMatches.slice(0, 5),
          },
        });

        // Update last alert timestamp
        await prisma.savedSearch.update({
          where: { id: search.id },
          data: { lastAlertSent: new Date() },
        });

        alertsSent++;
      }
    }

    return { frequency, searchesProcessed: savedSearches.length, alertsSent };
  } catch (err) {
    console.error('Alert processor error:', err);
    throw err;
  }
});

// ============================================
// CLIMATE DATA UPDATER (Monthly)
// ============================================

queues.climateUpdater.process(async (job: Job) => {
  console.log('Starting climate data update...');

  try {
    // Get all properties that need climate analysis update
    const properties = await prisma.property.findMany({
      where: {
        isActive: true,
        OR: [
          { climateAnalysis: null },
          {
            climateAnalysis: {
              updatedAt: { lt: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) },
            },
          },
        ],
      },
      select: {
        id: true,
        latitude: true,
        longitude: true,
        address: true,
      },
      take: 100, // Process in batches
    });

    let updated = 0;

    for (const property of properties) {
      if (!property.latitude || !property.longitude) continue;

      // Fetch climate data from external APIs (simulated)
      const climateData = await fetchClimateData(property.latitude, property.longitude);

      await prisma.climateAnalysis.upsert({
        where: { propertyId: property.id },
        update: {
          ...climateData,
          updatedAt: new Date(),
        },
        create: {
          propertyId: property.id,
          ...climateData,
        },
      });

      updated++;
    }

    return { propertiesUpdated: updated };
  } catch (err) {
    console.error('Climate updater error:', err);
    throw err;
  }
});

async function fetchClimateData(lat: number, lng: number) {
  // In production, call actual climate APIs (NOAA, EPA, etc.)
  // This is simulated data
  return {
    overallRiskScore: Math.random() * 100,
    overallGrade: ['A', 'B', 'C', 'D'][Math.floor(Math.random() * 4)],
    floodRiskScore: Math.random() * 100,
    wildfireRiskScore: Math.random() * 100,
    hurricaneRiskScore: Math.random() * 100,
    earthquakeRiskScore: Math.random() * 100,
    airQualityIndex: Math.floor(Math.random() * 200),
    averageTemperature: 15 + Math.random() * 20,
    annualRainfall: 500 + Math.random() * 1000,
  };
}

// ============================================
// IOT DATA AGGREGATOR (Hourly)
// ============================================

queues.iotAggregator.process(async (job: Job) => {
  console.log('Aggregating IoT data...');

  try {
    const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);

    // Get all active devices
    const devices = await prisma.iotDevice.findMany({
      where: { isActive: true },
    });

    let aggregated = 0;

    for (const device of devices) {
      // Get readings from the last hour
      const readings = await prisma.sensorReading.findMany({
        where: {
          deviceId: device.id,
          timestamp: { gte: oneHourAgo },
        },
      });

      if (readings.length === 0) continue;

      // Calculate aggregates
      const values = readings.map(r => r.value);
      const avg = values.reduce((a, b) => a + b, 0) / values.length;
      const min = Math.min(...values);
      const max = Math.max(...values);

      // Store hourly aggregate
      await prisma.sensorHourlyAggregate.create({
        data: {
          deviceId: device.id,
          propertyId: device.propertyId,
          sensorType: device.sensorType,
          hour: new Date(new Date().setMinutes(0, 0, 0)),
          avgValue: avg,
          minValue: min,
          maxValue: max,
          readingCount: readings.length,
        },
      });

      // Update device stats
      await prisma.iotDevice.update({
        where: { id: device.id },
        data: {
          lastReading: avg,
          readingCount: { increment: readings.length },
        },
      });

      aggregated++;
    }

    // Clean up old raw readings (keep 7 days)
    const sevenDaysAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
    await prisma.sensorReading.deleteMany({
      where: { timestamp: { lt: sevenDaysAgo } },
    });

    return { devicesAggregated: aggregated };
  } catch (err) {
    console.error('IoT aggregator error:', err);
    throw err;
  }
});

// ============================================
// KARMIC SCORE CALCULATOR (Daily)
// ============================================

queues.karmicCalculator.process(async (job: Job) => {
  console.log('Calculating karmic scores...');

  try {
    // Get all active agents
    const agents = await prisma.agent.findMany({
      where: { isActive: true },
      include: {
        user: true,
        properties: {
          where: { status: 'SOLD' },
        },
        reviews: true,
      },
    });

    let calculated = 0;

    for (const agent of agents) {
      // Calculate karmic score based on various factors
      let karmicScore = 50; // Base score

      // Positive factors
      const avgRating = agent.reviews.length > 0
        ? agent.reviews.reduce((sum, r) => sum + r.rating, 0) / agent.reviews.length
        : 0;
      karmicScore += avgRating * 5; // Up to +25 for 5-star average

      // Response time factor
      const avgResponseTime = agent.avgResponseTimeMinutes || 60;
      if (avgResponseTime < 30) karmicScore += 10;
      else if (avgResponseTime < 60) karmicScore += 5;

      // Successful closings factor
      const closingBonus = Math.min(agent.properties.length * 2, 20);
      karmicScore += closingBonus;

      // Vastu expertise bonus
      if (agent.vastuCertified) karmicScore += 10;

      // Cap at 100
      karmicScore = Math.min(100, Math.max(0, karmicScore));

      await prisma.agent.update({
        where: { id: agent.id },
        data: {
          karmicScore,
          lastKarmicCalculation: new Date(),
        },
      });

      // Record history
      await prisma.karmicScoreHistory.create({
        data: {
          agentId: agent.id,
          score: karmicScore,
          factors: {
            avgRating,
            avgResponseTime,
            closings: agent.properties.length,
            vastuCertified: agent.vastuCertified,
          },
        },
      });

      calculated++;
    }

    return { agentsCalculated: calculated };
  } catch (err) {
    console.error('Karmic calculator error:', err);
    throw err;
  }
});

// ============================================
// TOKEN REWARDS DISTRIBUTOR (Daily)
// ============================================

queues.tokenDistributor.process(async (job: Job) => {
  console.log('Distributing token rewards...');

  try {
    // Get pending rewards
    const pendingRewards = await prisma.tokenReward.findMany({
      where: {
        status: 'PENDING',
        createdAt: { lt: new Date(Date.now() - 24 * 60 * 60 * 1000) }, // At least 24h old
      },
      include: {
        user: true,
      },
    });

    let distributed = 0;

    for (const reward of pendingRewards) {
      try {
        // In production, call blockchain contract to transfer tokens
        // await transferTokens(reward.user.walletAddress, reward.amount);

        await prisma.tokenReward.update({
          where: { id: reward.id },
          data: {
            status: 'DISTRIBUTED',
            distributedAt: new Date(),
          },
        });

        // Update user's token balance
        await prisma.user.update({
          where: { id: reward.userId },
          data: {
            tokenBalance: { increment: reward.amount },
          },
        });

        // Create notification
        await prisma.notification.create({
          data: {
            userId: reward.userId,
            type: 'TOKEN_REWARD',
            title: 'Tokens Earned!',
            message: `You've earned ${reward.amount} DHARMA tokens for ${reward.reason}`,
            data: { rewardId: reward.id, amount: reward.amount },
          },
        });

        distributed++;
      } catch (err) {
        console.error(`Failed to distribute reward ${reward.id}:`, err);
        await prisma.tokenReward.update({
          where: { id: reward.id },
          data: { status: 'FAILED' },
        });
      }
    }

    return { rewardsDistributed: distributed };
  } catch (err) {
    console.error('Token distributor error:', err);
    throw err;
  }
});

// ============================================
// LISTING EXPIRY HANDLER
// ============================================

queues.listingExpiry.process(async (job: Job) => {
  console.log('Processing expired listings...');

  try {
    const now = new Date();

    // Find expired listings
    const expiredListings = await prisma.property.findMany({
      where: {
        isActive: true,
        listingExpiresAt: { lt: now },
      },
      include: {
        agent: { include: { user: true } },
        owner: true,
      },
    });

    let processed = 0;

    for (const listing of expiredListings) {
      // Mark as expired
      await prisma.property.update({
        where: { id: listing.id },
        data: {
          status: 'EXPIRED',
          isActive: false,
        },
      });

      // Notify agent
      if (listing.agentId) {
        await prisma.notification.create({
          data: {
            userId: listing.agentId,
            type: 'SYSTEM',
            title: 'Listing Expired',
            message: `Your listing at ${listing.address} has expired. Renew it to keep it active.`,
            data: { propertyId: listing.id },
          },
        });
      }

      // Notify owner
      if (listing.ownerId && listing.ownerId !== listing.agentId) {
        await prisma.notification.create({
          data: {
            userId: listing.ownerId,
            type: 'SYSTEM',
            title: 'Property Listing Expired',
            message: `The listing for ${listing.address} has expired.`,
            data: { propertyId: listing.id },
          },
        });
      }

      processed++;
    }

    // Also handle featured listings that expired
    await prisma.property.updateMany({
      where: {
        isFeatured: true,
        featuredUntil: { lt: now },
      },
      data: {
        isFeatured: false,
        featuredUntil: null,
      },
    });

    return { expiredListings: processed };
  } catch (err) {
    console.error('Listing expiry error:', err);
    throw err;
  }
});

// ============================================
// PERFORMANCE METRICS CALCULATOR (Monthly)
// ============================================

queues.performanceMetrics.process(async (job: Job) => {
  console.log('Calculating performance metrics...');

  try {
    const now = new Date();
    const monthStart = new Date(now.getFullYear(), now.getMonth(), 1);
    const lastMonthStart = new Date(now.getFullYear(), now.getMonth() - 1, 1);
    const lastMonthEnd = new Date(now.getFullYear(), now.getMonth(), 0);

    // Calculate agent performance
    const agents = await prisma.agent.findMany({
      where: { isActive: true },
      include: {
        properties: {
          where: {
            soldAt: {
              gte: lastMonthStart,
              lt: monthStart,
            },
          },
        },
        leads: {
          where: {
            createdAt: {
              gte: lastMonthStart,
              lt: monthStart,
            },
          },
        },
        reviews: {
          where: {
            createdAt: {
              gte: lastMonthStart,
              lt: monthStart,
            },
          },
        },
      },
    });

    for (const agent of agents) {
      const totalSales = agent.properties.reduce((sum, p) => sum + (p.soldPrice || 0), 0);
      const avgSalePrice = agent.properties.length > 0 ? totalSales / agent.properties.length : 0;
      const conversionRate = agent.leads.length > 0
        ? (agent.properties.length / agent.leads.length) * 100
        : 0;
      const avgRating = agent.reviews.length > 0
        ? agent.reviews.reduce((sum, r) => sum + r.rating, 0) / agent.reviews.length
        : 0;

      await prisma.agentPerformance.create({
        data: {
          agentId: agent.id,
          month: lastMonthStart,
          salesCount: agent.properties.length,
          totalSalesVolume: totalSales,
          avgSalePrice,
          leadsGenerated: agent.leads.length,
          conversionRate,
          avgRating,
          reviewCount: agent.reviews.length,
        },
      });
    }

    // Calculate market metrics
    const allSales = await prisma.property.findMany({
      where: {
        status: 'SOLD',
        soldAt: {
          gte: lastMonthStart,
          lt: monthStart,
        },
      },
      select: {
        soldPrice: true,
        price: true,
        daysOnMarket: true,
        propertyType: true,
        city: true,
      },
    });

    // Group by city and property type
    const marketMetrics: Record<string, any> = {};
    
    for (const sale of allSales) {
      const key = `${sale.city}-${sale.propertyType}`;
      if (!marketMetrics[key]) {
        marketMetrics[key] = {
          city: sale.city,
          propertyType: sale.propertyType,
          sales: [],
        };
      }
      marketMetrics[key].sales.push(sale);
    }

    for (const [key, data] of Object.entries(marketMetrics)) {
      const sales = data.sales;
      const avgPrice = sales.reduce((s: number, p: any) => s + (p.soldPrice || 0), 0) / sales.length;
      const avgDaysOnMarket = sales.reduce((s: number, p: any) => s + (p.daysOnMarket || 0), 0) / sales.length;
      const medianPrice = sales.sort((a: any, b: any) => (a.soldPrice || 0) - (b.soldPrice || 0))[Math.floor(sales.length / 2)]?.soldPrice || 0;

      await prisma.marketMetrics.create({
        data: {
          month: lastMonthStart,
          city: data.city,
          propertyType: data.propertyType,
          avgPrice,
          medianPrice,
          totalSales: sales.length,
          avgDaysOnMarket,
        },
      });
    }

    return { agentsProcessed: agents.length, marketsAnalyzed: Object.keys(marketMetrics).length };
  } catch (err) {
    console.error('Performance metrics error:', err);
    throw err;
  }
});

// ============================================
// EMAIL SENDER
// ============================================

queues.emailSender.process(async (job: Job<{ type: string; to: string; data: any }>) => {
  const { type, to, data } = job.data;
  console.log(`Sending ${type} email to ${to}...`);

  try {
    // In production, use actual email service (SendGrid, SES, etc.)
    // await sendEmail({ type, to, data });
    
    console.log(`Email sent: ${type} to ${to}`);
    return { sent: true };
  } catch (err) {
    console.error('Email send error:', err);
    throw err;
  }
});

// ============================================
// SEARCH INDEXER
// ============================================

queues.searchIndexer.process(async (job: Job<{ propertyId: string; action: string }>) => {
  const { propertyId, action } = job.data;
  console.log(`Indexing property ${propertyId} (${action})...`);

  try {
    // In production, update Elasticsearch/OpenSearch index
    // const property = await prisma.property.findUnique({ where: { id: propertyId } });
    // await esClient.index({ index: 'properties', id: propertyId, body: property });
    
    return { indexed: true };
  } catch (err) {
    console.error('Search indexer error:', err);
    throw err;
  }
});

// ============================================
// SCHEDULE RECURRING JOBS
// ============================================

export async function scheduleRecurringJobs() {
  // MLS Sync - Every 15 minutes
  await queues.mlsSync.add({}, { repeat: { cron: '*/15 * * * *' } });

  // Instant Alerts - Every minute (check for instant alerts)
  await queues.alertProcessor.add({ frequency: 'INSTANT' }, { repeat: { cron: '* * * * *' } });

  // Daily Alerts - Every day at 8 AM
  await queues.alertProcessor.add({ frequency: 'DAILY' }, { repeat: { cron: '0 8 * * *' } });

  // Weekly Alerts - Every Monday at 9 AM
  await queues.alertProcessor.add({ frequency: 'WEEKLY' }, { repeat: { cron: '0 9 * * 1' } });

  // Climate Update - First of every month at 2 AM
  await queues.climateUpdater.add({}, { repeat: { cron: '0 2 1 * *' } });

  // IoT Aggregator - Every hour
  await queues.iotAggregator.add({}, { repeat: { cron: '0 * * * *' } });

  // Karmic Calculator - Every day at 3 AM
  await queues.karmicCalculator.add({}, { repeat: { cron: '0 3 * * *' } });

  // Token Distributor - Every day at 4 AM
  await queues.tokenDistributor.add({}, { repeat: { cron: '0 4 * * *' } });

  // Listing Expiry - Every hour
  await queues.listingExpiry.add({}, { repeat: { cron: '0 * * * *' } });

  // Performance Metrics - First of every month at 1 AM
  await queues.performanceMetrics.add({}, { repeat: { cron: '0 1 1 * *' } });

  console.log('Recurring jobs scheduled');
}

// ============================================
// QUEUE MONITORING
// ============================================

export async function getQueueStats() {
  const stats: Record<string, any> = {};

  for (const [name, queue] of Object.entries(queues)) {
    const [waiting, active, completed, failed] = await Promise.all([
      queue.getWaitingCount(),
      queue.getActiveCount(),
      queue.getCompletedCount(),
      queue.getFailedCount(),
    ]);

    stats[name] = { waiting, active, completed, failed };
  }

  return stats;
}

// Clean up completed jobs (run periodically)
export async function cleanupJobs() {
  const oneWeekAgo = Date.now() - 7 * 24 * 60 * 60 * 1000;

  for (const queue of Object.values(queues)) {
    await queue.clean(oneWeekAgo, 'completed');
    await queue.clean(oneWeekAgo, 'failed');
  }
}














Openhouses · TS
import { Router, Request, Response } from 'express';
import { z } from 'zod';
import { prisma } from '../utils/prisma';
import { redis } from '../utils/redis';
import { authenticate, optionalAuthenticate, requireAgent, AuthRequest } from '../middleware/auth';
import { asyncHandler } from '../middleware/errorHandler';
import { v4 as uuidv4 } from 'uuid';

const router = Router();

// ============================================================================
// SCHEMAS
// ============================================================================

const CreateOpenHouseSchema = z.object({
  propertyId: z.string().uuid(),
  type: z.enum(['IN_PERSON', 'VIRTUAL', 'HYBRID']),
  startTime: z.string().datetime(),
  endTime: z.string().datetime(),
  title: z.string().max(200).optional(),
  description: z.string().max(2000).optional(),
  maxAttendees: z.number().int().min(1).max(500).optional(),
  requiresRSVP: z.boolean().default(false),
  isPrivate: z.boolean().default(false),
  // Virtual meeting details
  virtualPlatform: z.enum(['ZOOM', 'GOOGLE_MEET', 'TEAMS', 'CUSTOM']).optional(),
  virtualMeetingUrl: z.string().url().optional(),
  virtualMeetingId: z.string().optional(),
  virtualMeetingPassword: z.string().optional(),
  // In-person details
  parkingInstructions: z.string().max(500).optional(),
  entryInstructions: z.string().max(500).optional(),
  refreshmentsProvided: z.boolean().default(false),
  // Vastu-auspicious timing
  muhurat: z.object({
    nakshatra: z.string().optional(),
    tithi: z.string().optional(),
    isAuspicious: z.boolean().optional(),
  }).optional(),
  // Features
  features: z.array(z.string()).optional(), // e.g., ['3D_TOUR', 'LIVE_QA', 'REFRESHMENTS']
  tags: z.array(z.string()).optional(),
});

const UpdateOpenHouseSchema = CreateOpenHouseSchema.partial();

const RSVPSchema = z.object({
  attendeeCount: z.number().int().min(1).max(10).default(1),
  questions: z.string().max(1000).optional(),
  dietaryRestrictions: z.string().max(200).optional(),
  accessibilityNeeds: z.string().max(200).optional(),
  interestedInPrivateShowing: z.boolean().default(false),
});

const QuestionSchema = z.object({
  question: z.string().min(1).max(1000),
  isAnonymous: z.boolean().default(false),
});

const FeedbackSchema = z.object({
  rating: z.number().min(1).max(5),
  overallImpression: z.enum(['VERY_NEGATIVE', 'NEGATIVE', 'NEUTRAL', 'POSITIVE', 'VERY_POSITIVE']),
  likedAspects: z.array(z.string()).optional(),
  dislikedAspects: z.array(z.string()).optional(),
  comments: z.string().max(2000).optional(),
  wouldRecommend: z.boolean().optional(),
  interestedInProperty: z.enum(['NOT_INTERESTED', 'SOMEWHAT_INTERESTED', 'VERY_INTERESTED', 'READY_TO_OFFER']).optional(),
  pricePerception: z.enum(['TOO_LOW', 'FAIR', 'SLIGHTLY_HIGH', 'TOO_HIGH']).optional(),
});

// ============================================================================
// OPEN HOUSE CRUD
// ============================================================================

// Create open house
router.post('/', authenticate, requireAgent, asyncHandler(async (req: AuthRequest, res: Response) => {
  const data = CreateOpenHouseSchema.parse(req.body);
  
  // Verify property ownership
  const property = await prisma.property.findFirst({
    where: {
      id: data.propertyId,
      agentId: req.user!.agentId,
    },
  });
  
  if (!property) {
    return res.status(403).json({ error: 'Property not found or access denied' });
  }
  
  // Validate times
  const startTime = new Date(data.startTime);
  const endTime = new Date(data.endTime);
  
  if (startTime >= endTime) {
    return res.status(400).json({ error: 'End time must be after start time' });
  }
  
  if (startTime < new Date()) {
    return res.status(400).json({ error: 'Start time must be in the future' });
  }
  
  // Check for conflicting open houses
  const conflicting = await prisma.openHouse.findFirst({
    where: {
      propertyId: data.propertyId,
      status: { in: ['SCHEDULED', 'LIVE'] },
      OR: [
        { startTime: { lte: endTime }, endTime: { gte: startTime } },
      ],
    },
  });
  
  if (conflicting) {
    return res.status(400).json({ error: 'Conflicting open house already scheduled' });
  }
  
  // Generate virtual meeting link if needed
  let virtualDetails = {};
  if (data.type !== 'IN_PERSON' && !data.virtualMeetingUrl) {
    // Generate a custom meeting room
    virtualDetails = {
      virtualPlatform: 'CUSTOM',
      virtualMeetingId: uuidv4(),
      virtualMeetingUrl: `${process.env.APP_URL}/open-house/virtual/${uuidv4()}`,
    };
  }
  
  const openHouse = await prisma.openHouse.create({
    data: {
      ...data,
      ...virtualDetails,
      agentId: req.user!.agentId!,
      status: 'SCHEDULED',
    },
    include: {
      property: {
        select: {
          id: true,
          title: true,
          address: true,
          city: true,
          state: true,
          price: true,
          photos: { take: 1 },
        },
      },
      agent: {
        select: {
          id: true,
          user: { select: { firstName: true, lastName: true } },
        },
      },
    },
  });
  
  // Schedule reminder notifications
  await prisma.scheduledNotification.createMany({
    data: [
      {
        openHouseId: openHouse.id,
        type: '24_HOUR_REMINDER',
        scheduledFor: new Date(startTime.getTime() - 24 * 60 * 60 * 1000),
      },
      {
        openHouseId: openHouse.id,
        type: '1_HOUR_REMINDER',
        scheduledFor: new Date(startTime.getTime() - 60 * 60 * 1000),
      },
    ],
  });
  
  // Notify users who favorited this property
  const favorites = await prisma.favorite.findMany({
    where: { propertyId: data.propertyId },
    select: { userId: true },
  });
  
  if (favorites.length > 0) {
    await prisma.notification.createMany({
      data: favorites.map(f => ({
        userId: f.userId,
        type: 'OPEN_HOUSE_SCHEDULED',
        title: 'Open House Scheduled',
        message: `An open house has been scheduled for ${property.title || property.address}`,
        data: { openHouseId: openHouse.id, propertyId: property.id },
      })),
    });
  }
  
  res.status(201).json(openHouse);
}));

// List open houses
router.get('/', optionalAuthenticate, asyncHandler(async (req: AuthRequest, res: Response) => {
  const {
    propertyId,
    agentId,
    type,
    status,
    city,
    startDate,
    endDate,
    upcoming,
    past,
    limit = '20',
    offset = '0',
  } = req.query;
  
  const where: any = {};
  
  if (propertyId) where.propertyId = propertyId;
  if (agentId) where.agentId = agentId;
  if (type) where.type = type;
  if (status) where.status = status;
  if (city) where.property = { city: { contains: city as string, mode: 'insensitive' } };
  
  if (startDate || endDate) {
    where.startTime = {};
    if (startDate) where.startTime.gte = new Date(startDate as string);
    if (endDate) where.startTime.lte = new Date(endDate as string);
  }
  
  if (upcoming === 'true') {
    where.startTime = { gte: new Date() };
    where.status = { in: ['SCHEDULED', 'LIVE'] };
  }
  
  if (past === 'true') {
    where.endTime = { lt: new Date() };
  }
  
  // Hide private open houses for non-authenticated users
  if (!req.user) {
    where.isPrivate = false;
  }
  
  const [openHouses, total] = await Promise.all([
    prisma.openHouse.findMany({
      where,
      include: {
        property: {
          select: {
            id: true,
            title: true,
            address: true,
            city: true,
            state: true,
            price: true,
            bedrooms: true,
            bathrooms: true,
            squareFeet: true,
            photos: { take: 1 },
          },
        },
        agent: {
          select: {
            id: true,
            user: { select: { firstName: true, lastName: true, avatar: true } },
          },
        },
        _count: { select: { rsvps: true, attendances: true } },
      },
      orderBy: { startTime: 'asc' },
      take: parseInt(limit as string),
      skip: parseInt(offset as string),
    }),
    prisma.openHouse.count({ where }),
  ]);
  
  res.json({
    openHouses,
    total,
    limit: parseInt(limit as string),
    offset: parseInt(offset as string),
  });
}));

// Get open house details
router.get('/:id', optionalAuthenticate, asyncHandler(async (req: AuthRequest, res: Response) => {
  const { id } = req.params;
  
  const openHouse = await prisma.openHouse.findUnique({
    where: { id },
    include: {
      property: {
        include: {
          photos: true,
          vastu: { select: { overallScore: true, isCompliant: true } },
          climate: { select: { overallRiskScore: true } },
        },
      },
      agent: {
        select: {
          id: true,
          user: { select: { firstName: true, lastName: true, avatar: true, email: true, phone: true } },
          licenseNumber: true,
          specializations: true,
          karmicScore: true,
        },
      },
      rsvps: req.user ? {
        where: { userId: req.user.id },
        take: 1,
      } : false,
      questions: {
        where: { isApproved: true },
        orderBy: { upvotes: 'desc' },
        take: 20,
      },
      _count: {
        select: { rsvps: true, attendances: true, questions: true },
      },
    },
  });
  
  if (!openHouse) {
    return res.status(404).json({ error: 'Open house not found' });
  }
  
  // Check if private
  if (openHouse.isPrivate && !req.user) {
    return res.status(403).json({ error: 'This is a private open house' });
  }
  
  // Get live visitor count if currently active
  let liveVisitors = 0;
  if (openHouse.status === 'LIVE') {
    liveVisitors = await redis.scard(`openhouse:${id}:visitors`);
  }
  
  res.json({
    ...openHouse,
    liveVisitors,
    userRSVP: openHouse.rsvps?.[0] || null,
  });
}));

// Update open house
router.put('/:id', authenticate, requireAgent, asyncHandler(async (req: AuthRequest, res: Response) => {
  const { id } = req.params;
  const data = UpdateOpenHouseSchema.parse(req.body);
  
  const openHouse = await prisma.openHouse.findFirst({
    where: {
      id,
      agentId: req.user!.agentId,
      status: { in: ['SCHEDULED'] }, // Can only update scheduled ones
    },
  });
  
  if (!openHouse) {
    return res.status(404).json({ error: 'Open house not found or cannot be modified' });
  }
  
  const updated = await prisma.openHouse.update({
    where: { id },
    data,
    include: {
      property: { select: { id: true, title: true, address: true } },
    },
  });
  
  // Notify RSVPed attendees of changes
  if (data.startTime || data.endTime) {
    const rsvps = await prisma.openHouseRSVP.findMany({
      where: { openHouseId: id, status: 'CONFIRMED' },
      select: { userId: true },
    });
    
    if (rsvps.length > 0) {
      await prisma.notification.createMany({
        data: rsvps.map(r => ({
          userId: r.userId,
          type: 'OPEN_HOUSE_UPDATED',
          title: 'Open House Time Changed',
          message: `The open house for ${updated.property.title || updated.property.address} has been rescheduled`,
          data: { openHouseId: id },
        })),
      });
    }
  }
  
  res.json(updated);
}));

// Cancel open house
router.post('/:id/cancel', authenticate, requireAgent, asyncHandler(async (req: AuthRequest, res: Response) => {
  const { id } = req.params;
  const { reason } = req.body;
  
  const openHouse = await prisma.openHouse.findFirst({
    where: {
      id,
      agentId: req.user!.agentId,
      status: { in: ['SCHEDULED', 'LIVE'] },
    },
    include: {
      property: { select: { title: true, address: true } },
    },
  });
  
  if (!openHouse) {
    return res.status(404).json({ error: 'Open house not found or already completed' });
  }
  
  await prisma.openHouse.update({
    where: { id },
    data: {
      status: 'CANCELLED',
      cancellationReason: reason,
      cancelledAt: new Date(),
    },
  });
  
  // Notify all RSVPed attendees
  const rsvps = await prisma.openHouseRSVP.findMany({
    where: { openHouseId: id },
    select: { userId: true },
  });
  
  if (rsvps.length > 0) {
    await prisma.notification.createMany({
      data: rsvps.map(r => ({
        userId: r.userId,
        type: 'OPEN_HOUSE_CANCELLED',
        title: 'Open House Cancelled',
        message: `The open house for ${openHouse.property.title || openHouse.property.address} has been cancelled${reason ? `: ${reason}` : ''}`,
        data: { openHouseId: id },
        priority: 'HIGH',
      })),
    });
  }
  
  res.json({ success: true, message: 'Open house cancelled' });
}));

// Start open house (go live)
router.post('/:id/start', authenticate, requireAgent, asyncHandler(async (req: AuthRequest, res: Response) => {
  const { id } = req.params;
  
  const openHouse = await prisma.openHouse.findFirst({
    where: {
      id,
      agentId: req.user!.agentId,
      status: 'SCHEDULED',
    },
  });
  
  if (!openHouse) {
    return res.status(404).json({ error: 'Open house not found or not in scheduled status' });
  }
  
  await prisma.openHouse.update({
    where: { id },
    data: {
      status: 'LIVE',
      actualStartTime: new Date(),
    },
  });
  
  // Initialize Redis tracking
  await redis.del(`openhouse:${id}:visitors`);
  await redis.set(`openhouse:${id}:status`, 'LIVE', 'EX', 86400);
  
  // Notify RSVPed attendees
  const rsvps = await prisma.openHouseRSVP.findMany({
    where: { openHouseId: id, status: 'CONFIRMED' },
    select: { userId: true },
  });
  
  if (rsvps.length > 0) {
    await prisma.notification.createMany({
      data: rsvps.map(r => ({
        userId: r.userId,
        type: 'OPEN_HOUSE_STARTED',
        title: 'Open House is Now Live!',
        message: 'The open house you RSVPed to is now live. Join now!',
        data: { openHouseId: id },
        priority: 'URGENT',
      })),
    });
  }
  
  res.json({ success: true, message: 'Open house is now live' });
}));

// End open house
router.post('/:id/end', authenticate, requireAgent, asyncHandler(async (req: AuthRequest, res: Response) => {
  const { id } = req.params;
  
  const openHouse = await prisma.openHouse.findFirst({
    where: {
      id,
      agentId: req.user!.agentId,
      status: 'LIVE',
    },
  });
  
  if (!openHouse) {
    return res.status(404).json({ error: 'Open house not found or not live' });
  }
  
  // Get final attendance count
  const attendanceCount = await prisma.openHouseAttendance.count({
    where: { openHouseId: id },
  });
  
  await prisma.openHouse.update({
    where: { id },
    data: {
      status: 'COMPLETED',
      actualEndTime: new Date(),
      actualAttendees: attendanceCount,
    },
  });
  
  // Clean up Redis
  await redis.del(`openhouse:${id}:visitors`);
  await redis.del(`openhouse:${id}:status`);
  
  // Send feedback request to attendees
  const attendances = await prisma.openHouseAttendance.findMany({
    where: { openHouseId: id },
    select: { userId: true },
  });
  
  if (attendances.length > 0) {
    await prisma.notification.createMany({
      data: attendances.map(a => ({
        userId: a.userId,
        type: 'FEEDBACK_REQUEST',
        title: 'How was the open house?',
        message: 'Please share your feedback about the open house you attended',
        data: { openHouseId: id },
      })),
    });
  }
  
  res.json({ success: true, message: 'Open house ended', attendanceCount });
}));

// ============================================================================
// RSVP MANAGEMENT
// ============================================================================

// RSVP to open house
router.post('/:id/rsvp', authenticate, asyncHandler(async (req: AuthRequest, res: Response) => {
  const { id } = req.params;
  const data = RSVPSchema.parse(req.body);
  
  const openHouse = await prisma.openHouse.findUnique({
    where: { id },
    include: {
      _count: { select: { rsvps: true } },
      property: { select: { title: true, address: true } },
    },
  });
  
  if (!openHouse) {
    return res.status(404).json({ error: 'Open house not found' });
  }
  
  if (openHouse.status !== 'SCHEDULED') {
    return res.status(400).json({ error: 'Cannot RSVP to this open house' });
  }
  
  // Check capacity
  if (openHouse.maxAttendees && openHouse._count.rsvps >= openHouse.maxAttendees) {
    return res.status(400).json({ error: 'Open house is at capacity' });
  }
  
  // Check for existing RSVP
  const existing = await prisma.openHouseRSVP.findUnique({
    where: {
      openHouseId_userId: {
        openHouseId: id,
        userId: req.user!.id,
      },
    },
  });
  
  if (existing) {
    return res.status(400).json({ error: 'You have already RSVPed to this open house' });
  }
  
  const rsvp = await prisma.openHouseRSVP.create({
    data: {
      openHouseId: id,
      userId: req.user!.id,
      ...data,
      status: 'CONFIRMED',
    },
  });
  
  // Create lead if user interested in private showing
  if (data.interestedInPrivateShowing) {
    await prisma.lead.create({
      data: {
        propertyId: openHouse.propertyId,
        agentId: openHouse.agentId,
        userId: req.user!.id,
        source: 'OPEN_HOUSE',
        status: 'NEW',
        notes: `Interested in private showing after open house. Questions: ${data.questions || 'None'}`,
      },
    });
  }
  
  // Notify agent
  await prisma.notification.create({
    data: {
      userId: openHouse.agentId,
      type: 'NEW_RSVP',
      title: 'New Open House RSVP',
      message: `Someone RSVPed to your open house for ${openHouse.property.title || openHouse.property.address}`,
      data: { openHouseId: id, rsvpId: rsvp.id },
    },
  });
  
  res.status(201).json(rsvp);
}));

// Cancel RSVP
router.delete('/:id/rsvp', authenticate, asyncHandler(async (req: AuthRequest, res: Response) => {
  const { id } = req.params;
  
  const rsvp = await prisma.openHouseRSVP.findUnique({
    where: {
      openHouseId_userId: {
        openHouseId: id,
        userId: req.user!.id,
      },
    },
  });
  
  if (!rsvp) {
    return res.status(404).json({ error: 'RSVP not found' });
  }
  
  await prisma.openHouseRSVP.update({
    where: { id: rsvp.id },
    data: { status: 'CANCELLED' },
  });
  
  res.json({ success: true, message: 'RSVP cancelled' });
}));

// Get RSVPs for open house (agent only)
router.get('/:id/rsvps', authenticate, requireAgent, asyncHandler(async (req: AuthRequest, res: Response) => {
  const { id } = req.params;
  
  const openHouse = await prisma.openHouse.findFirst({
    where: {
      id,
      agentId: req.user!.agentId,
    },
  });
  
  if (!openHouse) {
    return res.status(403).json({ error: 'Access denied' });
  }
  
  const rsvps = await prisma.openHouseRSVP.findMany({
    where: { openHouseId: id },
    include: {
      user: {
        select: {
          id: true,
          firstName: true,
          lastName: true,
          email: true,
          phone: true,
        },
      },
    },
    orderBy: { createdAt: 'asc' },
  });
  
  const stats = {
    total: rsvps.length,
    confirmed: rsvps.filter(r => r.status === 'CONFIRMED').length,
    cancelled: rsvps.filter(r => r.status === 'CANCELLED').length,
    totalAttendees: rsvps.reduce((sum, r) => sum + r.attendeeCount, 0),
    interestedInPrivateShowing: rsvps.filter(r => r.interestedInPrivateShowing).length,
  };
  
  res.json({ rsvps, stats });
}));

// ============================================================================
// ATTENDANCE & CHECK-IN
// ============================================================================

// Check in to open house
router.post('/:id/checkin', authenticate, asyncHandler(async (req: AuthRequest, res: Response) => {
  const { id } = req.params;
  const { checkInMethod = 'APP' } = req.body;
  
  const openHouse = await prisma.openHouse.findUnique({
    where: { id },
  });
  
  if (!openHouse) {
    return res.status(404).json({ error: 'Open house not found' });
  }
  
  if (openHouse.status !== 'LIVE') {
    return res.status(400).json({ error: 'Open house is not currently live' });
  }
  
  // Check for existing attendance
  const existing = await prisma.openHouseAttendance.findUnique({
    where: {
      openHouseId_userId: {
        openHouseId: id,
        userId: req.user!.id,
      },
    },
  });
  
  if (existing) {
    return res.status(400).json({ error: 'Already checked in' });
  }
  
  const attendance = await prisma.openHouseAttendance.create({
    data: {
      openHouseId: id,
      userId: req.user!.id,
      checkInTime: new Date(),
      checkInMethod,
    },
  });
  
  // Update RSVP if exists
  await prisma.openHouseRSVP.updateMany({
    where: {
      openHouseId: id,
      userId: req.user!.id,
    },
    data: { attended: true },
  });
  
  // Track in Redis for real-time
  await redis.sadd(`openhouse:${id}:visitors`, req.user!.id);
  
  res.status(201).json(attendance);
}));

// Check out from open house
router.post('/:id/checkout', authenticate, asyncHandler(async (req: AuthRequest, res: Response) => {
  const { id } = req.params;
  
  const attendance = await prisma.openHouseAttendance.findUnique({
    where: {
      openHouseId_userId: {
        openHouseId: id,
        userId: req.user!.id,
      },
    },
  });
  
  if (!attendance) {
    return res.status(404).json({ error: 'Not checked in' });
  }
  
  const checkOutTime = new Date();
  const duration = Math.round((checkOutTime.getTime() - attendance.checkInTime.getTime()) / 60000);
  
  await prisma.openHouseAttendance.update({
    where: { id: attendance.id },
    data: {
      checkOutTime,
      duration,
    },
  });
  
  // Remove from Redis
  await redis.srem(`openhouse:${id}:visitors`, req.user!.id);
  
  res.json({ success: true, duration });
}));

// Get attendance list (agent only)
router.get('/:id/attendance', authenticate, requireAgent, asyncHandler(async (req: AuthRequest, res: Response) => {
  const { id } = req.params;
  
  const openHouse = await prisma.openHouse.findFirst({
    where: {
      id,
      agentId: req.user!.agentId,
    },
  });
  
  if (!openHouse) {
    return res.status(403).json({ error: 'Access denied' });
  }
  
  const attendances = await prisma.openHouseAttendance.findMany({
    where: { openHouseId: id },
    include: {
      user: {
        select: {
          id: true,
          firstName: true,
          lastName: true,
          email: true,
          phone: true,
        },
      },
      feedback: true,
    },
    orderBy: { checkInTime: 'asc' },
  });
  
  const stats = {
    total: attendances.length,
    averageDuration: attendances.filter(a => a.duration).reduce((sum, a) => sum + (a.duration || 0), 0) / attendances.length || 0,
    withFeedback: attendances.filter(a => a.feedback).length,
    currentlyPresent: await redis.scard(`openhouse:${id}:visitors`),
  };
  
  res.json({ attendances, stats });
}));

// ============================================================================
// QUESTIONS & Q&A
// ============================================================================

// Ask a question
router.post('/:id/questions', authenticate, asyncHandler(async (req: AuthRequest, res: Response) => {
  const { id } = req.params;
  const data = QuestionSchema.parse(req.body);
  
  const openHouse = await prisma.openHouse.findUnique({
    where: { id },
  });
  
  if (!openHouse) {
    return res.status(404).json({ error: 'Open house not found' });
  }
  
  const question = await prisma.openHouseQuestion.create({
    data: {
      openHouseId: id,
      userId: req.user!.id,
      question: data.question,
      isAnonymous: data.isAnonymous,
      isApproved: true, // Auto-approve, agent can hide later
    },
    include: {
      user: data.isAnonymous ? false : {
        select: { firstName: true, lastName: true },
      },
    },
  });
  
  // Broadcast via WebSocket if open house is live
  if (openHouse.status === 'LIVE') {
    await redis.publish(`openhouse:${id}:questions`, JSON.stringify(question));
  }
  
  res.status(201).json(question);
}));

// Get questions
router.get('/:id/questions', optionalAuthenticate, asyncHandler(async (req: AuthRequest, res: Response) => {
  const { id } = req.params;
  const { answered, limit = '50' } = req.query;
  
  const where: any = {
    openHouseId: id,
    isApproved: true,
  };
  
  if (answered === 'true') where.isAnswered = true;
  if (answered === 'false') where.isAnswered = false;
  
  const questions = await prisma.openHouseQuestion.findMany({
    where,
    include: {
      user: {
        select: { firstName: true, lastName: true },
      },
    },
    orderBy: [{ upvotes: 'desc' }, { createdAt: 'asc' }],
    take: parseInt(limit as string),
  });
  
  // Hide user info for anonymous questions
  const processed = questions.map(q => ({
    ...q,
    user: q.isAnonymous ? null : q.user,
  }));
  
  res.json(processed);
}));

// Upvote a question
router.post('/:id/questions/:questionId/upvote', authenticate, asyncHandler(async (req: AuthRequest, res: Response) => {
  const { questionId } = req.params;
  
  // Check for existing upvote
  const existing = await prisma.questionUpvote.findUnique({
    where: {
      questionId_userId: {
        questionId,
        userId: req.user!.id,
      },
    },
  });
  
  if (existing) {
    // Remove upvote
    await prisma.questionUpvote.delete({ where: { id: existing.id } });
    await prisma.openHouseQuestion.update({
      where: { id: questionId },
      data: { upvotes: { decrement: 1 } },
    });
    return res.json({ upvoted: false });
  }
  
  // Add upvote
  await prisma.questionUpvote.create({
    data: { questionId, userId: req.user!.id },
  });
  await prisma.openHouseQuestion.update({
    where: { id: questionId },
    data: { upvotes: { increment: 1 } },
  });
  
  res.json({ upvoted: true });
}));

// Answer a question (agent only)
router.post('/:id/questions/:questionId/answer', authenticate, requireAgent, asyncHandler(async (req: AuthRequest, res: Response) => {
  const { id, questionId } = req.params;
  const { answer } = req.body;
  
  const openHouse = await prisma.openHouse.findFirst({
    where: {
      id,
      agentId: req.user!.agentId,
    },
  });
  
  if (!openHouse) {
    return res.status(403).json({ error: 'Access denied' });
  }
  
  const question = await prisma.openHouseQuestion.update({
    where: { id: questionId },
    data: {
      answer,
      isAnswered: true,
      answeredAt: new Date(),
    },
  });
  
  // Broadcast via WebSocket if live
  if (openHouse.status === 'LIVE') {
    await redis.publish(`openhouse:${id}:answers`, JSON.stringify(question));
  }
  
  res.json(question);
}));

// ============================================================================
// FEEDBACK
// ============================================================================

// Submit feedback
router.post('/:id/feedback', authenticate, asyncHandler(async (req: AuthRequest, res: Response) => {
  const { id } = req.params;
  const data = FeedbackSchema.parse(req.body);
  
  // Check user attended
  const attendance = await prisma.openHouseAttendance.findUnique({
    where: {
      openHouseId_userId: {
        openHouseId: id,
        userId: req.user!.id,
      },
    },
  });
  
  if (!attendance) {
    return res.status(403).json({ error: 'You must attend the open house to leave feedback' });
  }
  
  // Check for existing feedback
  const existing = await prisma.openHouseFeedback.findFirst({
    where: {
      openHouseId: id,
      userId: req.user!.id,
    },
  });
  
  if (existing) {
    return res.status(400).json({ error: 'You have already submitted feedback' });
  }
  
  const feedback = await prisma.openHouseFeedback.create({
    data: {
      openHouseId: id,
      userId: req.user!.id,
      attendanceId: attendance.id,
      ...data,
    },
  });
  
  // Create lead if very interested or ready to offer
  if (data.interestedInProperty === 'VERY_INTERESTED' || data.interestedInProperty === 'READY_TO_OFFER') {
    const openHouse = await prisma.openHouse.findUnique({
      where: { id },
    });
    
    if (openHouse) {
      await prisma.lead.create({
        data: {
          propertyId: openHouse.propertyId,
          agentId: openHouse.agentId,
          userId: req.user!.id,
          source: 'OPEN_HOUSE',
          status: data.interestedInProperty === 'READY_TO_OFFER' ? 'HOT' : 'WARM',
          notes: `From open house feedback: ${data.interestedInProperty}. Comments: ${data.comments || 'None'}`,
          priority: data.interestedInProperty === 'READY_TO_OFFER' ? 'HIGH' : 'MEDIUM',
        },
      });
    }
  }
  
  res.status(201).json(feedback);
}));

// Get feedback summary (agent only)
router.get('/:id/feedback', authenticate, requireAgent, asyncHandler(async (req: AuthRequest, res: Response) => {
  const { id } = req.params;
  
  const openHouse = await prisma.openHouse.findFirst({
    where: {
      id,
      agentId: req.user!.agentId,
    },
  });
  
  if (!openHouse) {
    return res.status(403).json({ error: 'Access denied' });
  }
  
  const feedback = await prisma.openHouseFeedback.findMany({
    where: { openHouseId: id },
    include: {
      user: {
        select: { firstName: true, lastName: true },
      },
    },
    orderBy: { createdAt: 'desc' },
  });
  
  // Calculate statistics
  const stats = {
    total: feedback.length,
    averageRating: feedback.reduce((sum, f) => sum + f.rating, 0) / feedback.length || 0,
    impressions: {
      veryPositive: feedback.filter(f => f.overallImpression === 'VERY_POSITIVE').length,
      positive: feedback.filter(f => f.overallImpression === 'POSITIVE').length,
      neutral: feedback.filter(f => f.overallImpression === 'NEUTRAL').length,
      negative: feedback.filter(f => f.overallImpression === 'NEGATIVE').length,
      veryNegative: feedback.filter(f => f.overallImpression === 'VERY_NEGATIVE').length,
    },
    interest: {
      readyToOffer: feedback.filter(f => f.interestedInProperty === 'READY_TO_OFFER').length,
      veryInterested: feedback.filter(f => f.interestedInProperty === 'VERY_INTERESTED').length,
      somewhatInterested: feedback.filter(f => f.interestedInProperty === 'SOMEWHAT_INTERESTED').length,
      notInterested: feedback.filter(f => f.interestedInProperty === 'NOT_INTERESTED').length,
    },
    pricePerception: {
      tooLow: feedback.filter(f => f.pricePerception === 'TOO_LOW').length,
      fair: feedback.filter(f => f.pricePerception === 'FAIR').length,
      slightlyHigh: feedback.filter(f => f.pricePerception === 'SLIGHTLY_HIGH').length,
      tooHigh: feedback.filter(f => f.pricePerception === 'TOO_HIGH').length,
    },
    wouldRecommend: feedback.filter(f => f.wouldRecommend).length,
    // Aggregate liked/disliked aspects
    likedAspects: feedback.flatMap(f => f.likedAspects || []).reduce((acc, aspect) => {
      acc[aspect] = (acc[aspect] || 0) + 1;
      return acc;
    }, {} as Record<string, number>),
    dislikedAspects: feedback.flatMap(f => f.dislikedAspects || []).reduce((acc, aspect) => {
      acc[aspect] = (acc[aspect] || 0) + 1;
      return acc;
    }, {} as Record<string, number>),
  };
  
  res.json({ feedback, stats });
}));

// ============================================================================
// ANALYTICS
// ============================================================================

// Get open house analytics (agent only)
router.get('/:id/analytics', authenticate, requireAgent, asyncHandler(async (req: AuthRequest, res: Response) => {
  const { id } = req.params;
  
  const openHouse = await prisma.openHouse.findFirst({
    where: {
      id,
      agentId: req.user!.agentId,
    },
    include: {
      property: { select: { id: true, title: true, price: true } },
    },
  });
  
  if (!openHouse) {
    return res.status(403).json({ error: 'Access denied' });
  }
  
  const [rsvps, attendances, feedback, questions, leads] = await Promise.all([
    prisma.openHouseRSVP.count({ where: { openHouseId: id } }),
    prisma.openHouseAttendance.findMany({
      where: { openHouseId: id },
      select: { duration: true, checkInMethod: true },
    }),
    prisma.openHouseFeedback.aggregate({
      where: { openHouseId: id },
      _avg: { rating: true },
      _count: true,
    }),
    prisma.openHouseQuestion.count({ where: { openHouseId: id } }),
    prisma.lead.count({
      where: {
        propertyId: openHouse.propertyId,
        source: 'OPEN_HOUSE',
        createdAt: { gte: openHouse.startTime },
      },
    }),
  ]);
  
  const analytics = {
    overview: {
      totalRSVPs: rsvps,
      totalAttendees: attendances.length,
      showRate: rsvps > 0 ? Math.round((attendances.length / rsvps) * 100) : 0,
      averageDuration: attendances.filter(a => a.duration).reduce((sum, a) => sum + (a.duration || 0), 0) / attendances.length || 0,
      totalQuestions: questions,
      leadsGenerated: leads,
      averageRating: feedback._avg.rating || 0,
      feedbackCount: feedback._count,
    },
    checkInMethods: attendances.reduce((acc, a) => {
      acc[a.checkInMethod || 'UNKNOWN'] = (acc[a.checkInMethod || 'UNKNOWN'] || 0) + 1;
      return acc;
    }, {} as Record<string, number>),
    conversionFunnel: {
      propertyViews: await prisma.propertyView.count({
        where: {
          propertyId: openHouse.propertyId,
          viewedAt: { gte: new Date(openHouse.createdAt.getTime() - 7 * 24 * 60 * 60 * 1000) },
        },
      }),
      rsvps,
      attended: attendances.length,
      leadsGenerated: leads,
    },
  };
  
  res.json(analytics);
}));

// Agent dashboard - all open houses analytics
router.get('/analytics/dashboard', authenticate, requireAgent, asyncHandler(async (req: AuthRequest, res: Response) => {
  const { period = '30' } = req.query;
  const since = new Date(Date.now() - parseInt(period as string) * 24 * 60 * 60 * 1000);
  
  const openHouses = await prisma.openHouse.findMany({
    where: {
      agentId: req.user!.agentId,
      startTime: { gte: since },
    },
    include: {
      property: { select: { id: true, title: true, city: true } },
      _count: {
        select: { rsvps: true, attendances: true, feedback: true },
      },
    },
    orderBy: { startTime: 'desc' },
  });
  
  const stats = {
    totalOpenHouses: openHouses.length,
    completed: openHouses.filter(oh => oh.status === 'COMPLETED').length,
    scheduled: openHouses.filter(oh => oh.status === 'SCHEDULED').length,
    cancelled: openHouses.filter(oh => oh.status === 'CANCELLED').length,
    totalRSVPs: openHouses.reduce((sum, oh) => sum + oh._count.rsvps, 0),
    totalAttendees: openHouses.reduce((sum, oh) => sum + oh._count.attendances, 0),
    averageShowRate: openHouses.length > 0 
      ? Math.round(openHouses.reduce((sum, oh) => {
          return sum + (oh._count.rsvps > 0 ? oh._count.attendances / oh._count.rsvps : 0);
        }, 0) / openHouses.length * 100)
      : 0,
    leadsGenerated: await prisma.lead.count({
      where: {
        agentId: req.user!.agentId,
        source: 'OPEN_HOUSE',
        createdAt: { gte: since },
      },
    }),
  };
  
  // Top performing properties by attendance
  const topProperties = openHouses
    .filter(oh => oh.status === 'COMPLETED')
    .sort((a, b) => b._count.attendances - a._count.attendances)
    .slice(0, 5)
    .map(oh => ({
      propertyId: oh.property.id,
      title: oh.property.title,
      city: oh.property.city,
      attendees: oh._count.attendances,
      date: oh.startTime,
    }));
  
  res.json({ stats, openHouses, topProperties });
}));

// ============================================================================
// CALENDAR INTEGRATION
// ============================================================================

// Get calendar feed URL
router.get('/calendar/feed', authenticate, asyncHandler(async (req: AuthRequest, res: Response) => {
  // Generate a unique calendar token for the user
  let token = await redis.get(`calendar:token:${req.user!.id}`);
  
  if (!token) {
    token = uuidv4();
    await redis.set(`calendar:token:${req.user!.id}`, token);
    await redis.set(`calendar:user:${token}`, req.user!.id);
  }
  
  const feedUrl = `${process.env.APP_URL}/api/openhouses/calendar/${token}.ics`;
  
  res.json({ feedUrl });
}));

// ICS calendar feed (public endpoint with token auth)
router.get('/calendar/:token.ics', asyncHandler(async (req: Request, res: Response) => {
  const { token } = req.params;
  
  const userId = await redis.get(`calendar:user:${token}`);
  
  if (!userId) {
    return res.status(401).json({ error: 'Invalid calendar token' });
  }
  
  // Get user's RSVPed open houses
  const rsvps = await prisma.openHouseRSVP.findMany({
    where: {
      userId,
      status: 'CONFIRMED',
      openHouse: {
        status: { in: ['SCHEDULED', 'LIVE'] },
      },
    },
    include: {
      openHouse: {
        include: {
          property: { select: { address: true, city: true, state: true } },
        },
      },
    },
  });
  
  // Generate ICS content
  let ics = `BEGIN:VCALENDAR
VERSION:2.0
PRODID:-//Dharma Realty//Open Houses//EN
CALSCALE:GREGORIAN
METHOD:PUBLISH
X-WR-CALNAME:Dharma Realty Open Houses
`;

  for (const rsvp of rsvps) {
    const oh = rsvp.openHouse;
    const location = `${oh.property.address}, ${oh.property.city}, ${oh.property.state}`;
    
    ics += `BEGIN:VEVENT
UID:${oh.id}@dharmarealty.com
DTSTART:${formatICSDate(oh.startTime)}
DTEND:${formatICSDate(oh.endTime)}
SUMMARY:Open House: ${oh.title || location}
LOCATION:${oh.type === 'VIRTUAL' ? oh.virtualMeetingUrl : location}
DESCRIPTION:${oh.description || ''}
STATUS:CONFIRMED
END:VEVENT
`;
  }

  ics += 'END:VCALENDAR';

  res.setHeader('Content-Type', 'text/calendar; charset=utf-8');
  res.setHeader('Content-Disposition', 'attachment; filename="openhouses.ics"');
  res.send(ics);
}));

function formatICSDate(date: Date): string {
  return date.toISOString().replace(/[-:]/g, '').replace(/\.\d{3}/, '');
}

export default router;
Inspections · TS
import { Router, Request, Response } from 'express';
import { z } from 'zod';
import { prisma } from '../utils/prisma';
import { redis } from '../utils/redis';
import { authenticate, optionalAuthenticate, requireAgent, AuthRequest } from '../middleware/auth';
import { asyncHandler } from '../middleware/errorHandler';
import { S3Client, PutObjectCommand, GetObjectCommand } from '@aws-sdk/client-s3';
import { getSignedUrl } from '@aws-sdk/s3-request-presigner';
import multer from 'multer';
import { v4 as uuidv4 } from 'uuid';

const router = Router();

// S3 client setup
const s3 = new S3Client({
  region: process.env.AWS_REGION || 'us-east-1',
  credentials: {
    accessKeyId: process.env.AWS_ACCESS_KEY_ID!,
    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY!,
  },
});

const upload = multer({
  storage: multer.memoryStorage(),
  limits: { fileSize: 50 * 1024 * 1024 }, // 50MB
});

// ============================================================================
// SCHEMAS
// ============================================================================

const InspectionTypeEnum = z.enum([
  'GENERAL',
  'STRUCTURAL',
  'ELECTRICAL',
  'PLUMBING',
  'HVAC',
  'ROOF',
  'FOUNDATION',
  'PEST',
  'MOLD',
  'RADON',
  'ASBESTOS',
  'LEAD',
  'POOL',
  'SEPTIC',
  'WELL',
  'CHIMNEY',
  'VASTU',
  'ENERGY_AUDIT',
  'ENVIRONMENTAL',
]);

const DefectSeverityEnum = z.enum(['MINOR', 'MODERATE', 'MAJOR', 'SAFETY_HAZARD', 'CRITICAL']);

const CreateInspectionSchema = z.object({
  propertyId: z.string().uuid(),
  type: InspectionTypeEnum,
  scheduledDate: z.string().datetime(),
  inspectorId: z.string().uuid().optional(),
  inspectorName: z.string().max(200).optional(),
  inspectorCompany: z.string().max(200).optional(),
  inspectorLicense: z.string().max(100).optional(),
  inspectorPhone: z.string().max(20).optional(),
  inspectorEmail: z.string().email().optional(),
  estimatedDuration: z.number().int().min(15).max(480).optional(), // minutes
  estimatedCost: z.number().min(0).optional(),
  notes: z.string().max(2000).optional(),
  accessInstructions: z.string().max(500).optional(),
  attendees: z.array(z.object({
    userId: z.string().uuid().optional(),
    name: z.string(),
    role: z.enum(['BUYER', 'SELLER', 'AGENT', 'CONTRACTOR', 'OTHER']),
  })).optional(),
});

const UpdateInspectionSchema = CreateInspectionSchema.partial();

const InspectionReportSchema = z.object({
  overallCondition: z.enum(['EXCELLENT', 'GOOD', 'FAIR', 'POOR', 'CRITICAL']),
  summary: z.string().max(5000),
  recommendations: z.string().max(5000).optional(),
  estimatedRepairCost: z.number().min(0).optional(),
  estimatedRepairCostRange: z.object({
    min: z.number().min(0),
    max: z.number().min(0),
  }).optional(),
  immediateActionRequired: z.boolean().default(false),
  reinspectionRecommended: z.boolean().default(false),
  reinspectionAreas: z.array(z.string()).optional(),
  systemsInspected: z.array(z.object({
    system: z.string(),
    condition: z.enum(['EXCELLENT', 'GOOD', 'FAIR', 'POOR', 'NOT_INSPECTED']),
    notes: z.string().optional(),
    estimatedAge: z.number().optional(),
    estimatedRemainingLife: z.number().optional(),
  })).optional(),
  vastuCompliance: z.object({
    isCompliant: z.boolean(),
    score: z.number().min(0).max(100),
    issues: z.array(z.string()),
    recommendations: z.array(z.string()),
  }).optional(),
});

const DefectSchema = z.object({
  category: z.string().max(100),
  location: z.string().max(200),
  description: z.string().max(2000),
  severity: DefectSeverityEnum,
  estimatedRepairCost: z.number().min(0).optional(),
  estimatedRepairCostRange: z.object({
    min: z.number().min(0),
    max: z.number().min(0),
  }).optional(),
  urgency: z.enum(['IMMEDIATE', 'WITHIN_30_DAYS', 'WITHIN_90_DAYS', 'WITHIN_YEAR', 'MONITOR']).optional(),
  recommendedAction: z.string().max(1000).optional(),
  contractorType: z.string().max(100).optional(),
  photos: z.array(z.string()).optional(),
  coordinates: z.object({
    x: z.number(),
    y: z.number(),
    floorPlanId: z.string().optional(),
  }).optional(),
});

const RepairRequestSchema = z.object({
  defectIds: z.array(z.string().uuid()),
  requestType: z.enum(['FIX_BEFORE_CLOSE', 'CREDIT', 'PRICE_REDUCTION', 'AS_IS']),
  requestedAmount: z.number().min(0).optional(),
  notes: z.string().max(2000).optional(),
  deadline: z.string().datetime().optional(),
});

// ============================================================================
// INSPECTION CRUD
// ============================================================================

// Schedule inspection
router.post('/', authenticate, asyncHandler(async (req: AuthRequest, res: Response) => {
  const data = CreateInspectionSchema.parse(req.body);
  
  // Verify property access (owner, agent, or buyer in transaction)
  const property = await prisma.property.findUnique({
    where: { id: data.propertyId },
    include: {
      transactions: {
        where: {
          OR: [
            { buyerId: req.user!.id },
            { sellerId: req.user!.id },
          ],
          status: { in: ['PENDING', 'IN_ESCROW', 'UNDER_CONTRACT'] },
        },
      },
    },
  });
  
  if (!property) {
    return res.status(404).json({ error: 'Property not found' });
  }
  
  const hasAccess = 
    property.ownerId === req.user!.id ||
    property.agentId === req.user!.agentId ||
    property.transactions.length > 0;
  
  if (!hasAccess) {
    return res.status(403).json({ error: 'Access denied' });
  }
  
  const inspection = await prisma.inspection.create({
    data: {
      ...data,
      scheduledDate: new Date(data.scheduledDate),
      scheduledById: req.user!.id,
      status: 'SCHEDULED',
    },
    include: {
      property: {
        select: { id: true, title: true, address: true, city: true },
      },
    },
  });
  
  // Notify relevant parties
  const notifications: any[] = [];
  
  if (property.ownerId && property.ownerId !== req.user!.id) {
    notifications.push({
      userId: property.ownerId,
      type: 'INSPECTION_SCHEDULED',
      title: 'Inspection Scheduled',
      message: `A ${data.type} inspection has been scheduled for ${property.title || property.address}`,
      data: { inspectionId: inspection.id, propertyId: property.id },
    });
  }
  
  if (property.agentId && property.agentId !== req.user!.id) {
    notifications.push({
      userId: property.agentId,
      type: 'INSPECTION_SCHEDULED',
      title: 'Inspection Scheduled',
      message: `A ${data.type} inspection has been scheduled for ${property.title || property.address}`,
      data: { inspectionId: inspection.id, propertyId: property.id },
    });
  }
  
  if (notifications.length > 0) {
    await prisma.notification.createMany({ data: notifications });
  }
  
  res.status(201).json(inspection);
}));

// List inspections
router.get('/', authenticate, asyncHandler(async (req: AuthRequest, res: Response) => {
  const {
    propertyId,
    type,
    status,
    upcoming,
    past,
    limit = '20',
    offset = '0',
  } = req.query;
  
  const where: any = {
    OR: [
      { scheduledById: req.user!.id },
      { property: { ownerId: req.user!.id } },
      { property: { agentId: req.user!.agentId } },
    ],
  };
  
  if (propertyId) where.propertyId = propertyId;
  if (type) where.type = type;
  if (status) where.status = status;
  
  if (upcoming === 'true') {
    where.scheduledDate = { gte: new Date() };
    where.status = { in: ['SCHEDULED', 'CONFIRMED'] };
  }
  
  if (past === 'true') {
    where.scheduledDate = { lt: new Date() };
  }
  
  const [inspections, total] = await Promise.all([
    prisma.inspection.findMany({
      where,
      include: {
        property: {
          select: { id: true, title: true, address: true, city: true, photos: { take: 1 } },
        },
        report: { select: { id: true, overallCondition: true } },
        _count: { select: { defects: true } },
      },
      orderBy: { scheduledDate: 'desc' },
      take: parseInt(limit as string),
      skip: parseInt(offset as string),
    }),
    prisma.inspection.count({ where }),
  ]);
  
  res.json({
    inspections,
    total,
    limit: parseInt(limit as string),
    offset: parseInt(offset as string),
  });
}));

// Get inspection details
router.get('/:id', authenticate, asyncHandler(async (req: AuthRequest, res: Response) => {
  const { id } = req.params;
  
  const inspection = await prisma.inspection.findUnique({
    where: { id },
    include: {
      property: {
        select: {
          id: true,
          title: true,
          address: true,
          city: true,
          state: true,
          ownerId: true,
          agentId: true,
        },
      },
      report: true,
      defects: {
        include: {
          photos: true,
          repairRequests: true,
        },
        orderBy: { severity: 'desc' },
      },
      documents: true,
      scheduledBy: {
        select: { firstName: true, lastName: true },
      },
    },
  });
  
  if (!inspection) {
    return res.status(404).json({ error: 'Inspection not found' });
  }
  
  // Check access
  const hasAccess = 
    inspection.scheduledById === req.user!.id ||
    inspection.property.ownerId === req.user!.id ||
    inspection.property.agentId === req.user!.agentId;
  
  if (!hasAccess) {
    return res.status(403).json({ error: 'Access denied' });
  }
  
  res.json(inspection);
}));

// Update inspection
router.put('/:id', authenticate, asyncHandler(async (req: AuthRequest, res: Response) => {
  const { id } = req.params;
  const data = UpdateInspectionSchema.parse(req.body);
  
  const inspection = await prisma.inspection.findFirst({
    where: {
      id,
      OR: [
        { scheduledById: req.user!.id },
        { property: { agentId: req.user!.agentId } },
      ],
      status: { in: ['SCHEDULED', 'CONFIRMED'] },
    },
  });
  
  if (!inspection) {
    return res.status(404).json({ error: 'Inspection not found or cannot be modified' });
  }
  
  const updated = await prisma.inspection.update({
    where: { id },
    data: {
      ...data,
      scheduledDate: data.scheduledDate ? new Date(data.scheduledDate) : undefined,
    },
  });
  
  res.json(updated);
}));

// Cancel inspection
router.post('/:id/cancel', authenticate, asyncHandler(async (req: AuthRequest, res: Response) => {
  const { id } = req.params;
  const { reason } = req.body;
  
  const inspection = await prisma.inspection.findFirst({
    where: {
      id,
      OR: [
        { scheduledById: req.user!.id },
        { property: { agentId: req.user!.agentId } },
      ],
      status: { in: ['SCHEDULED', 'CONFIRMED'] },
    },
    include: {
      property: { select: { ownerId: true, agentId: true } },
    },
  });
  
  if (!inspection) {
    return res.status(404).json({ error: 'Inspection not found or cannot be cancelled' });
  }
  
  await prisma.inspection.update({
    where: { id },
    data: {
      status: 'CANCELLED',
      cancellationReason: reason,
      cancelledAt: new Date(),
    },
  });
  
  res.json({ success: true, message: 'Inspection cancelled' });
}));

// Confirm inspection
router.post('/:id/confirm', authenticate, asyncHandler(async (req: AuthRequest, res: Response) => {
  const { id } = req.params;
  
  const inspection = await prisma.inspection.findFirst({
    where: {
      id,
      OR: [
        { scheduledById: req.user!.id },
        { property: { agentId: req.user!.agentId } },
      ],
      status: 'SCHEDULED',
    },
  });
  
  if (!inspection) {
    return res.status(404).json({ error: 'Inspection not found' });
  }
  
  await prisma.inspection.update({
    where: { id },
    data: { status: 'CONFIRMED' },
  });
  
  res.json({ success: true, message: 'Inspection confirmed' });
}));

// Mark inspection as in progress
router.post('/:id/start', authenticate, asyncHandler(async (req: AuthRequest, res: Response) => {
  const { id } = req.params;
  
  const inspection = await prisma.inspection.findFirst({
    where: {
      id,
      OR: [
        { scheduledById: req.user!.id },
        { property: { agentId: req.user!.agentId } },
      ],
      status: { in: ['SCHEDULED', 'CONFIRMED'] },
    },
  });
  
  if (!inspection) {
    return res.status(404).json({ error: 'Inspection not found' });
  }
  
  await prisma.inspection.update({
    where: { id },
    data: {
      status: 'IN_PROGRESS',
      actualStartTime: new Date(),
    },
  });
  
  res.json({ success: true, message: 'Inspection started' });
}));

// Complete inspection
router.post('/:id/complete', authenticate, asyncHandler(async (req: AuthRequest, res: Response) => {
  const { id } = req.params;
  
  const inspection = await prisma.inspection.findFirst({
    where: {
      id,
      OR: [
        { scheduledById: req.user!.id },
        { property: { agentId: req.user!.agentId } },
      ],
      status: 'IN_PROGRESS',
    },
  });
  
  if (!inspection) {
    return res.status(404).json({ error: 'Inspection not found or not in progress' });
  }
  
  await prisma.inspection.update({
    where: { id },
    data: {
      status: 'COMPLETED',
      actualEndTime: new Date(),
    },
  });
  
  res.json({ success: true, message: 'Inspection completed' });
}));

// ============================================================================
// INSPECTION REPORT
// ============================================================================

// Create/update inspection report
router.post('/:id/report', authenticate, asyncHandler(async (req: AuthRequest, res: Response) => {
  const { id } = req.params;
  const data = InspectionReportSchema.parse(req.body);
  
  const inspection = await prisma.inspection.findFirst({
    where: {
      id,
      OR: [
        { scheduledById: req.user!.id },
        { property: { agentId: req.user!.agentId } },
      ],
    },
    include: {
      property: { select: { ownerId: true, agentId: true, title: true, address: true } },
    },
  });
  
  if (!inspection) {
    return res.status(404).json({ error: 'Inspection not found' });
  }
  
  const report = await prisma.inspectionReport.upsert({
    where: { inspectionId: id },
    create: {
      inspectionId: id,
      ...data,
      createdById: req.user!.id,
    },
    update: {
      ...data,
      updatedAt: new Date(),
    },
  });
  
  // Update inspection status
  await prisma.inspection.update({
    where: { id },
    data: { status: 'REPORT_READY' },
  });
  
  // Notify property owner and agent
  const notifications: any[] = [];
  
  if (inspection.property.ownerId) {
    notifications.push({
      userId: inspection.property.ownerId,
      type: 'INSPECTION_REPORT_READY',
      title: 'Inspection Report Ready',
      message: `The inspection report for ${inspection.property.title || inspection.property.address} is now available`,
      data: { inspectionId: id, reportId: report.id },
      priority: data.immediateActionRequired ? 'URGENT' : 'NORMAL',
    });
  }
  
  if (inspection.property.agentId) {
    notifications.push({
      userId: inspection.property.agentId,
      type: 'INSPECTION_REPORT_READY',
      title: 'Inspection Report Ready',
      message: `The inspection report for ${inspection.property.title || inspection.property.address} is now available`,
      data: { inspectionId: id, reportId: report.id },
      priority: data.immediateActionRequired ? 'URGENT' : 'NORMAL',
    });
  }
  
  if (notifications.length > 0) {
    await prisma.notification.createMany({ data: notifications });
  }
  
  res.status(201).json(report);
}));

// Get inspection report
router.get('/:id/report', authenticate, asyncHandler(async (req: AuthRequest, res: Response) => {
  const { id } = req.params;
  
  const inspection = await prisma.inspection.findFirst({
    where: {
      id,
      OR: [
        { scheduledById: req.user!.id },
        { property: { ownerId: req.user!.id } },
        { property: { agentId: req.user!.agentId } },
      ],
    },
    include: {
      report: {
        include: {
          createdBy: { select: { firstName: true, lastName: true } },
        },
      },
    },
  });
  
  if (!inspection) {
    return res.status(404).json({ error: 'Inspection not found' });
  }
  
  if (!inspection.report) {
    return res.status(404).json({ error: 'Report not yet available' });
  }
  
  res.json(inspection.report);
}));

// ============================================================================
// DEFECTS
// ============================================================================

// Add defect to inspection
router.post('/:id/defects', authenticate, asyncHandler(async (req: AuthRequest, res: Response) => {
  const { id } = req.params;
  const data = DefectSchema.parse(req.body);
  
  const inspection = await prisma.inspection.findFirst({
    where: {
      id,
      OR: [
        { scheduledById: req.user!.id },
        { property: { agentId: req.user!.agentId } },
      ],
    },
  });
  
  if (!inspection) {
    return res.status(404).json({ error: 'Inspection not found' });
  }
  
  const defect = await prisma.inspectionDefect.create({
    data: {
      inspectionId: id,
      ...data,
      reportedById: req.user!.id,
    },
  });
  
  res.status(201).json(defect);
}));

// List defects
router.get('/:id/defects', authenticate, asyncHandler(async (req: AuthRequest, res: Response) => {
  const { id } = req.params;
  const { severity, category } = req.query;
  
  const inspection = await prisma.inspection.findFirst({
    where: {
      id,
      OR: [
        { scheduledById: req.user!.id },
        { property: { ownerId: req.user!.id } },
        { property: { agentId: req.user!.agentId } },
      ],
    },
  });
  
  if (!inspection) {
    return res.status(404).json({ error: 'Inspection not found' });
  }
  
  const where: any = { inspectionId: id };
  if (severity) where.severity = severity;
  if (category) where.category = { contains: category as string, mode: 'insensitive' };
  
  const defects = await prisma.inspectionDefect.findMany({
    where,
    include: {
      photos: true,
      repairRequests: true,
    },
    orderBy: [
      { severity: 'desc' },
      { createdAt: 'asc' },
    ],
  });
  
  // Summary statistics
  const summary = {
    total: defects.length,
    bySeverity: {
      critical: defects.filter(d => d.severity === 'CRITICAL').length,
      safetyHazard: defects.filter(d => d.severity === 'SAFETY_HAZARD').length,
      major: defects.filter(d => d.severity === 'MAJOR').length,
      moderate: defects.filter(d => d.severity === 'MODERATE').length,
      minor: defects.filter(d => d.severity === 'MINOR').length,
    },
    estimatedTotalCost: defects.reduce((sum, d) => sum + (d.estimatedRepairCost || 0), 0),
    byCategory: defects.reduce((acc, d) => {
      acc[d.category] = (acc[d.category] || 0) + 1;
      return acc;
    }, {} as Record<string, number>),
  };
  
  res.json({ defects, summary });
}));

// Update defect
router.put('/:id/defects/:defectId', authenticate, asyncHandler(async (req: AuthRequest, res: Response) => {
  const { id, defectId } = req.params;
  const data = DefectSchema.partial().parse(req.body);
  
  const defect = await prisma.inspectionDefect.findFirst({
    where: {
      id: defectId,
      inspectionId: id,
      inspection: {
        OR: [
          { scheduledById: req.user!.id },
          { property: { agentId: req.user!.agentId } },
        ],
      },
    },
  });
  
  if (!defect) {
    return res.status(404).json({ error: 'Defect not found' });
  }
  
  const updated = await prisma.inspectionDefect.update({
    where: { id: defectId },
    data,
  });
  
  res.json(updated);
}));

// Delete defect
router.delete('/:id/defects/:defectId', authenticate, asyncHandler(async (req: AuthRequest, res: Response) => {
  const { id, defectId } = req.params;
  
  const defect = await prisma.inspectionDefect.findFirst({
    where: {
      id: defectId,
      inspectionId: id,
      inspection: {
        OR: [
          { scheduledById: req.user!.id },
          { property: { agentId: req.user!.agentId } },
        ],
      },
    },
  });
  
  if (!defect) {
    return res.status(404).json({ error: 'Defect not found' });
  }
  
  await prisma.inspectionDefect.delete({ where: { id: defectId } });
  
  res.json({ success: true, message: 'Defect deleted' });
}));

// Upload defect photo
router.post('/:id/defects/:defectId/photos', authenticate, upload.single('photo'), asyncHandler(async (req: AuthRequest, res: Response) => {
  const { id, defectId } = req.params;
  
  if (!req.file) {
    return res.status(400).json({ error: 'No photo provided' });
  }
  
  const defect = await prisma.inspectionDefect.findFirst({
    where: {
      id: defectId,
      inspectionId: id,
      inspection: {
        OR: [
          { scheduledById: req.user!.id },
          { property: { agentId: req.user!.agentId } },
        ],
      },
    },
  });
  
  if (!defect) {
    return res.status(404).json({ error: 'Defect not found' });
  }
  
  const key = `inspections/${id}/defects/${defectId}/${uuidv4()}.jpg`;
  
  await s3.send(new PutObjectCommand({
    Bucket: process.env.S3_BUCKET,
    Key: key,
    Body: req.file.buffer,
    ContentType: req.file.mimetype,
  }));
  
  const photo = await prisma.defectPhoto.create({
    data: {
      defectId,
      url: `${process.env.CDN_URL}/${key}`,
      s3Key: key,
      caption: req.body.caption,
    },
  });
  
  res.status(201).json(photo);
}));

// ============================================================================
// REPAIR REQUESTS
// ============================================================================

// Create repair request
router.post('/:id/repair-requests', authenticate, asyncHandler(async (req: AuthRequest, res: Response) => {
  const { id } = req.params;
  const data = RepairRequestSchema.parse(req.body);
  
  const inspection = await prisma.inspection.findFirst({
    where: {
      id,
      OR: [
        { scheduledById: req.user!.id },
        { property: { ownerId: req.user!.id } },
      ],
    },
    include: {
      property: { select: { ownerId: true, agentId: true, title: true } },
    },
  });
  
  if (!inspection) {
    return res.status(404).json({ error: 'Inspection not found' });
  }
  
  // Verify defects belong to this inspection
  const defects = await prisma.inspectionDefect.findMany({
    where: {
      id: { in: data.defectIds },
      inspectionId: id,
    },
  });
  
  if (defects.length !== data.defectIds.length) {
    return res.status(400).json({ error: 'Some defects not found' });
  }
  
  const repairRequest = await prisma.repairRequest.create({
    data: {
      inspectionId: id,
      requestedById: req.user!.id,
      requestType: data.requestType,
      requestedAmount: data.requestedAmount,
      notes: data.notes,
      deadline: data.deadline ? new Date(data.deadline) : null,
      status: 'PENDING',
      defects: {
        connect: data.defectIds.map(id => ({ id })),
      },
    },
    include: {
      defects: true,
    },
  });
  
  // Notify seller/owner
  if (inspection.property.ownerId && inspection.property.ownerId !== req.user!.id) {
    await prisma.notification.create({
      data: {
        userId: inspection.property.ownerId,
        type: 'REPAIR_REQUEST',
        title: 'New Repair Request',
        message: `A repair request has been submitted for ${inspection.property.title}`,
        data: { inspectionId: id, repairRequestId: repairRequest.id },
        priority: 'HIGH',
      },
    });
  }
  
  res.status(201).json(repairRequest);
}));

// Get repair requests for inspection
router.get('/:id/repair-requests', authenticate, asyncHandler(async (req: AuthRequest, res: Response) => {
  const { id } = req.params;
  
  const inspection = await prisma.inspection.findFirst({
    where: {
      id,
      OR: [
        { scheduledById: req.user!.id },
        { property: { ownerId: req.user!.id } },
        { property: { agentId: req.user!.agentId } },
      ],
    },
  });
  
  if (!inspection) {
    return res.status(404).json({ error: 'Inspection not found' });
  }
  
  const repairRequests = await prisma.repairRequest.findMany({
    where: { inspectionId: id },
    include: {
      defects: true,
      requestedBy: { select: { firstName: true, lastName: true } },
      responses: {
        orderBy: { createdAt: 'desc' },
      },
    },
    orderBy: { createdAt: 'desc' },
  });
  
  res.json(repairRequests);
}));

// Respond to repair request
router.post('/:id/repair-requests/:requestId/respond', authenticate, asyncHandler(async (req: AuthRequest, res: Response) => {
  const { id, requestId } = req.params;
  const { response, counterOffer, notes } = req.body;
  
  const repairRequest = await prisma.repairRequest.findFirst({
    where: {
      id: requestId,
      inspectionId: id,
      inspection: {
        property: {
          OR: [
            { ownerId: req.user!.id },
            { agentId: req.user!.agentId },
          ],
        },
      },
    },
  });
  
  if (!repairRequest) {
    return res.status(404).json({ error: 'Repair request not found' });
  }
  
  // Create response
  const repairResponse = await prisma.repairRequestResponse.create({
    data: {
      repairRequestId: requestId,
      respondedById: req.user!.id,
      response, // ACCEPT, REJECT, COUNTER
      counterOffer,
      notes,
    },
  });
  
  // Update request status
  let newStatus = repairRequest.status;
  if (response === 'ACCEPT') newStatus = 'ACCEPTED';
  else if (response === 'REJECT') newStatus = 'REJECTED';
  else if (response === 'COUNTER') newStatus = 'COUNTER_OFFERED';
  
  await prisma.repairRequest.update({
    where: { id: requestId },
    data: { status: newStatus },
  });
  
  // Notify requester
  await prisma.notification.create({
    data: {
      userId: repairRequest.requestedById,
      type: 'REPAIR_REQUEST_RESPONSE',
      title: `Repair Request ${response}`,
      message: `Your repair request has received a response`,
      data: { repairRequestId: requestId },
    },
  });
  
  res.status(201).json(repairResponse);
}));

// ============================================================================
// DOCUMENTS
// ============================================================================

// Upload inspection document
router.post('/:id/documents', authenticate, upload.single('document'), asyncHandler(async (req: AuthRequest, res: Response) => {
  const { id } = req.params;
  const { type, name } = req.body;
  
  if (!req.file) {
    return res.status(400).json({ error: 'No document provided' });
  }
  
  const inspection = await prisma.inspection.findFirst({
    where: {
      id,
      OR: [
        { scheduledById: req.user!.id },
        { property: { agentId: req.user!.agentId } },
      ],
    },
  });
  
  if (!inspection) {
    return res.status(404).json({ error: 'Inspection not found' });
  }
  
  const key = `inspections/${id}/documents/${uuidv4()}-${req.file.originalname}`;
  
  await s3.send(new PutObjectCommand({
    Bucket: process.env.S3_BUCKET,
    Key: key,
    Body: req.file.buffer,
    ContentType: req.file.mimetype,
  }));
  
  const document = await prisma.inspectionDocument.create({
    data: {
      inspectionId: id,
      type: type || 'REPORT',
      name: name || req.file.originalname,
      url: `${process.env.CDN_URL}/${key}`,
      s3Key: key,
      mimeType: req.file.mimetype,
      size: req.file.size,
      uploadedById: req.user!.id,
    },
  });
  
  res.status(201).json(document);
}));

// Get document download URL
router.get('/:id/documents/:docId/download', authenticate, asyncHandler(async (req: AuthRequest, res: Response) => {
  const { id, docId } = req.params;
  
  const document = await prisma.inspectionDocument.findFirst({
    where: {
      id: docId,
      inspectionId: id,
      inspection: {
        OR: [
          { scheduledById: req.user!.id },
          { property: { ownerId: req.user!.id } },
          { property: { agentId: req.user!.agentId } },
        ],
      },
    },
  });
  
  if (!document) {
    return res.status(404).json({ error: 'Document not found' });
  }
  
  const url = await getSignedUrl(
    s3,
    new GetObjectCommand({
      Bucket: process.env.S3_BUCKET,
      Key: document.s3Key,
    }),
    { expiresIn: 3600 }
  );
  
  res.json({ url });
}));

// ============================================================================
// CONTRACTOR RECOMMENDATIONS
// ============================================================================

// Get contractor recommendations for defects
router.get('/:id/contractors', authenticate, asyncHandler(async (req: AuthRequest, res: Response) => {
  const { id } = req.params;
  const { defectId, category } = req.query;
  
  const inspection = await prisma.inspection.findFirst({
    where: {
      id,
      OR: [
        { scheduledById: req.user!.id },
        { property: { ownerId: req.user!.id } },
        { property: { agentId: req.user!.agentId } },
      ],
    },
    include: {
      property: { select: { city: true, state: true, zipCode: true } },
      defects: defectId ? { where: { id: defectId as string } } : true,
    },
  });
  
  if (!inspection) {
    return res.status(404).json({ error: 'Inspection not found' });
  }
  
  // Get contractor types needed based on defects
  const contractorTypes = new Set<string>();
  inspection.defects.forEach(d => {
    if (d.contractorType) contractorTypes.add(d.contractorType);
  });
  
  if (category) contractorTypes.add(category as string);
  
  // Find contractors in the area
  const contractors = await prisma.contractor.findMany({
    where: {
      specialties: { hasSome: Array.from(contractorTypes) },
      serviceAreas: { has: inspection.property.city },
      isActive: true,
      isVerified: true,
    },
    include: {
      _count: { select: { reviews: true } },
    },
    orderBy: [
      { avgRating: 'desc' },
      { completedJobs: 'desc' },
    ],
    take: 10,
  });
  
  // Get reviews for top contractors
  const contractorsWithReviews = await Promise.all(
    contractors.map(async c => {
      const reviews = await prisma.contractorReview.findMany({
        where: { contractorId: c.id },
        orderBy: { createdAt: 'desc' },
        take: 3,
        select: {
          rating: true,
          comment: true,
          createdAt: true,
        },
      });
      return { ...c, recentReviews: reviews };
    })
  );
  
  res.json({
    contractorTypes: Array.from(contractorTypes),
    contractors: contractorsWithReviews,
  });
}));

// Request quote from contractor
router.post('/:id/quote-request', authenticate, asyncHandler(async (req: AuthRequest, res: Response) => {
  const { id } = req.params;
  const { contractorId, defectIds, message, preferredSchedule } = req.body;
  
  const inspection = await prisma.inspection.findFirst({
    where: {
      id,
      OR: [
        { scheduledById: req.user!.id },
        { property: { ownerId: req.user!.id } },
      ],
    },
    include: {
      property: { select: { address: true, city: true } },
      defects: { where: { id: { in: defectIds } } },
    },
  });
  
  if (!inspection) {
    return res.status(404).json({ error: 'Inspection not found' });
  }
  
  const quoteRequest = await prisma.quoteRequest.create({
    data: {
      inspectionId: id,
      contractorId,
      requestedById: req.user!.id,
      defects: { connect: defectIds.map((id: string) => ({ id })) },
      message,
      preferredSchedule,
      status: 'PENDING',
    },
  });
  
  // Notify contractor
  const contractor = await prisma.contractor.findUnique({
    where: { id: contractorId },
    select: { userId: true },
  });
  
  if (contractor?.userId) {
    await prisma.notification.create({
      data: {
        userId: contractor.userId,
        type: 'QUOTE_REQUEST',
        title: 'New Quote Request',
        message: `You have a new quote request for ${inspection.property.address}`,
        data: { quoteRequestId: quoteRequest.id },
      },
    });
  }
  
  res.status(201).json(quoteRequest);
}));

// ============================================================================
// INSPECTOR DIRECTORY
// ============================================================================

// Search inspectors
router.get('/inspectors/search', optionalAuthenticate, asyncHandler(async (req: AuthRequest, res: Response) => {
  const {
    city,
    state,
    zipCode,
    type,
    minRating,
    limit = '20',
    offset = '0',
  } = req.query;
  
  const where: any = {
    isActive: true,
    isVerified: true,
  };
  
  if (city) where.serviceAreas = { has: city };
  if (state) where.state = state;
  if (type) where.specializations = { has: type };
  if (minRating) where.avgRating = { gte: parseFloat(minRating as string) };
  
  const [inspectors, total] = await Promise.all([
    prisma.inspector.findMany({
      where,
      include: {
        _count: { select: { inspections: true, reviews: true } },
      },
      orderBy: [
        { avgRating: 'desc' },
        { completedInspections: 'desc' },
      ],
      take: parseInt(limit as string),
      skip: parseInt(offset as string),
    }),
    prisma.inspector.count({ where }),
  ]);
  
  res.json({
    inspectors,
    total,
    limit: parseInt(limit as string),
    offset: parseInt(offset as string),
  });
}));

// Get inspector profile
router.get('/inspectors/:inspectorId', optionalAuthenticate, asyncHandler(async (req: AuthRequest, res: Response) => {
  const { inspectorId } = req.params;
  
  const inspector = await prisma.inspector.findUnique({
    where: { id: inspectorId },
    include: {
      reviews: {
        orderBy: { createdAt: 'desc' },
        take: 10,
        include: {
          user: { select: { firstName: true, lastName: true } },
        },
      },
      certifications: true,
      _count: { select: { inspections: true, reviews: true } },
    },
  });
  
  if (!inspector) {
    return res.status(404).json({ error: 'Inspector not found' });
  }
  
  res.json(inspector);
}));

export default router;


Signing · TS
import { Router, Request, Response } from 'express';
import { z } from 'zod';
import { prisma } from '../utils/prisma';
import { redis } from '../utils/redis';
import { authenticate, requireAgent, AuthRequest } from '../middleware/auth';
import { asyncHandler } from '../middleware/errorHandler';
import { S3Client, PutObjectCommand, GetObjectCommand } from '@aws-sdk/client-s3';
import { getSignedUrl } from '@aws-sdk/s3-request-presigner';
import multer from 'multer';
import { v4 as uuidv4 } from 'uuid';
import crypto from 'crypto';

const router = Router();

// S3 client
const s3 = new S3Client({
  region: process.env.AWS_REGION || 'us-east-1',
  credentials: {
    accessKeyId: process.env.AWS_ACCESS_KEY_ID!,
    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY!,
  },
});

const upload = multer({
  storage: multer.memoryStorage(),
  limits: { fileSize: 25 * 1024 * 1024 }, // 25MB
  fileFilter: (req, file, cb) => {
    const allowed = ['application/pdf', 'application/msword', 
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document'];
    cb(null, allowed.includes(file.mimetype));
  },
});

// ============================================================================
// DOCUSIGN API HELPER
// ============================================================================

class DocuSignClient {
  private accessToken: string | null = null;
  private tokenExpiry: Date | null = null;
  private baseUrl: string;
  private accountId: string;

  constructor() {
    this.baseUrl = process.env.DOCUSIGN_BASE_URL || 'https://demo.docusign.net/restapi';
    this.accountId = process.env.DOCUSIGN_ACCOUNT_ID || '';
  }

  private async getAccessToken(): Promise<string> {
    if (this.accessToken && this.tokenExpiry && new Date() < this.tokenExpiry) {
      return this.accessToken;
    }

    // JWT Grant flow for server-to-server
    const response = await fetch(`${process.env.DOCUSIGN_AUTH_SERVER}/oauth/token`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: new URLSearchParams({
        grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer',
        assertion: await this.generateJWT(),
      }),
    });

    const data = await response.json();
    this.accessToken = data.access_token;
    this.tokenExpiry = new Date(Date.now() + (data.expires_in - 60) * 1000);
    
    return this.accessToken!;
  }

  private async generateJWT(): Promise<string> {
    const header = Buffer.from(JSON.stringify({ alg: 'RS256', typ: 'JWT' })).toString('base64url');
    const now = Math.floor(Date.now() / 1000);
    const payload = Buffer.from(JSON.stringify({
      iss: process.env.DOCUSIGN_INTEGRATION_KEY,
      sub: process.env.DOCUSIGN_USER_ID,
      aud: process.env.DOCUSIGN_AUTH_SERVER?.replace('https://', ''),
      iat: now,
      exp: now + 3600,
      scope: 'signature impersonation',
    })).toString('base64url');

    const privateKey = process.env.DOCUSIGN_PRIVATE_KEY!.replace(/\\n/g, '\n');
    const sign = crypto.createSign('RSA-SHA256');
    sign.update(`${header}.${payload}`);
    const signature = sign.sign(privateKey, 'base64url');

    return `${header}.${payload}.${signature}`;
  }

  async createEnvelope(data: {
    templateId?: string;
    documents?: Array<{
      documentId: string;
      name: string;
      content: Buffer;
    }>;
    recipients: Array<{
      email: string;
      name: string;
      roleName?: string;
      routingOrder: number;
      tabs?: any;
    }>;
    emailSubject: string;
    emailBlurb?: string;
    status?: 'created' | 'sent';
  }): Promise<{ envelopeId: string; uri: string }> {
    const token = await this.getAccessToken();

    const envelopeDefinition: any = {
      emailSubject: data.emailSubject,
      emailBlurb: data.emailBlurb,
      status: data.status || 'sent',
    };

    if (data.templateId) {
      envelopeDefinition.templateId = data.templateId;
      envelopeDefinition.templateRoles = data.recipients.map(r => ({
        email: r.email,
        name: r.name,
        roleName: r.roleName,
        routingOrder: r.routingOrder.toString(),
        tabs: r.tabs,
      }));
    } else {
      envelopeDefinition.documents = data.documents?.map(d => ({
        documentId: d.documentId,
        name: d.name,
        documentBase64: d.content.toString('base64'),
      }));
      envelopeDefinition.recipients = {
        signers: data.recipients.map((r, i) => ({
          email: r.email,
          name: r.name,
          recipientId: (i + 1).toString(),
          routingOrder: r.routingOrder.toString(),
          tabs: r.tabs,
        })),
      };
    }

    const response = await fetch(
      `${this.baseUrl}/v2.1/accounts/${this.accountId}/envelopes`,
      {
        method: 'POST',
        headers: {
          Authorization: `Bearer ${token}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(envelopeDefinition),
      }
    );

    if (!response.ok) {
      const error = await response.json();
      throw new Error(`DocuSign error: ${error.message}`);
    }

    const result = await response.json();
    return { envelopeId: result.envelopeId, uri: result.uri };
  }

  async getEnvelopeStatus(envelopeId: string): Promise<any> {
    const token = await this.getAccessToken();

    const response = await fetch(
      `${this.baseUrl}/v2.1/accounts/${this.accountId}/envelopes/${envelopeId}`,
      {
        headers: { Authorization: `Bearer ${token}` },
      }
    );

    return response.json();
  }

  async getSigningUrl(envelopeId: string, recipientEmail: string, recipientName: string, returnUrl: string): Promise<string> {
    const token = await this.getAccessToken();

    const response = await fetch(
      `${this.baseUrl}/v2.1/accounts/${this.accountId}/envelopes/${envelopeId}/views/recipient`,
      {
        method: 'POST',
        headers: {
          Authorization: `Bearer ${token}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          returnUrl,
          authenticationMethod: 'none',
          email: recipientEmail,
          userName: recipientName,
        }),
      }
    );

    const result = await response.json();
    return result.url;
  }

  async downloadDocument(envelopeId: string, documentId: string = 'combined'): Promise<Buffer> {
    const token = await this.getAccessToken();

    const response = await fetch(
      `${this.baseUrl}/v2.1/accounts/${this.accountId}/envelopes/${envelopeId}/documents/${documentId}`,
      {
        headers: { Authorization: `Bearer ${token}` },
      }
    );

    return Buffer.from(await response.arrayBuffer());
  }

  async voidEnvelope(envelopeId: string, reason: string): Promise<void> {
    const token = await this.getAccessToken();

    await fetch(
      `${this.baseUrl}/v2.1/accounts/${this.accountId}/envelopes/${envelopeId}`,
      {
        method: 'PUT',
        headers: {
          Authorization: `Bearer ${token}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          status: 'voided',
          voidedReason: reason,
        }),
      }
    );
  }

  async listTemplates(): Promise<any[]> {
    const token = await this.getAccessToken();

    const response = await fetch(
      `${this.baseUrl}/v2.1/accounts/${this.accountId}/templates`,
      {
        headers: { Authorization: `Bearer ${token}` },
      }
    );

    const result = await response.json();
    return result.envelopeTemplates || [];
  }
}

const docusign = new DocuSignClient();

// ============================================================================
// SCHEMAS
// ============================================================================

const DocumentTypeEnum = z.enum([
  'PURCHASE_AGREEMENT',
  'LISTING_AGREEMENT',
  'BUYER_AGENCY',
  'DISCLOSURE_FORM',
  'ADDENDUM',
  'AMENDMENT',
  'COUNTEROFFER',
  'CONTINGENCY_RELEASE',
  'INSPECTION_RESPONSE',
  'REPAIR_REQUEST',
  'CLOSING_STATEMENT',
  'DEED',
  'TITLE_INSURANCE',
  'LEASE_AGREEMENT',
  'RENTAL_APPLICATION',
  'OTHER',
]);

const CreateEnvelopeSchema = z.object({
  name: z.string().max(200),
  type: DocumentTypeEnum,
  propertyId: z.string().uuid().optional(),
  transactionId: z.string().uuid().optional(),
  templateId: z.string().optional(),
  recipients: z.array(z.object({
    email: z.string().email(),
    name: z.string(),
    role: z.enum(['BUYER', 'SELLER', 'AGENT', 'BROKER', 'ATTORNEY', 'TITLE_COMPANY', 'LENDER', 'OTHER']),
    routingOrder: z.number().int().min(1),
    signatureRequired: z.boolean().default(true),
    initialsRequired: z.boolean().default(false),
    dateRequired: z.boolean().default(false),
  })),
  message: z.string().max(1000).optional(),
  expirationDays: z.number().int().min(1).max(365).default(30),
  reminderEnabled: z.boolean().default(true),
  reminderDelay: z.number().int().min(1).max(30).default(3),
  reminderFrequency: z.number().int().min(1).max(30).default(3),
});

const BulkSendSchema = z.object({
  templateId: z.string(),
  recipients: z.array(z.object({
    email: z.string().email(),
    name: z.string(),
    propertyId: z.string().uuid().optional(),
    customFields: z.record(z.string()).optional(),
  })),
  emailSubject: z.string().max(200),
  emailMessage: z.string().max(1000).optional(),
});

// ============================================================================
// DOCUMENT TEMPLATES
// ============================================================================

// List available templates
router.get('/templates', authenticate, asyncHandler(async (req: AuthRequest, res: Response) => {
  const cacheKey = 'docusign:templates';
  const cached = await redis.get(cacheKey);
  
  if (cached) {
    return res.json(JSON.parse(cached));
  }
  
  // Get DocuSign templates
  const docusignTemplates = await docusign.listTemplates();
  
  // Get custom templates from database
  const customTemplates = await prisma.documentTemplate.findMany({
    where: {
      OR: [
        { isPublic: true },
        { createdById: req.user!.id },
        { agentId: req.user!.agentId },
      ],
    },
    orderBy: { usageCount: 'desc' },
  });
  
  const templates = {
    docusign: docusignTemplates.map(t => ({
      id: t.templateId,
      name: t.name,
      description: t.description,
      source: 'DOCUSIGN',
      roles: t.recipients?.signers?.map((s: any) => s.roleName) || [],
    })),
    custom: customTemplates.map(t => ({
      id: t.id,
      name: t.name,
      description: t.description,
      type: t.type,
      source: 'CUSTOM',
    })),
  };
  
  await redis.set(cacheKey, JSON.stringify(templates), 'EX', 3600);
  
  res.json(templates);
}));

// Create custom template
router.post('/templates', authenticate, requireAgent, upload.single('document'), asyncHandler(async (req: AuthRequest, res: Response) => {
  if (!req.file) {
    return res.status(400).json({ error: 'No document provided' });
  }
  
  const { name, description, type, isPublic, fields } = req.body;
  
  const key = `templates/${req.user!.agentId}/${uuidv4()}.pdf`;
  
  await s3.send(new PutObjectCommand({
    Bucket: process.env.S3_BUCKET,
    Key: key,
    Body: req.file.buffer,
    ContentType: req.file.mimetype,
  }));
  
  const template = await prisma.documentTemplate.create({
    data: {
      name,
      description,
      type,
      isPublic: isPublic === 'true',
      s3Key: key,
      fields: fields ? JSON.parse(fields) : [],
      createdById: req.user!.id,
      agentId: req.user!.agentId,
    },
  });
  
  // Invalidate cache
  await redis.del('docusign:templates');
  
  res.status(201).json(template);
}));

// ============================================================================
// ENVELOPES (SIGNING REQUESTS)
// ============================================================================

// Create envelope with document upload
router.post('/envelopes', authenticate, upload.array('documents', 10), asyncHandler(async (req: AuthRequest, res: Response) => {
  const data = CreateEnvelopeSchema.parse(JSON.parse(req.body.data));
  const files = req.files as Express.Multer.File[];
  
  if (!files?.length && !data.templateId) {
    return res.status(400).json({ error: 'Either documents or templateId required' });
  }
  
  // Verify property/transaction access if provided
  if (data.propertyId) {
    const property = await prisma.property.findFirst({
      where: {
        id: data.propertyId,
        OR: [
          { ownerId: req.user!.id },
          { agentId: req.user!.agentId },
        ],
      },
    });
    if (!property) {
      return res.status(403).json({ error: 'Property access denied' });
    }
  }
  
  // Prepare documents
  const documents = files?.map((file, index) => ({
    documentId: (index + 1).toString(),
    name: file.originalname,
    content: file.buffer,
  }));
  
  // Create DocuSign envelope
  const { envelopeId, uri } = await docusign.createEnvelope({
    templateId: data.templateId,
    documents,
    recipients: data.recipients.map(r => ({
      email: r.email,
      name: r.name,
      roleName: r.role,
      routingOrder: r.routingOrder,
      tabs: {
        signHereTabs: r.signatureRequired ? [{ documentId: '1', pageNumber: '1', xPosition: '100', yPosition: '700' }] : [],
        initialHereTabs: r.initialsRequired ? [{ documentId: '1', pageNumber: '1', xPosition: '100', yPosition: '750' }] : [],
        dateSignedTabs: r.dateRequired ? [{ documentId: '1', pageNumber: '1', xPosition: '400', yPosition: '700' }] : [],
      },
    })),
    emailSubject: `Please sign: ${data.name}`,
    emailBlurb: data.message,
    status: 'sent',
  });
  
  // Store envelope in database
  const envelope = await prisma.signingEnvelope.create({
    data: {
      docusignEnvelopeId: envelopeId,
      name: data.name,
      type: data.type,
      propertyId: data.propertyId,
      transactionId: data.transactionId,
      createdById: req.user!.id,
      status: 'SENT',
      expiresAt: new Date(Date.now() + data.expirationDays * 24 * 60 * 60 * 1000),
      recipients: {
        create: data.recipients.map(r => ({
          email: r.email,
          name: r.name,
          role: r.role,
          routingOrder: r.routingOrder,
          status: 'SENT',
        })),
      },
    },
    include: {
      recipients: true,
    },
  });
  
  // Store documents in S3
  if (files?.length) {
    for (const file of files) {
      const key = `envelopes/${envelope.id}/${file.originalname}`;
      await s3.send(new PutObjectCommand({
        Bucket: process.env.S3_BUCKET,
        Key: key,
        Body: file.buffer,
        ContentType: file.mimetype,
      }));
      
      await prisma.envelopeDocument.create({
        data: {
          envelopeId: envelope.id,
          name: file.originalname,
          s3Key: key,
          mimeType: file.mimetype,
          size: file.size,
        },
      });
    }
  }
  
  // Notify recipients
  await prisma.notification.createMany({
    data: data.recipients.map(r => ({
      userId: r.email, // Will need to look up by email
      type: 'DOCUMENT_TO_SIGN',
      title: 'Document Ready for Signature',
      message: `You have a document "${data.name}" waiting for your signature`,
      data: { envelopeId: envelope.id },
      priority: 'HIGH',
    })),
  });
  
  res.status(201).json(envelope);
}));

// List envelopes
router.get('/envelopes', authenticate, asyncHandler(async (req: AuthRequest, res: Response) => {
  const {
    status,
    type,
    propertyId,
    transactionId,
    role, // 'sender' or 'recipient'
    limit = '20',
    offset = '0',
  } = req.query;
  
  const where: any = {};
  
  if (role === 'sender') {
    where.createdById = req.user!.id;
  } else if (role === 'recipient') {
    where.recipients = { some: { email: req.user!.email } };
  } else {
    where.OR = [
      { createdById: req.user!.id },
      { recipients: { some: { email: req.user!.email } } },
    ];
  }
  
  if (status) where.status = status;
  if (type) where.type = type;
  if (propertyId) where.propertyId = propertyId;
  if (transactionId) where.transactionId = transactionId;
  
  const [envelopes, total] = await Promise.all([
    prisma.signingEnvelope.findMany({
      where,
      include: {
        property: { select: { id: true, title: true, address: true } },
        transaction: { select: { id: true, status: true } },
        recipients: true,
        createdBy: { select: { firstName: true, lastName: true } },
        _count: { select: { documents: true } },
      },
      orderBy: { createdAt: 'desc' },
      take: parseInt(limit as string),
      skip: parseInt(offset as string),
    }),
    prisma.signingEnvelope.count({ where }),
  ]);
  
  res.json({
    envelopes,
    total,
    limit: parseInt(limit as string),
    offset: parseInt(offset as string),
  });
}));

// Get envelope details
router.get('/envelopes/:id', authenticate, asyncHandler(async (req: AuthRequest, res: Response) => {
  const { id } = req.params;
  
  const envelope = await prisma.signingEnvelope.findFirst({
    where: {
      id,
      OR: [
        { createdById: req.user!.id },
        { recipients: { some: { email: req.user!.email } } },
      ],
    },
    include: {
      property: { select: { id: true, title: true, address: true } },
      transaction: true,
      recipients: true,
      documents: true,
      auditTrail: { orderBy: { createdAt: 'asc' } },
      createdBy: { select: { firstName: true, lastName: true } },
    },
  });
  
  if (!envelope) {
    return res.status(404).json({ error: 'Envelope not found' });
  }
  
  // Get live status from DocuSign
  if (envelope.docusignEnvelopeId) {
    const docusignStatus = await docusign.getEnvelopeStatus(envelope.docusignEnvelopeId);
    
    // Update local status if changed
    if (docusignStatus.status !== envelope.status.toLowerCase()) {
      await prisma.signingEnvelope.update({
        where: { id },
        data: { status: docusignStatus.status.toUpperCase() },
      });
    }
  }
  
  res.json(envelope);
}));

// Get signing URL for recipient
router.get('/envelopes/:id/signing-url', authenticate, asyncHandler(async (req: AuthRequest, res: Response) => {
  const { id } = req.params;
  
  const envelope = await prisma.signingEnvelope.findFirst({
    where: {
      id,
      recipients: { some: { email: req.user!.email } },
      status: { in: ['SENT', 'DELIVERED'] },
    },
  });
  
  if (!envelope) {
    return res.status(404).json({ error: 'Envelope not found or not ready for signing' });
  }
  
  const returnUrl = `${process.env.APP_URL}/documents/signed?envelopeId=${id}`;
  
  const signingUrl = await docusign.getSigningUrl(
    envelope.docusignEnvelopeId!,
    req.user!.email,
    `${req.user!.firstName} ${req.user!.lastName}`,
    returnUrl
  );
  
  // Log audit event
  await prisma.envelopeAuditEvent.create({
    data: {
      envelopeId: id,
      event: 'SIGNING_URL_GENERATED',
      actor: req.user!.email,
      details: { ip: req.ip },
    },
  });
  
  res.json({ signingUrl });
}));

// Download signed document
router.get('/envelopes/:id/download', authenticate, asyncHandler(async (req: AuthRequest, res: Response) => {
  const { id } = req.params;
  const { format = 'combined' } = req.query; // combined, separate, certificate
  
  const envelope = await prisma.signingEnvelope.findFirst({
    where: {
      id,
      OR: [
        { createdById: req.user!.id },
        { recipients: { some: { email: req.user!.email } } },
      ],
    },
  });
  
  if (!envelope) {
    return res.status(404).json({ error: 'Envelope not found' });
  }
  
  if (envelope.status !== 'COMPLETED') {
    return res.status(400).json({ error: 'Document not yet completed' });
  }
  
  const documentId = format === 'certificate' ? 'certificate' : 'combined';
  const document = await docusign.downloadDocument(envelope.docusignEnvelopeId!, documentId);
  
  // Log download
  await prisma.envelopeAuditEvent.create({
    data: {
      envelopeId: id,
      event: 'DOCUMENT_DOWNLOADED',
      actor: req.user!.email,
      details: { format },
    },
  });
  
  res.setHeader('Content-Type', 'application/pdf');
  res.setHeader('Content-Disposition', `attachment; filename="${envelope.name}-signed.pdf"`);
  res.send(document);
}));

// Void envelope
router.post('/envelopes/:id/void', authenticate, asyncHandler(async (req: AuthRequest, res: Response) => {
  const { id } = req.params;
  const { reason } = req.body;
  
  if (!reason) {
    return res.status(400).json({ error: 'Void reason is required' });
  }
  
  const envelope = await prisma.signingEnvelope.findFirst({
    where: {
      id,
      createdById: req.user!.id,
      status: { in: ['SENT', 'DELIVERED'] },
    },
  });
  
  if (!envelope) {
    return res.status(404).json({ error: 'Envelope not found or cannot be voided' });
  }
  
  await docusign.voidEnvelope(envelope.docusignEnvelopeId!, reason);
  
  await prisma.signingEnvelope.update({
    where: { id },
    data: {
      status: 'VOIDED',
      voidedReason: reason,
      voidedAt: new Date(),
    },
  });
  
  // Notify recipients
  const recipients = await prisma.envelopeRecipient.findMany({
    where: { envelopeId: id },
  });
  
  // Log audit event
  await prisma.envelopeAuditEvent.create({
    data: {
      envelopeId: id,
      event: 'ENVELOPE_VOIDED',
      actor: req.user!.email,
      details: { reason },
    },
  });
  
  res.json({ success: true, message: 'Envelope voided' });
}));

// Resend envelope
router.post('/envelopes/:id/resend', authenticate, asyncHandler(async (req: AuthRequest, res: Response) => {
  const { id } = req.params;
  const { recipientId } = req.body;
  
  const envelope = await prisma.signingEnvelope.findFirst({
    where: {
      id,
      createdById: req.user!.id,
      status: { in: ['SENT', 'DELIVERED'] },
    },
    include: { recipients: true },
  });
  
  if (!envelope) {
    return res.status(404).json({ error: 'Envelope not found' });
  }
  
  // Resend via DocuSign would go here
  // For now, just log the action
  
  await prisma.envelopeAuditEvent.create({
    data: {
      envelopeId: id,
      event: 'ENVELOPE_RESENT',
      actor: req.user!.email,
      details: { recipientId },
    },
  });
  
  res.json({ success: true, message: 'Envelope resent' });
}));

// ============================================================================
// WEBHOOKS
// ============================================================================

// DocuSign Connect webhook
router.post('/webhook/docusign', asyncHandler(async (req: Request, res: Response) => {
  // Verify HMAC signature
  const signature = req.headers['x-docusign-signature-1'] as string;
  const hmac = crypto.createHmac('sha256', process.env.DOCUSIGN_HMAC_KEY!);
  hmac.update(JSON.stringify(req.body));
  const expectedSignature = hmac.digest('base64');
  
  if (signature !== expectedSignature) {
    return res.status(401).json({ error: 'Invalid signature' });
  }
  
  const { event, data } = req.body;
  const envelopeId = data?.envelopeId;
  
  // Find our envelope
  const envelope = await prisma.signingEnvelope.findFirst({
    where: { docusignEnvelopeId: envelopeId },
  });
  
  if (!envelope) {
    return res.status(200).json({ received: true }); // Acknowledge but ignore
  }
  
  switch (event) {
    case 'envelope-sent':
      await prisma.signingEnvelope.update({
        where: { id: envelope.id },
        data: { status: 'SENT', sentAt: new Date() },
      });
      break;
      
    case 'envelope-delivered':
      await prisma.signingEnvelope.update({
        where: { id: envelope.id },
        data: { status: 'DELIVERED' },
      });
      break;
      
    case 'envelope-completed':
      await prisma.signingEnvelope.update({
        where: { id: envelope.id },
        data: { status: 'COMPLETED', completedAt: new Date() },
      });
      
      // Download and store signed document
      const signedDoc = await docusign.downloadDocument(envelopeId, 'combined');
      const key = `envelopes/${envelope.id}/signed-${Date.now()}.pdf`;
      
      await s3.send(new PutObjectCommand({
        Bucket: process.env.S3_BUCKET,
        Key: key,
        Body: signedDoc,
        ContentType: 'application/pdf',
      }));
      
      await prisma.envelopeDocument.create({
        data: {
          envelopeId: envelope.id,
          name: `${envelope.name}-signed.pdf`,
          s3Key: key,
          mimeType: 'application/pdf',
          size: signedDoc.length,
          isSigned: true,
        },
      });
      
      // Notify creator
      await prisma.notification.create({
        data: {
          userId: envelope.createdById,
          type: 'DOCUMENT_COMPLETED',
          title: 'Document Fully Signed',
          message: `All parties have signed "${envelope.name}"`,
          data: { envelopeId: envelope.id },
          priority: 'HIGH',
        },
      });
      break;
      
    case 'envelope-declined':
      await prisma.signingEnvelope.update({
        where: { id: envelope.id },
        data: { status: 'DECLINED', declinedAt: new Date() },
      });
      
      // Notify creator
      await prisma.notification.create({
        data: {
          userId: envelope.createdById,
          type: 'DOCUMENT_DECLINED',
          title: 'Document Declined',
          message: `"${envelope.name}" was declined by a recipient`,
          data: { envelopeId: envelope.id },
          priority: 'URGENT',
        },
      });
      break;
      
    case 'recipient-completed':
      await prisma.envelopeRecipient.updateMany({
        where: {
          envelopeId: envelope.id,
          email: data.recipientEmail,
        },
        data: { status: 'COMPLETED', signedAt: new Date() },
      });
      break;
      
    case 'recipient-declined':
      await prisma.envelopeRecipient.updateMany({
        where: {
          envelopeId: envelope.id,
          email: data.recipientEmail,
        },
        data: { 
          status: 'DECLINED', 
          declinedReason: data.declineReason,
        },
      });
      break;
  }
  
  // Log audit event
  await prisma.envelopeAuditEvent.create({
    data: {
      envelopeId: envelope.id,
      event: event.toUpperCase().replace(/-/g, '_'),
      actor: 'DOCUSIGN_WEBHOOK',
      details: data,
    },
  });
  
  res.status(200).json({ received: true });
}));

// ============================================================================
// BULK SEND
// ============================================================================

// Bulk send documents
router.post('/bulk-send', authenticate, requireAgent, asyncHandler(async (req: AuthRequest, res: Response) => {
  const data = BulkSendSchema.parse(req.body);
  
  const results = [];
  
  for (const recipient of data.recipients) {
    try {
      const { envelopeId } = await docusign.createEnvelope({
        templateId: data.templateId,
        recipients: [{
          email: recipient.email,
          name: recipient.name,
          routingOrder: 1,
        }],
        emailSubject: data.emailSubject,
        emailBlurb: data.emailMessage,
        status: 'sent',
      });
      
      const envelope = await prisma.signingEnvelope.create({
        data: {
          docusignEnvelopeId: envelopeId,
          name: data.emailSubject,
          type: 'OTHER',
          propertyId: recipient.propertyId,
          createdById: req.user!.id,
          status: 'SENT',
          recipients: {
            create: {
              email: recipient.email,
              name: recipient.name,
              role: 'OTHER',
              routingOrder: 1,
              status: 'SENT',
            },
          },
        },
      });
      
      results.push({ success: true, email: recipient.email, envelopeId: envelope.id });
    } catch (error: any) {
      results.push({ success: false, email: recipient.email, error: error.message });
    }
  }
  
  res.json({
    sent: results.filter(r => r.success).length,
    failed: results.filter(r => !r.success).length,
    results,
  });
}));

// ============================================================================
// ANALYTICS
// ============================================================================

// Get signing analytics
router.get('/analytics', authenticate, asyncHandler(async (req: AuthRequest, res: Response) => {
  const { period = '30' } = req.query;
  const since = new Date(Date.now() - parseInt(period as string) * 24 * 60 * 60 * 1000);
  
  const where = {
    createdById: req.user!.id,
    createdAt: { gte: since },
  };
  
  const [total, byStatus, byType, avgCompletionTime] = await Promise.all([
    prisma.signingEnvelope.count({ where }),
    prisma.signingEnvelope.groupBy({
      by: ['status'],
      where,
      _count: true,
    }),
    prisma.signingEnvelope.groupBy({
      by: ['type'],
      where,
      _count: true,
    }),
    prisma.signingEnvelope.aggregate({
      where: { ...where, status: 'COMPLETED' },
      _avg: {
        // Would need to calculate from sentAt to completedAt
      },
    }),
  ]);
  
  // Calculate completion rate
  const completed = byStatus.find(s => s.status === 'COMPLETED')?._count || 0;
  const completionRate = total > 0 ? Math.round((completed / total) * 100) : 0;
  
  res.json({
    total,
    completionRate,
    byStatus: byStatus.reduce((acc, s) => ({ ...acc, [s.status]: s._count }), {}),
    byType: byType.reduce((acc, t) => ({ ...acc, [t.type]: t._count }), {}),
    period: parseInt(period as string),
  });
}));

export default router;
Video · TS
import { Router, Request, Response } from 'express';
import { z } from 'zod';
import { prisma } from '../utils/prisma';
import { redis } from '../utils/redis';
import { authenticate, optionalAuthenticate, requireAgent, AuthRequest } from '../middleware/auth';
import { asyncHandler } from '../middleware/errorHandler';
import twilio from 'twilio';
import { v4 as uuidv4 } from 'uuid';

const router = Router();

// Twilio client
const twilioClient = twilio(
  process.env.TWILIO_ACCOUNT_SID,
  process.env.TWILIO_AUTH_TOKEN
);

const AccessToken = twilio.jwt.AccessToken;
const VideoGrant = AccessToken.VideoGrant;
const ChatGrant = AccessToken.ChatGrant;

// ============================================================================
// SCHEMAS
// ============================================================================

const CallTypeEnum = z.enum([
  'VIRTUAL_TOUR',
  'PROPERTY_WALKTHROUGH',
  'CONSULTATION',
  'SHOWING',
  'NEGOTIATION',
  'CLOSING_MEETING',
  'INTERVIEW',
  'SUPPORT',
  'OTHER',
]);

const CreateRoomSchema = z.object({
  name: z.string().max(200),
  type: CallTypeEnum,
  propertyId: z.string().uuid().optional(),
  transactionId: z.string().uuid().optional(),
  scheduledAt: z.string().datetime().optional(),
  duration: z.number().int().min(15).max(480).default(60), // minutes
  maxParticipants: z.number().int().min(2).max(50).default(10),
  isRecorded: z.boolean().default(false),
  waitingRoomEnabled: z.boolean().default(true),
  participants: z.array(z.object({
    userId: z.string().uuid().optional(),
    email: z.string().email(),
    name: z.string(),
    role: z.enum(['HOST', 'CO_HOST', 'PARTICIPANT', 'VIEWER']),
  })).optional(),
  settings: z.object({
    enableChat: z.boolean().default(true),
    enableScreenShare: z.boolean().default(true),
    enableWhiteboard: z.boolean().default(false),
    enableRecording: z.boolean().default(false),
    enableTranscription: z.boolean().default(false),
    autoStartRecording: z.boolean().default(false),
    muteOnEntry: z.boolean().default(false),
  }).optional(),
  description: z.string().max(1000).optional(),
  agenda: z.array(z.string()).optional(),
});

const UpdateRoomSchema = CreateRoomSchema.partial();

const ScheduleRecurringSchema = z.object({
  name: z.string().max(200),
  type: CallTypeEnum,
  pattern: z.enum(['DAILY', 'WEEKLY', 'BIWEEKLY', 'MONTHLY']),
  startDate: z.string().datetime(),
  endDate: z.string().datetime().optional(),
  occurrences: z.number().int().min(1).max(52).optional(),
  duration: z.number().int().min(15).max(480).default(60),
  participants: z.array(z.object({
    email: z.string().email(),
    name: z.string(),
    role: z.enum(['HOST', 'CO_HOST', 'PARTICIPANT']),
  })),
  settings: z.object({
    enableChat: z.boolean().default(true),
    enableScreenShare: z.boolean().default(true),
  }).optional(),
});

// ============================================================================
// ROOM MANAGEMENT
// ============================================================================

// Create video room
router.post('/rooms', authenticate, asyncHandler(async (req: AuthRequest, res: Response) => {
  const data = CreateRoomSchema.parse(req.body);
  
  // Generate unique room name
  const roomUniqueName = `dharma-${uuidv4()}`;
  
  // Create Twilio room
  const twilioRoom = await twilioClient.video.v1.rooms.create({
    uniqueName: roomUniqueName,
    type: data.maxParticipants > 4 ? 'group' : 'group-small',
    maxParticipants: data.maxParticipants,
    recordParticipantsOnConnect: data.settings?.autoStartRecording || false,
    statusCallback: `${process.env.APP_URL}/api/video/webhook/room-status`,
    statusCallbackMethod: 'POST',
  });
  
  // Create room in database
  const room = await prisma.videoRoom.create({
    data: {
      twilioSid: twilioRoom.sid,
      uniqueName: roomUniqueName,
      name: data.name,
      type: data.type,
      propertyId: data.propertyId,
      transactionId: data.transactionId,
      hostId: req.user!.id,
      scheduledAt: data.scheduledAt ? new Date(data.scheduledAt) : null,
      duration: data.duration,
      maxParticipants: data.maxParticipants,
      isRecorded: data.isRecorded,
      waitingRoomEnabled: data.waitingRoomEnabled,
      settings: data.settings || {},
      description: data.description,
      agenda: data.agenda || [],
      status: 'SCHEDULED',
    },
  });
  
  // Create participant records
  if (data.participants?.length) {
    await prisma.videoParticipant.createMany({
      data: data.participants.map(p => ({
        roomId: room.id,
        userId: p.userId,
        email: p.email,
        name: p.name,
        role: p.role,
        status: 'INVITED',
      })),
    });
    
    // Send invitations
    await prisma.notification.createMany({
      data: data.participants.map(p => ({
        userId: p.userId || p.email, // Will need to look up by email
        type: 'VIDEO_CALL_INVITATION',
        title: 'Video Call Invitation',
        message: `You've been invited to "${data.name}"${data.scheduledAt ? ` on ${new Date(data.scheduledAt).toLocaleString()}` : ''}`,
        data: { roomId: room.id },
      })),
    });
  }
  
  // Generate host token immediately
  const hostToken = generateAccessToken(req.user!.id, roomUniqueName, true);
  
  res.status(201).json({
    room,
    hostToken,
    joinUrl: `${process.env.APP_URL}/video/${room.id}`,
  });
}));

// List rooms
router.get('/rooms', authenticate, asyncHandler(async (req: AuthRequest, res: Response) => {
  const {
    status,
    type,
    propertyId,
    upcoming,
    past,
    limit = '20',
    offset = '0',
  } = req.query;
  
  const where: any = {
    OR: [
      { hostId: req.user!.id },
      { participants: { some: { userId: req.user!.id } } },
      { participants: { some: { email: req.user!.email } } },
    ],
  };
  
  if (status) where.status = status;
  if (type) where.type = type;
  if (propertyId) where.propertyId = propertyId;
  
  if (upcoming === 'true') {
    where.scheduledAt = { gte: new Date() };
    where.status = { in: ['SCHEDULED', 'IN_PROGRESS'] };
  }
  
  if (past === 'true') {
    where.OR = [
      { status: 'COMPLETED' },
      { endedAt: { lt: new Date() } },
    ];
  }
  
  const [rooms, total] = await Promise.all([
    prisma.videoRoom.findMany({
      where,
      include: {
        host: { select: { id: true, firstName: true, lastName: true, avatar: true } },
        property: { select: { id: true, title: true, address: true, photos: { take: 1 } } },
        participants: { select: { name: true, role: true, status: true } },
        _count: { select: { participants: true, recordings: true } },
      },
      orderBy: { scheduledAt: 'asc' },
      take: parseInt(limit as string),
      skip: parseInt(offset as string),
    }),
    prisma.videoRoom.count({ where }),
  ]);
  
  res.json({
    rooms,
    total,
    limit: parseInt(limit as string),
    offset: parseInt(offset as string),
  });
}));

// Get room details
router.get('/rooms/:id', authenticate, asyncHandler(async (req: AuthRequest, res: Response) => {
  const { id } = req.params;
  
  const room = await prisma.videoRoom.findFirst({
    where: {
      id,
      OR: [
        { hostId: req.user!.id },
        { participants: { some: { userId: req.user!.id } } },
        { participants: { some: { email: req.user!.email } } },
      ],
    },
    include: {
      host: { select: { id: true, firstName: true, lastName: true, avatar: true, email: true } },
      property: {
        select: {
          id: true,
          title: true,
          address: true,
          city: true,
          state: true,
          photos: { take: 5 },
        },
      },
      transaction: { select: { id: true, status: true } },
      participants: {
        include: {
          user: { select: { firstName: true, lastName: true, avatar: true } },
        },
      },
      recordings: true,
      chatMessages: {
        orderBy: { createdAt: 'asc' },
        take: 100,
      },
    },
  });
  
  if (!room) {
    return res.status(404).json({ error: 'Room not found' });
  }
  
  // Get current participant count if room is live
  let currentParticipants = 0;
  if (room.status === 'IN_PROGRESS' && room.twilioSid) {
    try {
      const twilioRoom = await twilioClient.video.v1.rooms(room.twilioSid).fetch();
      currentParticipants = twilioRoom.maxParticipants; // Would need actual count from participants list
    } catch (e) {
      // Room may not exist yet in Twilio
    }
  }
  
  res.json({
    ...room,
    currentParticipants,
  });
}));

// Update room
router.put('/rooms/:id', authenticate, asyncHandler(async (req: AuthRequest, res: Response) => {
  const { id } = req.params;
  const data = UpdateRoomSchema.parse(req.body);
  
  const room = await prisma.videoRoom.findFirst({
    where: {
      id,
      hostId: req.user!.id,
      status: { in: ['SCHEDULED'] },
    },
  });
  
  if (!room) {
    return res.status(404).json({ error: 'Room not found or cannot be modified' });
  }
  
  const updated = await prisma.videoRoom.update({
    where: { id },
    data: {
      ...data,
      scheduledAt: data.scheduledAt ? new Date(data.scheduledAt) : undefined,
    },
  });
  
  // Notify participants of changes
  if (data.scheduledAt) {
    const participants = await prisma.videoParticipant.findMany({
      where: { roomId: id },
    });
    
    await prisma.notification.createMany({
      data: participants.map(p => ({
        userId: p.userId || p.email,
        type: 'VIDEO_CALL_UPDATED',
        title: 'Video Call Rescheduled',
        message: `"${updated.name}" has been rescheduled to ${new Date(data.scheduledAt!).toLocaleString()}`,
        data: { roomId: id },
      })),
    });
  }
  
  res.json(updated);
}));

// Cancel room
router.post('/rooms/:id/cancel', authenticate, asyncHandler(async (req: AuthRequest, res: Response) => {
  const { id } = req.params;
  const { reason } = req.body;
  
  const room = await prisma.videoRoom.findFirst({
    where: {
      id,
      hostId: req.user!.id,
      status: { in: ['SCHEDULED'] },
    },
    include: { participants: true },
  });
  
  if (!room) {
    return res.status(404).json({ error: 'Room not found or cannot be cancelled' });
  }
  
  await prisma.videoRoom.update({
    where: { id },
    data: {
      status: 'CANCELLED',
      cancelledAt: new Date(),
      cancellationReason: reason,
    },
  });
  
  // Notify participants
  await prisma.notification.createMany({
    data: room.participants.map(p => ({
      userId: p.userId || p.email,
      type: 'VIDEO_CALL_CANCELLED',
      title: 'Video Call Cancelled',
      message: `"${room.name}" has been cancelled${reason ? `: ${reason}` : ''}`,
      data: { roomId: id },
    })),
  });
  
  res.json({ success: true, message: 'Room cancelled' });
}));

// ============================================================================
// JOIN & TOKENS
// ============================================================================

// Get access token to join room
router.post('/rooms/:id/token', authenticate, asyncHandler(async (req: AuthRequest, res: Response) => {
  const { id } = req.params;
  
  const room = await prisma.videoRoom.findFirst({
    where: {
      id,
      OR: [
        { hostId: req.user!.id },
        { participants: { some: { userId: req.user!.id } } },
        { participants: { some: { email: req.user!.email } } },
      ],
    },
    include: {
      participants: {
        where: {
          OR: [
            { userId: req.user!.id },
            { email: req.user!.email },
          ],
        },
      },
    },
  });
  
  if (!room) {
    return res.status(404).json({ error: 'Room not found or access denied' });
  }
  
  // Check waiting room
  if (room.waitingRoomEnabled && room.hostId !== req.user!.id) {
    const participant = room.participants[0];
    if (participant && participant.status === 'WAITING') {
      return res.status(403).json({ 
        error: 'Waiting for host approval',
        status: 'WAITING',
      });
    }
  }
  
  const isHost = room.hostId === req.user!.id;
  const token = generateAccessToken(req.user!.id, room.uniqueName, isHost);
  
  // Update participant status
  if (room.participants.length > 0) {
    await prisma.videoParticipant.update({
      where: { id: room.participants[0].id },
      data: { status: 'CONNECTED', joinedAt: new Date() },
    });
  }
  
  // Update room status if first join
  if (room.status === 'SCHEDULED') {
    await prisma.videoRoom.update({
      where: { id },
      data: { status: 'IN_PROGRESS', startedAt: new Date() },
    });
  }
  
  res.json({
    token,
    roomName: room.uniqueName,
    identity: req.user!.id,
    isHost,
  });
}));

// Generate guest token (for non-authenticated users)
router.post('/rooms/:id/guest-token', asyncHandler(async (req: Request, res: Response) => {
  const { id } = req.params;
  const { email, name } = req.body;
  
  if (!email || !name) {
    return res.status(400).json({ error: 'Email and name required' });
  }
  
  const room = await prisma.videoRoom.findFirst({
    where: {
      id,
      participants: { some: { email } },
    },
    include: {
      participants: { where: { email } },
    },
  });
  
  if (!room) {
    return res.status(403).json({ error: 'Not invited to this room' });
  }
  
  const participant = room.participants[0];
  
  // Check waiting room
  if (room.waitingRoomEnabled && participant.status === 'INVITED') {
    // Add to waiting room
    await prisma.videoParticipant.update({
      where: { id: participant.id },
      data: { status: 'WAITING' },
    });
    
    // Notify host
    await redis.publish(`video:${room.id}:waiting`, JSON.stringify({
      participantId: participant.id,
      email,
      name,
    }));
    
    return res.json({
      status: 'WAITING',
      message: 'Waiting for host to admit you',
    });
  }
  
  const guestId = `guest-${uuidv4()}`;
  const token = generateAccessToken(guestId, room.uniqueName, false);
  
  // Update participant
  await prisma.videoParticipant.update({
    where: { id: participant.id },
    data: { status: 'CONNECTED', joinedAt: new Date() },
  });
  
  res.json({
    token,
    roomName: room.uniqueName,
    identity: guestId,
    isHost: false,
  });
}));

// Admit participant from waiting room
router.post('/rooms/:id/admit', authenticate, asyncHandler(async (req: AuthRequest, res: Response) => {
  const { id } = req.params;
  const { participantId, admit } = req.body;
  
  const room = await prisma.videoRoom.findFirst({
    where: { id, hostId: req.user!.id },
  });
  
  if (!room) {
    return res.status(403).json({ error: 'Only host can admit participants' });
  }
  
  if (admit) {
    await prisma.videoParticipant.update({
      where: { id: participantId },
      data: { status: 'ADMITTED' },
    });
    
    // Notify participant they can join
    await redis.publish(`video:${id}:admitted`, JSON.stringify({ participantId }));
  } else {
    await prisma.videoParticipant.update({
      where: { id: participantId },
      data: { status: 'REJECTED' },
    });
  }
  
  res.json({ success: true });
}));

// ============================================================================
// IN-CALL FEATURES
// ============================================================================

// Start recording
router.post('/rooms/:id/recording/start', authenticate, asyncHandler(async (req: AuthRequest, res: Response) => {
  const { id } = req.params;
  
  const room = await prisma.videoRoom.findFirst({
    where: { id, hostId: req.user!.id, status: 'IN_PROGRESS' },
  });
  
  if (!room) {
    return res.status(404).json({ error: 'Room not found or not in progress' });
  }
  
  // Start Twilio recording
  const recording = await twilioClient.video.v1.rooms(room.twilioSid!)
    .recordings.create();
  
  await prisma.videoRecording.create({
    data: {
      roomId: room.id,
      twilioSid: recording.sid,
      status: 'RECORDING',
      startedAt: new Date(),
      startedById: req.user!.id,
    },
  });
  
  // Notify participants
  await redis.publish(`video:${id}:recording`, JSON.stringify({ status: 'started' }));
  
  res.json({ success: true, recordingSid: recording.sid });
}));

// Stop recording
router.post('/rooms/:id/recording/stop', authenticate, asyncHandler(async (req: AuthRequest, res: Response) => {
  const { id } = req.params;
  
  const room = await prisma.videoRoom.findFirst({
    where: { id, hostId: req.user!.id },
    include: {
      recordings: { where: { status: 'RECORDING' } },
    },
  });
  
  if (!room || !room.recordings.length) {
    return res.status(404).json({ error: 'No active recording found' });
  }
  
  const recording = room.recordings[0];
  
  // Stop Twilio recording
  await twilioClient.video.v1.rooms(room.twilioSid!)
    .recordings(recording.twilioSid!)
    .update({ status: 'stopped' });
  
  await prisma.videoRecording.update({
    where: { id: recording.id },
    data: { status: 'STOPPED', endedAt: new Date() },
  });
  
  // Notify participants
  await redis.publish(`video:${id}:recording`, JSON.stringify({ status: 'stopped' }));
  
  res.json({ success: true });
}));

// Send chat message
router.post('/rooms/:id/chat', authenticate, asyncHandler(async (req: AuthRequest, res: Response) => {
  const { id } = req.params;
  const { message, type = 'TEXT' } = req.body;
  
  const room = await prisma.videoRoom.findFirst({
    where: {
      id,
      OR: [
        { hostId: req.user!.id },
        { participants: { some: { userId: req.user!.id } } },
      ],
      status: 'IN_PROGRESS',
    },
  });
  
  if (!room) {
    return res.status(404).json({ error: 'Room not found or not active' });
  }
  
  const chatMessage = await prisma.videoChatMessage.create({
    data: {
      roomId: id,
      senderId: req.user!.id,
      message,
      type,
    },
    include: {
      sender: { select: { firstName: true, lastName: true, avatar: true } },
    },
  });
  
  // Broadcast via WebSocket/Redis
  await redis.publish(`video:${id}:chat`, JSON.stringify(chatMessage));
  
  res.status(201).json(chatMessage);
}));

// Share screen annotation/pointer
router.post('/rooms/:id/annotation', authenticate, asyncHandler(async (req: AuthRequest, res: Response) => {
  const { id } = req.params;
  const { type, data } = req.body; // type: 'pointer', 'drawing', 'highlight'
  
  // Broadcast to all participants
  await redis.publish(`video:${id}:annotation`, JSON.stringify({
    userId: req.user!.id,
    type,
    data,
    timestamp: Date.now(),
  }));
  
  res.json({ success: true });
}));

// ============================================================================
// END CALL
// ============================================================================

// End room
router.post('/rooms/:id/end', authenticate, asyncHandler(async (req: AuthRequest, res: Response) => {
  const { id } = req.params;
  
  const room = await prisma.videoRoom.findFirst({
    where: {
      id,
      hostId: req.user!.id,
      status: 'IN_PROGRESS',
    },
    include: { participants: true },
  });
  
  if (!room) {
    return res.status(404).json({ error: 'Room not found or not in progress' });
  }
  
  // End Twilio room
  if (room.twilioSid) {
    try {
      await twilioClient.video.v1.rooms(room.twilioSid).update({ status: 'completed' });
    } catch (e) {
      // Room may already be ended
    }
  }
  
  // Calculate duration
  const duration = room.startedAt 
    ? Math.round((Date.now() - room.startedAt.getTime()) / 60000)
    : 0;
  
  await prisma.videoRoom.update({
    where: { id },
    data: {
      status: 'COMPLETED',
      endedAt: new Date(),
      actualDuration: duration,
    },
  });
  
  // Update participant statuses
  await prisma.videoParticipant.updateMany({
    where: { roomId: id, status: 'CONNECTED' },
    data: { status: 'LEFT', leftAt: new Date() },
  });
  
  // Notify all participants
  await redis.publish(`video:${id}:ended`, JSON.stringify({ endedBy: req.user!.id }));
  
  res.json({ success: true, duration });
}));

// Leave room
router.post('/rooms/:id/leave', authenticate, asyncHandler(async (req: AuthRequest, res: Response) => {
  const { id } = req.params;
  
  await prisma.videoParticipant.updateMany({
    where: {
      roomId: id,
      OR: [
        { userId: req.user!.id },
        { email: req.user!.email },
      ],
    },
    data: { status: 'LEFT', leftAt: new Date() },
  });
  
  // Notify others
  await redis.publish(`video:${id}:participant-left`, JSON.stringify({
    userId: req.user!.id,
  }));
  
  res.json({ success: true });
}));

// ============================================================================
// RECORDINGS
// ============================================================================

// List recordings
router.get('/recordings', authenticate, asyncHandler(async (req: AuthRequest, res: Response) => {
  const { roomId, limit = '20', offset = '0' } = req.query;
  
  const where: any = {
    room: {
      OR: [
        { hostId: req.user!.id },
        { participants: { some: { userId: req.user!.id } } },
      ],
    },
    status: 'COMPLETED',
  };
  
  if (roomId) where.roomId = roomId;
  
  const [recordings, total] = await Promise.all([
    prisma.videoRecording.findMany({
      where,
      include: {
        room: { select: { id: true, name: true, type: true } },
        startedBy: { select: { firstName: true, lastName: true } },
      },
      orderBy: { startedAt: 'desc' },
      take: parseInt(limit as string),
      skip: parseInt(offset as string),
    }),
    prisma.videoRecording.count({ where }),
  ]);
  
  res.json({
    recordings,
    total,
    limit: parseInt(limit as string),
    offset: parseInt(offset as string),
  });
}));

// Get recording download URL
router.get('/recordings/:id/download', authenticate, asyncHandler(async (req: AuthRequest, res: Response) => {
  const { id } = req.params;
  
  const recording = await prisma.videoRecording.findFirst({
    where: {
      id,
      room: {
        OR: [
          { hostId: req.user!.id },
          { participants: { some: { userId: req.user!.id } } },
        ],
      },
    },
  });
  
  if (!recording) {
    return res.status(404).json({ error: 'Recording not found' });
  }
  
  if (!recording.s3Key) {
    return res.status(400).json({ error: 'Recording not yet processed' });
  }
  
  // Generate presigned URL
  const { getSignedUrl } = await import('@aws-sdk/s3-request-presigner');
  const { S3Client, GetObjectCommand } = await import('@aws-sdk/client-s3');
  
  const s3 = new S3Client({ region: process.env.AWS_REGION });
  const url = await getSignedUrl(
    s3,
    new GetObjectCommand({
      Bucket: process.env.S3_BUCKET,
      Key: recording.s3Key,
    }),
    { expiresIn: 3600 }
  );
  
  res.json({ url });
}));

// Delete recording
router.delete('/recordings/:id', authenticate, asyncHandler(async (req: AuthRequest, res: Response) => {
  const { id } = req.params;
  
  const recording = await prisma.videoRecording.findFirst({
    where: {
      id,
      room: { hostId: req.user!.id },
    },
  });
  
  if (!recording) {
    return res.status(404).json({ error: 'Recording not found' });
  }
  
  // Delete from S3
  if (recording.s3Key) {
    const { S3Client, DeleteObjectCommand } = await import('@aws-sdk/client-s3');
    const s3 = new S3Client({ region: process.env.AWS_REGION });
    await s3.send(new DeleteObjectCommand({
      Bucket: process.env.S3_BUCKET,
      Key: recording.s3Key,
    }));
  }
  
  await prisma.videoRecording.delete({ where: { id } });
  
  res.json({ success: true, message: 'Recording deleted' });
}));

// ============================================================================
// WEBHOOKS
// ============================================================================

// Twilio room status webhook
router.post('/webhook/room-status', asyncHandler(async (req: Request, res: Response) => {
  const { RoomSid, RoomStatus, StatusCallbackEvent } = req.body;
  
  const room = await prisma.videoRoom.findFirst({
    where: { twilioSid: RoomSid },
  });
  
  if (!room) {
    return res.status(200).send('OK');
  }
  
  switch (StatusCallbackEvent) {
    case 'room-created':
      // Room is ready
      break;
      
    case 'room-ended':
      await prisma.videoRoom.update({
        where: { id: room.id },
        data: { status: 'COMPLETED', endedAt: new Date() },
      });
      break;
      
    case 'participant-connected':
      const { ParticipantIdentity } = req.body;
      await prisma.videoParticipant.updateMany({
        where: { roomId: room.id, OR: [{ userId: ParticipantIdentity }, { email: ParticipantIdentity }] },
        data: { status: 'CONNECTED', joinedAt: new Date() },
      });
      break;
      
    case 'participant-disconnected':
      const { ParticipantIdentity: leftIdentity } = req.body;
      await prisma.videoParticipant.updateMany({
        where: { roomId: room.id, OR: [{ userId: leftIdentity }, { email: leftIdentity }] },
        data: { status: 'LEFT', leftAt: new Date() },
      });
      break;
      
    case 'recording-started':
      break;
      
    case 'recording-completed':
      const { RecordingSid } = req.body;
      // Get recording from Twilio and upload to S3
      const twilioRecording = await twilioClient.video.v1
        .recordings(RecordingSid)
        .fetch();
      
      // Download recording
      const response = await fetch(twilioRecording.links.media);
      const buffer = Buffer.from(await response.arrayBuffer());
      
      // Upload to S3
      const { S3Client, PutObjectCommand } = await import('@aws-sdk/client-s3');
      const s3 = new S3Client({ region: process.env.AWS_REGION });
      const key = `recordings/${room.id}/${RecordingSid}.mkv`;
      
      await s3.send(new PutObjectCommand({
        Bucket: process.env.S3_BUCKET,
        Key: key,
        Body: buffer,
        ContentType: 'video/x-matroska',
      }));
      
      await prisma.videoRecording.updateMany({
        where: { twilioSid: RecordingSid },
        data: {
          status: 'COMPLETED',
          s3Key: key,
          duration: twilioRecording.duration,
          size: buffer.length,
        },
      });
      break;
  }
  
  res.status(200).send('OK');
}));

// ============================================================================
// RECURRING MEETINGS
// ============================================================================

// Schedule recurring meeting
router.post('/rooms/recurring', authenticate, asyncHandler(async (req: AuthRequest, res: Response) => {
  const data = ScheduleRecurringSchema.parse(req.body);
  
  // Create recurring series
  const series = await prisma.videoRoomSeries.create({
    data: {
      name: data.name,
      type: data.type,
      pattern: data.pattern,
      hostId: req.user!.id,
      settings: data.settings || {},
      duration: data.duration,
    },
  });
  
  // Generate occurrences
  const occurrences = generateOccurrences(
    new Date(data.startDate),
    data.pattern,
    data.occurrences || 10,
    data.endDate ? new Date(data.endDate) : undefined
  );
  
  // Create rooms for each occurrence
  for (const date of occurrences) {
    const roomUniqueName = `dharma-${series.id}-${date.getTime()}`;
    
    const room = await prisma.videoRoom.create({
      data: {
        seriesId: series.id,
        uniqueName: roomUniqueName,
        name: data.name,
        type: data.type,
        hostId: req.user!.id,
        scheduledAt: date,
        duration: data.duration,
        settings: data.settings || {},
        status: 'SCHEDULED',
      },
    });
    
    // Add participants
    if (data.participants.length) {
      await prisma.videoParticipant.createMany({
        data: data.participants.map(p => ({
          roomId: room.id,
          email: p.email,
          name: p.name,
          role: p.role,
          status: 'INVITED',
        })),
      });
    }
  }
  
  res.status(201).json({
    series,
    occurrencesCreated: occurrences.length,
  });
}));

// Cancel recurring series
router.post('/rooms/recurring/:seriesId/cancel', authenticate, asyncHandler(async (req: AuthRequest, res: Response) => {
  const { seriesId } = req.params;
  const { cancelFuture = true } = req.body;
  
  const series = await prisma.videoRoomSeries.findFirst({
    where: { id: seriesId, hostId: req.user!.id },
  });
  
  if (!series) {
    return res.status(404).json({ error: 'Series not found' });
  }
  
  if (cancelFuture) {
    // Cancel all future rooms
    await prisma.videoRoom.updateMany({
      where: {
        seriesId,
        status: 'SCHEDULED',
        scheduledAt: { gte: new Date() },
      },
      data: { status: 'CANCELLED' },
    });
  }
  
  await prisma.videoRoomSeries.update({
    where: { id: seriesId },
    data: { isCancelled: true },
  });
  
  res.json({ success: true });
}));

// ============================================================================
// ANALYTICS
// ============================================================================

// Get video call analytics
router.get('/analytics', authenticate, asyncHandler(async (req: AuthRequest, res: Response) => {
  const { period = '30' } = req.query;
  const since = new Date(Date.now() - parseInt(period as string) * 24 * 60 * 60 * 1000);
  
  const where = {
    hostId: req.user!.id,
    createdAt: { gte: since },
  };
  
  const [total, byStatus, byType, avgDuration, totalParticipants] = await Promise.all([
    prisma.videoRoom.count({ where }),
    prisma.videoRoom.groupBy({
      by: ['status'],
      where,
      _count: true,
    }),
    prisma.videoRoom.groupBy({
      by: ['type'],
      where,
      _count: true,
    }),
    prisma.videoRoom.aggregate({
      where: { ...where, status: 'COMPLETED' },
      _avg: { actualDuration: true },
    }),
    prisma.videoParticipant.count({
      where: { room: where },
    }),
  ]);
  
  res.json({
    total,
    completed: byStatus.find(s => s.status === 'COMPLETED')?._count || 0,
    cancelled: byStatus.find(s => s.status === 'CANCELLED')?._count || 0,
    byType: byType.reduce((acc, t) => ({ ...acc, [t.type]: t._count }), {}),
    averageDuration: Math.round(avgDuration._avg.actualDuration || 0),
    totalParticipants,
    period: parseInt(period as string),
  });
}));

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

function generateAccessToken(identity: string, roomName: string, isHost: boolean): string {
  const token = new AccessToken(
    process.env.TWILIO_ACCOUNT_SID!,
    process.env.TWILIO_API_KEY!,
    process.env.TWILIO_API_SECRET!,
    { identity }
  );
  
  const videoGrant = new VideoGrant({
    room: roomName,
  });
  
  token.addGrant(videoGrant);
  
  // Add chat grant if enabled
  const chatGrant = new ChatGrant({
    serviceSid: process.env.TWILIO_CHAT_SERVICE_SID,
  });
  token.addGrant(chatGrant);
  
  return token.toJwt();
}

function generateOccurrences(
  startDate: Date,
  pattern: string,
  count: number,
  endDate?: Date
): Date[] {
  const occurrences: Date[] = [];
  let currentDate = new Date(startDate);
  
  while (occurrences.length < count && (!endDate || currentDate <= endDate)) {
    occurrences.push(new Date(currentDate));
    
    switch (pattern) {
      case 'DAILY':
        currentDate.setDate(currentDate.getDate() + 1);
        break;
      case 'WEEKLY':
        currentDate.setDate(currentDate.getDate() + 7);
        break;
      case 'BIWEEKLY':
        currentDate.setDate(currentDate.getDate() + 14);
        break;
      case 'MONTHLY':
        currentDate.setMonth(currentDate.getMonth() + 1);
        break;
    }
  }
  
  return occurrences;
}

export default router;















Page · TSX
'use client';

import { useState } from 'react';
import Link from 'next/link';
import { useRouter } from 'next/navigation';
import { motion, AnimatePresence } from 'framer-motion';

type UserRole = 'BUYER' | 'SELLER' | 'AGENT';

interface FormData {
  email: string;
  password: string;
  confirmPassword: string;
  firstName: string;
  lastName: string;
  phone: string;
  role: UserRole;
  // Agent-specific fields
  licenseNumber?: string;
  brokerage?: string;
  specializations?: string[];
  serviceAreas?: string[];
  bio?: string;
  // Buyer preferences
  preferVastu?: boolean;
  preferAstrology?: boolean;
  birthDate?: string;
  birthTime?: string;
  birthPlace?: string;
  // Terms
  agreeToTerms: boolean;
  agreeToPrivacy: boolean;
  subscribeNewsletter: boolean;
}

const specializations = [
  'Residential',
  'Commercial',
  'Luxury',
  'Investment',
  'First-Time Buyers',
  'Relocation',
  'Vastu Properties',
  'Green Homes',
  'Historic Properties',
  'New Construction',
];

export default function RegisterPage() {
  const router = useRouter();
  const [step, setStep] = useState(1);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [showPassword, setShowPassword] = useState(false);
  
  const [formData, setFormData] = useState<FormData>({
    email: '',
    password: '',
    confirmPassword: '',
    firstName: '',
    lastName: '',
    phone: '',
    role: 'BUYER',
    preferVastu: false,
    preferAstrology: false,
    agreeToTerms: false,
    agreeToPrivacy: false,
    subscribeNewsletter: true,
  });

  const updateField = (field: keyof FormData, value: any) => {
    setFormData(prev => ({ ...prev, [field]: value }));
    setError('');
  };

  const validateStep1 = () => {
    if (!formData.email || !formData.email.includes('@')) {
      setError('Please enter a valid email address');
      return false;
    }
    if (formData.password.length < 8) {
      setError('Password must be at least 8 characters');
      return false;
    }
    if (!/[A-Z]/.test(formData.password) || !/[0-9]/.test(formData.password)) {
      setError('Password must contain uppercase letter and number');
      return false;
    }
    if (formData.password !== formData.confirmPassword) {
      setError('Passwords do not match');
      return false;
    }
    return true;
  };

  const validateStep2 = () => {
    if (!formData.firstName.trim() || !formData.lastName.trim()) {
      setError('Please enter your full name');
      return false;
    }
    if (!formData.phone || formData.phone.length < 10) {
      setError('Please enter a valid phone number');
      return false;
    }
    return true;
  };

  const validateStep3 = () => {
    if (formData.role === 'AGENT') {
      if (!formData.licenseNumber?.trim()) {
        setError('License number is required for agents');
        return false;
      }
      if (!formData.brokerage?.trim()) {
        setError('Brokerage name is required');
        return false;
      }
    }
    return true;
  };

  const nextStep = () => {
    if (step === 1 && !validateStep1()) return;
    if (step === 2 && !validateStep2()) return;
    if (step === 3 && !validateStep3()) return;
    setStep(prev => Math.min(prev + 1, 4));
  };

  const prevStep = () => {
    setStep(prev => Math.max(prev - 1, 1));
    setError('');
  };

  const handleSubmit = async () => {
    if (!formData.agreeToTerms || !formData.agreeToPrivacy) {
      setError('Please agree to the terms and privacy policy');
      return;
    }

    setLoading(true);
    setError('');

    try {
      const response = await fetch('/api/auth/register', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(formData),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.message || 'Registration failed');
      }

      // Store token and redirect
      localStorage.setItem('token', data.token);
      router.push('/dashboard');
    } catch (err: any) {
      setError(err.message || 'Something went wrong');
    } finally {
      setLoading(false);
    }
  };

  const getPasswordStrength = () => {
    const password = formData.password;
    let strength = 0;
    if (password.length >= 8) strength++;
    if (password.length >= 12) strength++;
    if (/[A-Z]/.test(password)) strength++;
    if (/[0-9]/.test(password)) strength++;
    if (/[^A-Za-z0-9]/.test(password)) strength++;
    return strength;
  };

  const strengthColors = ['bg-red-500', 'bg-orange-500', 'bg-yellow-500', 'bg-lime-500', 'bg-green-500'];
  const strengthLabels = ['Very Weak', 'Weak', 'Fair', 'Good', 'Strong'];

  return (
    <div className="min-h-screen bg-gradient-to-br from-amber-50 via-orange-50 to-yellow-50">
      {/* Decorative Background */}
      <div className="absolute inset-0 overflow-hidden pointer-events-none">
        <div className="absolute top-0 right-0 w-96 h-96 bg-gradient-to-br from-orange-200/30 to-amber-200/30 rounded-full blur-3xl transform translate-x-1/2 -translate-y-1/2" />
        <div className="absolute bottom-0 left-0 w-96 h-96 bg-gradient-to-tr from-yellow-200/30 to-orange-200/30 rounded-full blur-3xl transform -translate-x-1/2 translate-y-1/2" />
        {/* Om Symbol Pattern */}
        <div className="absolute inset-0 opacity-5">
          <svg className="w-full h-full" viewBox="0 0 100 100" preserveAspectRatio="none">
            <pattern id="om-pattern" x="0" y="0" width="20" height="20" patternUnits="userSpaceOnUse">
              <text x="10" y="15" fontSize="12" textAnchor="middle" fill="currentColor">ॐ</text>
            </pattern>
            <rect fill="url(#om-pattern)" width="100" height="100" />
          </svg>
        </div>
      </div>

      <div className="relative z-10 flex min-h-screen">
        {/* Left Panel - Branding */}
        <div className="hidden lg:flex lg:w-1/2 bg-gradient-to-br from-orange-600 via-amber-600 to-yellow-600 p-12 flex-col justify-between">
          <div>
            <Link href="/" className="flex items-center gap-3">
              <div className="w-12 h-12 bg-white/20 backdrop-blur-sm rounded-xl flex items-center justify-center">
                <span className="text-2xl text-white">🏛️</span>
              </div>
              <div>
                <h1 className="text-2xl font-bold text-white">Dharma Realty</h1>
                <p className="text-white/80 text-sm">Sacred Spaces, Modern Living</p>
              </div>
            </Link>
          </div>

          <div className="space-y-8">
            <div>
              <h2 className="text-4xl font-bold text-white leading-tight">
                Begin Your Journey to<br />
                <span className="text-yellow-200">Harmonious Living</span>
              </h2>
              <p className="mt-4 text-white/90 text-lg">
                Join thousands of families who have found their perfect home aligned with 
                ancient wisdom and modern convenience.
              </p>
            </div>

            <div className="grid grid-cols-2 gap-4">
              {[
                { icon: '🏠', label: 'Vastu-Compliant Homes', value: '50,000+' },
                { icon: '⭐', label: 'Happy Families', value: '25,000+' },
                { icon: '🌟', label: 'Verified Agents', value: '1,000+' },
                { icon: '📍', label: 'Cities Covered', value: '100+' },
              ].map((stat, i) => (
                <div key={i} className="bg-white/10 backdrop-blur-sm rounded-xl p-4">
                  <span className="text-2xl">{stat.icon}</span>
                  <p className="text-2xl font-bold text-white mt-2">{stat.value}</p>
                  <p className="text-white/80 text-sm">{stat.label}</p>
                </div>
              ))}
            </div>
          </div>

          <div className="flex items-center gap-4">
            <div className="flex -space-x-3">
              {[1, 2, 3, 4].map(i => (
                <div key={i} className="w-10 h-10 rounded-full bg-white/20 border-2 border-white/30 flex items-center justify-center text-white text-sm">
                  {String.fromCharCode(64 + i)}
                </div>
              ))}
            </div>
            <p className="text-white/90">
              <span className="font-semibold">1,000+</span> new members this month
            </p>
          </div>
        </div>

        {/* Right Panel - Form */}
        <div className="flex-1 flex flex-col justify-center px-6 py-12 lg:px-12">
          <div className="mx-auto w-full max-w-lg">
            {/* Mobile Logo */}
            <div className="lg:hidden mb-8">
              <Link href="/" className="flex items-center gap-3">
                <div className="w-10 h-10 bg-gradient-to-br from-orange-500 to-amber-500 rounded-xl flex items-center justify-center">
                  <span className="text-xl text-white">🏛️</span>
                </div>
                <span className="text-xl font-bold text-gray-900">Dharma Realty</span>
              </Link>
            </div>

            {/* Progress Steps */}
            <div className="mb-8">
              <div className="flex items-center justify-between mb-2">
                {[1, 2, 3, 4].map(s => (
                  <div key={s} className="flex items-center">
                    <div
                      className={`w-10 h-10 rounded-full flex items-center justify-center font-semibold transition-all ${
                        s === step
                          ? 'bg-gradient-to-r from-orange-500 to-amber-500 text-white scale-110'
                          : s < step
                          ? 'bg-green-500 text-white'
                          : 'bg-gray-200 text-gray-500'
                      }`}
                    >
                      {s < step ? '✓' : s}
                    </div>
                    {s < 4 && (
                      <div className={`w-16 lg:w-24 h-1 mx-2 rounded ${s < step ? 'bg-green-500' : 'bg-gray-200'}`} />
                    )}
                  </div>
                ))}
              </div>
              <div className="flex justify-between text-sm text-gray-600">
                <span>Account</span>
                <span>Personal</span>
                <span>Role</span>
                <span>Confirm</span>
              </div>
            </div>

            <AnimatePresence mode="wait">
              <motion.div
                key={step}
                initial={{ opacity: 0, x: 20 }}
                animate={{ opacity: 1, x: 0 }}
                exit={{ opacity: 0, x: -20 }}
                transition={{ duration: 0.2 }}
              >
                {/* Step 1: Account Details */}
                {step === 1 && (
                  <div className="space-y-6">
                    <div>
                      <h2 className="text-2xl font-bold text-gray-900">Create your account</h2>
                      <p className="mt-1 text-gray-600">Enter your email and create a secure password</p>
                    </div>

                    <div className="space-y-4">
                      <div>
                        <label className="block text-sm font-medium text-gray-700 mb-1">Email Address</label>
                        <div className="relative">
                          <input
                            type="email"
                            value={formData.email}
                            onChange={e => updateField('email', e.target.value)}
                            className="w-full px-4 py-3 pl-11 border border-gray-300 rounded-xl focus:ring-2 focus:ring-orange-500 focus:border-orange-500 transition-all"
                            placeholder="you@example.com"
                          />
                          <svg className="absolute left-4 top-1/2 -translate-y-1/2 w-5 h-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 8l7.89 5.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />
                          </svg>
                        </div>
                      </div>

                      <div>
                        <label className="block text-sm font-medium text-gray-700 mb-1">Password</label>
                        <div className="relative">
                          <input
                            type={showPassword ? 'text' : 'password'}
                            value={formData.password}
                            onChange={e => updateField('password', e.target.value)}
                            className="w-full px-4 py-3 pl-11 pr-11 border border-gray-300 rounded-xl focus:ring-2 focus:ring-orange-500 focus:border-orange-500 transition-all"
                            placeholder="••••••••"
                          />
                          <svg className="absolute left-4 top-1/2 -translate-y-1/2 w-5 h-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z" />
                          </svg>
                          <button
                            type="button"
                            onClick={() => setShowPassword(!showPassword)}
                            className="absolute right-4 top-1/2 -translate-y-1/2 text-gray-400 hover:text-gray-600"
                          >
                            {showPassword ? (
                              <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.88 9.88l-3.29-3.29m7.532 7.532l3.29 3.29M3 3l3.59 3.59m0 0A9.953 9.953 0 0112 5c4.478 0 8.268 2.943 9.543 7a10.025 10.025 0 01-4.132 5.411m0 0L21 21" />
                              </svg>
                            ) : (
                              <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
                              </svg>
                            )}
                          </button>
                        </div>
                        {formData.password && (
                          <div className="mt-2">
                            <div className="flex gap-1 mb-1">
                              {[0, 1, 2, 3, 4].map(i => (
                                <div
                                  key={i}
                                  className={`h-1 flex-1 rounded ${
                                    i < getPasswordStrength() ? strengthColors[getPasswordStrength() - 1] : 'bg-gray-200'
                                  }`}
                                />
                              ))}
                            </div>
                            <p className="text-xs text-gray-500">
                              Password strength: <span className={`font-medium ${getPasswordStrength() >= 4 ? 'text-green-600' : 'text-gray-600'}`}>
                                {strengthLabels[getPasswordStrength() - 1] || 'Too weak'}
                              </span>
                            </p>
                          </div>
                        )}
                      </div>

                      <div>
                        <label className="block text-sm font-medium text-gray-700 mb-1">Confirm Password</label>
                        <div className="relative">
                          <input
                            type={showPassword ? 'text' : 'password'}
                            value={formData.confirmPassword}
                            onChange={e => updateField('confirmPassword', e.target.value)}
                            className="w-full px-4 py-3 pl-11 border border-gray-300 rounded-xl focus:ring-2 focus:ring-orange-500 focus:border-orange-500 transition-all"
                            placeholder="••••••••"
                          />
                          <svg className="absolute left-4 top-1/2 -translate-y-1/2 w-5 h-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
                          </svg>
                        </div>
                        {formData.confirmPassword && formData.password === formData.confirmPassword && (
                          <p className="mt-1 text-sm text-green-600 flex items-center gap-1">
                            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
                            </svg>
                            Passwords match
                          </p>
                        )}
                      </div>
                    </div>
                  </div>
                )}

                {/* Step 2: Personal Information */}
                {step === 2 && (
                  <div className="space-y-6">
                    <div>
                      <h2 className="text-2xl font-bold text-gray-900">Personal Information</h2>
                      <p className="mt-1 text-gray-600">Tell us a bit about yourself</p>
                    </div>

                    <div className="space-y-4">
                      <div className="grid grid-cols-2 gap-4">
                        <div>
                          <label className="block text-sm font-medium text-gray-700 mb-1">First Name</label>
                          <input
                            type="text"
                            value={formData.firstName}
                            onChange={e => updateField('firstName', e.target.value)}
                            className="w-full px-4 py-3 border border-gray-300 rounded-xl focus:ring-2 focus:ring-orange-500 focus:border-orange-500"
                            placeholder="First name"
                          />
                        </div>
                        <div>
                          <label className="block text-sm font-medium text-gray-700 mb-1">Last Name</label>
                          <input
                            type="text"
                            value={formData.lastName}
                            onChange={e => updateField('lastName', e.target.value)}
                            className="w-full px-4 py-3 border border-gray-300 rounded-xl focus:ring-2 focus:ring-orange-500 focus:border-orange-500"
                            placeholder="Last name"
                          />
                        </div>
                      </div>

                      <div>
                        <label className="block text-sm font-medium text-gray-700 mb-1">Phone Number</label>
                        <div className="relative">
                          <input
                            type="tel"
                            value={formData.phone}
                            onChange={e => updateField('phone', e.target.value)}
                            className="w-full px-4 py-3 pl-11 border border-gray-300 rounded-xl focus:ring-2 focus:ring-orange-500 focus:border-orange-500"
                            placeholder="+91 98765 43210"
                          />
                          <svg className="absolute left-4 top-1/2 -translate-y-1/2 w-5 h-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 5a2 2 0 012-2h3.28a1 1 0 01.948.684l1.498 4.493a1 1 0 01-.502 1.21l-2.257 1.13a11.042 11.042 0 005.516 5.516l1.13-2.257a1 1 0 011.21-.502l4.493 1.498a1 1 0 01.684.949V19a2 2 0 01-2 2h-1C9.716 21 3 14.284 3 6V5z" />
                          </svg>
                        </div>
                      </div>

                      <div className="pt-4 border-t">
                        <p className="text-sm font-medium text-gray-700 mb-3">Would you like astrological guidance?</p>
                        <div className="space-y-3">
                          <label className="flex items-center gap-3 p-3 border rounded-xl cursor-pointer hover:bg-orange-50 transition-colors">
                            <input
                              type="checkbox"
                              checked={formData.preferVastu}
                              onChange={e => updateField('preferVastu', e.target.checked)}
                              className="w-5 h-5 text-orange-500 rounded focus:ring-orange-500"
                            />
                            <div>
                              <p className="font-medium text-gray-900">Vastu Shastra Analysis</p>
                              <p className="text-sm text-gray-500">Get properties aligned with Vastu principles</p>
                            </div>
                          </label>
                          <label className="flex items-center gap-3 p-3 border rounded-xl cursor-pointer hover:bg-orange-50 transition-colors">
                            <input
                              type="checkbox"
                              checked={formData.preferAstrology}
                              onChange={e => updateField('preferAstrology', e.target.checked)}
                              className="w-5 h-5 text-orange-500 rounded focus:ring-orange-500"
                            />
                            <div>
                              <p className="font-medium text-gray-900">Jyotish Compatibility</p>
                              <p className="text-sm text-gray-500">Find auspicious times for property decisions</p>
                            </div>
                          </label>
                        </div>
                      </div>

                      {formData.preferAstrology && (
                        <motion.div
                          initial={{ opacity: 0, height: 0 }}
                          animate={{ opacity: 1, height: 'auto' }}
                          className="space-y-4 pt-4 border-t"
                        >
                          <p className="text-sm text-gray-600">
                            For accurate astrological guidance, please provide your birth details:
                          </p>
                          <div className="grid grid-cols-2 gap-4">
                            <div>
                              <label className="block text-sm font-medium text-gray-700 mb-1">Birth Date</label>
                              <input
                                type="date"
                                value={formData.birthDate}
                                onChange={e => updateField('birthDate', e.target.value)}
                                className="w-full px-4 py-3 border border-gray-300 rounded-xl focus:ring-2 focus:ring-orange-500 focus:border-orange-500"
                              />
                            </div>
                            <div>
                              <label className="block text-sm font-medium text-gray-700 mb-1">Birth Time</label>
                              <input
                                type="time"
                                value={formData.birthTime}
                                onChange={e => updateField('birthTime', e.target.value)}
                                className="w-full px-4 py-3 border border-gray-300 rounded-xl focus:ring-2 focus:ring-orange-500 focus:border-orange-500"
                              />
                            </div>
                          </div>
                          <div>
                            <label className="block text-sm font-medium text-gray-700 mb-1">Birth Place</label>
                            <input
                              type="text"
                              value={formData.birthPlace}
                              onChange={e => updateField('birthPlace', e.target.value)}
                              className="w-full px-4 py-3 border border-gray-300 rounded-xl focus:ring-2 focus:ring-orange-500 focus:border-orange-500"
                              placeholder="City, State, Country"
                            />
                          </div>
                        </motion.div>
                      )}
                    </div>
                  </div>
                )}

                {/* Step 3: Role Selection */}
                {step === 3 && (
                  <div className="space-y-6">
                    <div>
                      <h2 className="text-2xl font-bold text-gray-900">How will you use Dharma Realty?</h2>
                      <p className="mt-1 text-gray-600">Select your primary role</p>
                    </div>

                    <div className="space-y-3">
                      {[
                        { value: 'BUYER', icon: '🏠', title: 'I want to buy a property', desc: 'Search and purchase your dream home' },
                        { value: 'SELLER', icon: '💰', title: 'I want to sell a property', desc: 'List and sell your property' },
                        { value: 'AGENT', icon: '👔', title: "I'm a real estate agent", desc: 'Connect with buyers and sellers' },
                      ].map(role => (
                        <label
                          key={role.value}
                          className={`flex items-center gap-4 p-4 border-2 rounded-xl cursor-pointer transition-all ${
                            formData.role === role.value
                              ? 'border-orange-500 bg-orange-50'
                              : 'border-gray-200 hover:border-orange-200'
                          }`}
                        >
                          <input
                            type="radio"
                            name="role"
                            value={role.value}
                            checked={formData.role === role.value}
                            onChange={e => updateField('role', e.target.value as UserRole)}
                            className="sr-only"
                          />
                          <span className="text-3xl">{role.icon}</span>
                          <div className="flex-1">
                            <p className="font-semibold text-gray-900">{role.title}</p>
                            <p className="text-sm text-gray-500">{role.desc}</p>
                          </div>
                          {formData.role === role.value && (
                            <svg className="w-6 h-6 text-orange-500" fill="currentColor" viewBox="0 0 20 20">
                              <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clipRule="evenodd" />
                            </svg>
                          )}
                        </label>
                      ))}
                    </div>

                    {formData.role === 'AGENT' && (
                      <motion.div
                        initial={{ opacity: 0, height: 0 }}
                        animate={{ opacity: 1, height: 'auto' }}
                        className="space-y-4 pt-4 border-t"
                      >
                        <div>
                          <label className="block text-sm font-medium text-gray-700 mb-1">License Number *</label>
                          <input
                            type="text"
                            value={formData.licenseNumber || ''}
                            onChange={e => updateField('licenseNumber', e.target.value)}
                            className="w-full px-4 py-3 border border-gray-300 rounded-xl focus:ring-2 focus:ring-orange-500 focus:border-orange-500"
                            placeholder="RERA License Number"
                          />
                        </div>
                        <div>
                          <label className="block text-sm font-medium text-gray-700 mb-1">Brokerage Name *</label>
                          <input
                            type="text"
                            value={formData.brokerage || ''}
                            onChange={e => updateField('brokerage', e.target.value)}
                            className="w-full px-4 py-3 border border-gray-300 rounded-xl focus:ring-2 focus:ring-orange-500 focus:border-orange-500"
                            placeholder="Your brokerage or company"
                          />
                        </div>
                        <div>
                          <label className="block text-sm font-medium text-gray-700 mb-2">Specializations</label>
                          <div className="flex flex-wrap gap-2">
                            {specializations.map(spec => (
                              <button
                                key={spec}
                                type="button"
                                onClick={() => {
                                  const current = formData.specializations || [];
                                  if (current.includes(spec)) {
                                    updateField('specializations', current.filter(s => s !== spec));
                                  } else {
                                    updateField('specializations', [...current, spec]);
                                  }
                                }}
                                className={`px-3 py-1.5 rounded-full text-sm transition-all ${
                                  formData.specializations?.includes(spec)
                                    ? 'bg-orange-500 text-white'
                                    : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
                                }`}
                              >
                                {spec}
                              </button>
                            ))}
                          </div>
                        </div>
                        <div>
                          <label className="block text-sm font-medium text-gray-700 mb-1">Bio</label>
                          <textarea
                            value={formData.bio || ''}
                            onChange={e => updateField('bio', e.target.value)}
                            rows={3}
                            className="w-full px-4 py-3 border border-gray-300 rounded-xl focus:ring-2 focus:ring-orange-500 focus:border-orange-500"
                            placeholder="Tell potential clients about yourself..."
                          />
                        </div>
                      </motion.div>
                    )}
                  </div>
                )}

                {/* Step 4: Confirmation */}
                {step === 4 && (
                  <div className="space-y-6">
                    <div>
                      <h2 className="text-2xl font-bold text-gray-900">Almost there!</h2>
                      <p className="mt-1 text-gray-600">Review your information and confirm</p>
                    </div>

                    <div className="bg-gray-50 rounded-xl p-4 space-y-3">
                      <div className="flex justify-between">
                        <span className="text-gray-600">Email</span>
                        <span className="font-medium">{formData.email}</span>
                      </div>
                      <div className="flex justify-between">
                        <span className="text-gray-600">Name</span>
                        <span className="font-medium">{formData.firstName} {formData.lastName}</span>
                      </div>
                      <div className="flex justify-between">
                        <span className="text-gray-600">Phone</span>
                        <span className="font-medium">{formData.phone}</span>
                      </div>
                      <div className="flex justify-between">
                        <span className="text-gray-600">Role</span>
                        <span className="font-medium capitalize">{formData.role.toLowerCase()}</span>
                      </div>
                      {formData.preferVastu && (
                        <div className="flex justify-between">
                          <span className="text-gray-600">Vastu Analysis</span>
                          <span className="text-green-600">✓ Enabled</span>
                        </div>
                      )}
                      {formData.preferAstrology && (
                        <div className="flex justify-between">
                          <span className="text-gray-600">Jyotish Compatibility</span>
                          <span className="text-green-600">✓ Enabled</span>
                        </div>
                      )}
                    </div>

                    <div className="space-y-3">
                      <label className="flex items-start gap-3 cursor-pointer">
                        <input
                          type="checkbox"
                          checked={formData.agreeToTerms}
                          onChange={e => updateField('agreeToTerms', e.target.checked)}
                          className="w-5 h-5 mt-0.5 text-orange-500 rounded focus:ring-orange-500"
                        />
                        <span className="text-sm text-gray-600">
                          I agree to the{' '}
                          <Link href="/terms" className="text-orange-600 hover:underline">Terms of Service</Link>
                        </span>
                      </label>
                      <label className="flex items-start gap-3 cursor-pointer">
                        <input
                          type="checkbox"
                          checked={formData.agreeToPrivacy}
                          onChange={e => updateField('agreeToPrivacy', e.target.checked)}
                          className="w-5 h-5 mt-0.5 text-orange-500 rounded focus:ring-orange-500"
                        />
                        <span className="text-sm text-gray-600">
                          I agree to the{' '}
                          <Link href="/privacy" className="text-orange-600 hover:underline">Privacy Policy</Link>
                        </span>
                      </label>
                      <label className="flex items-start gap-3 cursor-pointer">
                        <input
                          type="checkbox"
                          checked={formData.subscribeNewsletter}
                          onChange={e => updateField('subscribeNewsletter', e.target.checked)}
                          className="w-5 h-5 mt-0.5 text-orange-500 rounded focus:ring-orange-500"
                        />
                        <span className="text-sm text-gray-600">
                          Send me property alerts and newsletters (optional)
                        </span>
                      </label>
                    </div>
                  </div>
                )}
              </motion.div>
            </AnimatePresence>

            {/* Error Message */}
            {error && (
              <motion.div
                initial={{ opacity: 0, y: -10 }}
                animate={{ opacity: 1, y: 0 }}
                className="mt-4 p-3 bg-red-50 border border-red-200 rounded-xl text-red-700 text-sm flex items-center gap-2"
              >
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
                {error}
              </motion.div>
            )}

            {/* Navigation Buttons */}
            <div className="mt-8 flex gap-4">
              {step > 1 && (
                <button
                  onClick={prevStep}
                  className="flex-1 px-6 py-3 border border-gray-300 rounded-xl font-medium text-gray-700 hover:bg-gray-50 transition-colors"
                >
                  Back
                </button>
              )}
              {step < 4 ? (
                <button
                  onClick={nextStep}
                  className="flex-1 px-6 py-3 bg-gradient-to-r from-orange-500 to-amber-500 text-white rounded-xl font-medium hover:from-orange-600 hover:to-amber-600 transition-all"
                >
                  Continue
                </button>
              ) : (
                <button
                  onClick={handleSubmit}
                  disabled={loading}
                  className="flex-1 px-6 py-3 bg-gradient-to-r from-orange-500 to-amber-500 text-white rounded-xl font-medium hover:from-orange-600 hover:to-amber-600 transition-all disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center gap-2"
                >
                  {loading ? (
                    <>
                      <svg className="animate-spin w-5 h-5" fill="none" viewBox="0 0 24 24">
                        <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
                        <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" />
                      </svg>
                      Creating Account...
                    </>
                  ) : (
                    'Create Account'
                  )}
                </button>
              )}
            </div>

            {/* Social Sign Up */}
            <div className="mt-8">
              <div className="relative">
                <div className="absolute inset-0 flex items-center">
                  <div className="w-full border-t border-gray-300" />
                </div>
                <div className="relative flex justify-center text-sm">
                  <span className="px-4 bg-gradient-to-br from-amber-50 via-orange-50 to-yellow-50 text-gray-500">
                    Or sign up with
                  </span>
                </div>
              </div>

              <div className="mt-6 grid grid-cols-2 gap-4">
                <button className="flex items-center justify-center gap-2 px-4 py-3 border border-gray-300 rounded-xl hover:bg-gray-50 transition-colors">
                  <svg className="w-5 h-5" viewBox="0 0 24 24">
                    <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z" />
                    <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z" />
                    <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z" />
                    <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z" />
                  </svg>
                  Google
                </button>
                <button className="flex items-center justify-center gap-2 px-4 py-3 border border-gray-300 rounded-xl hover:bg-gray-50 transition-colors">
                  <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
                    <path d="M12.152 6.896c-.948 0-2.415-1.078-3.96-1.04-2.04.027-3.91 1.183-4.961 3.014-2.117 3.675-.546 9.103 1.519 12.09 1.013 1.454 2.208 3.09 3.792 3.039 1.52-.065 2.09-.987 3.935-.987 1.831 0 2.35.987 3.96.948 1.637-.026 2.676-1.48 3.676-2.948 1.156-1.688 1.636-3.325 1.662-3.415-.039-.013-3.182-1.221-3.22-4.857-.026-3.04 2.48-4.494 2.597-4.559-1.429-2.09-3.623-2.324-4.39-2.376-2-.156-3.675 1.09-4.61 1.09zM15.53 3.83c.843-1.012 1.4-2.427 1.245-3.83-1.207.052-2.662.805-3.532 1.818-.78.896-1.454 2.338-1.273 3.714 1.338.104 2.715-.688 3.559-1.701" />
                  </svg>
                  Apple
                </button>
              </div>
            </div>

            {/* Sign In Link */}
            <p className="mt-8 text-center text-sm text-gray-600">
              Already have an account?{' '}
              <Link href="/login" className="font-semibold text-orange-600 hover:text-orange-500">
                Sign in
              </Link>
            </p>
          </div>
        </div>
      </div>
    </div>
  );
}
Layout · TSX
'use client';

import { useState, useEffect } from 'react';
import Link from 'next/link';
import { usePathname } from 'next/navigation';
import { motion, AnimatePresence } from 'framer-motion';

interface User {
  id: string;
  email: string;
  firstName: string;
  lastName: string;
  role: 'BUYER' | 'SELLER' | 'AGENT' | 'ADMIN';
  avatar?: string;
}

const buyerNavigation = [
  { name: 'Overview', href: '/dashboard', icon: 'home' },
  { name: 'Saved Properties', href: '/dashboard/favorites', icon: 'heart' },
  { name: 'Saved Searches', href: '/dashboard/searches', icon: 'search' },
  { name: 'My Offers', href: '/dashboard/offers', icon: 'document' },
  { name: 'Messages', href: '/dashboard/messages', icon: 'chat' },
  { name: 'Showings', href: '/dashboard/showings', icon: 'calendar' },
  { name: 'Documents', href: '/dashboard/documents', icon: 'folder' },
  { name: 'Astrology', href: '/dashboard/astrology', icon: 'star' },
];

const sellerNavigation = [
  { name: 'Overview', href: '/dashboard', icon: 'home' },
  { name: 'My Listings', href: '/dashboard/listings', icon: 'building' },
  { name: 'Offers Received', href: '/dashboard/offers', icon: 'document' },
  { name: 'Showings', href: '/dashboard/showings', icon: 'calendar' },
  { name: 'Messages', href: '/dashboard/messages', icon: 'chat' },
  { name: 'Analytics', href: '/dashboard/analytics', icon: 'chart' },
  { name: 'Documents', href: '/dashboard/documents', icon: 'folder' },
];

const agentNavigation = [
  { name: 'Overview', href: '/dashboard', icon: 'home' },
  { name: 'My Listings', href: '/dashboard/listings', icon: 'building' },
  { name: 'Leads', href: '/dashboard/leads', icon: 'users' },
  { name: 'Clients', href: '/dashboard/clients', icon: 'user-group' },
  { name: 'Showings', href: '/dashboard/showings', icon: 'calendar' },
  { name: 'Open Houses', href: '/dashboard/openhouses', icon: 'door' },
  { name: 'Messages', href: '/dashboard/messages', icon: 'chat' },
  { name: 'Transactions', href: '/dashboard/transactions', icon: 'currency' },
  { name: 'Analytics', href: '/dashboard/analytics', icon: 'chart' },
  { name: 'Documents', href: '/dashboard/documents', icon: 'folder' },
];

const icons: Record<string, React.ReactNode> = {
  home: (
    <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6" />
    </svg>
  ),
  heart: (
    <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z" />
    </svg>
  ),
  search: (
    <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
    </svg>
  ),
  document: (
    <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
    </svg>
  ),
  chat: (
    <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z" />
    </svg>
  ),
  calendar: (
    <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
    </svg>
  ),
  folder: (
    <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z" />
    </svg>
  ),
  star: (
    <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M11.049 2.927c.3-.921 1.603-.921 1.902 0l1.519 4.674a1 1 0 00.95.69h4.915c.969 0 1.371 1.24.588 1.81l-3.976 2.888a1 1 0 00-.363 1.118l1.518 4.674c.3.922-.755 1.688-1.538 1.118l-3.976-2.888a1 1 0 00-1.176 0l-3.976 2.888c-.783.57-1.838-.197-1.538-1.118l1.518-4.674a1 1 0 00-.363-1.118l-3.976-2.888c-.784-.57-.38-1.81.588-1.81h4.914a1 1 0 00.951-.69l1.519-4.674z" />
    </svg>
  ),
  building: (
    <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 21V5a2 2 0 00-2-2H7a2 2 0 00-2 2v16m14 0h2m-2 0h-5m-9 0H3m2 0h5M9 7h1m-1 4h1m4-4h1m-1 4h1m-5 10v-5a1 1 0 011-1h2a1 1 0 011 1v5m-4 0h4" />
    </svg>
  ),
  users: (
    <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4.354a4 4 0 110 5.292M15 21H3v-1a6 6 0 0112 0v1zm0 0h6v-1a6 6 0 00-9-5.197M13 7a4 4 0 11-8 0 4 4 0 018 0z" />
    </svg>
  ),
  'user-group': (
    <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z" />
    </svg>
  ),
  door: (
    <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 11V7a4 4 0 118 0m-4 8v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2z" />
    </svg>
  ),
  currency: (
    <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
    </svg>
  ),
  chart: (
    <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" />
    </svg>
  ),
};

export default function DashboardLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const pathname = usePathname();
  const [sidebarOpen, setSidebarOpen] = useState(false);
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const [notifications, setNotifications] = useState(3);

  useEffect(() => {
    // Fetch user data
    const fetchUser = async () => {
      try {
        const token = localStorage.getItem('token');
        if (!token) {
          window.location.href = '/login';
          return;
        }

        const response = await fetch('/api/auth/me', {
          headers: { Authorization: `Bearer ${token}` },
        });

        if (!response.ok) {
          throw new Error('Not authenticated');
        }

        const data = await response.json();
        setUser(data.user);
      } catch (err) {
        window.location.href = '/login';
      } finally {
        setLoading(false);
      }
    };

    fetchUser();
  }, []);

  const navigation = user?.role === 'AGENT' 
    ? agentNavigation 
    : user?.role === 'SELLER' 
    ? sellerNavigation 
    : buyerNavigation;

  if (loading) {
    return (
      <div className="min-h-screen bg-gray-50 flex items-center justify-center">
        <div className="text-center">
          <div className="w-16 h-16 border-4 border-orange-500 border-t-transparent rounded-full animate-spin mx-auto" />
          <p className="mt-4 text-gray-600">Loading dashboard...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-50">
      {/* Mobile sidebar backdrop */}
      <AnimatePresence>
        {sidebarOpen && (
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            className="fixed inset-0 z-40 bg-gray-900/50 lg:hidden"
            onClick={() => setSidebarOpen(false)}
          />
        )}
      </AnimatePresence>

      {/* Sidebar */}
      <aside
        className={`fixed inset-y-0 left-0 z-50 w-72 bg-white border-r border-gray-200 transform transition-transform lg:translate-x-0 ${
          sidebarOpen ? 'translate-x-0' : '-translate-x-full'
        }`}
      >
        <div className="flex flex-col h-full">
          {/* Logo */}
          <div className="flex items-center justify-between h-16 px-6 border-b">
            <Link href="/" className="flex items-center gap-3">
              <div className="w-10 h-10 bg-gradient-to-br from-orange-500 to-amber-500 rounded-xl flex items-center justify-center">
                <span className="text-xl text-white">🏛️</span>
              </div>
              <span className="text-lg font-bold text-gray-900">Dharma Realty</span>
            </Link>
            <button
              onClick={() => setSidebarOpen(false)}
              className="lg:hidden p-2 text-gray-500 hover:text-gray-700"
            >
              <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
              </svg>
            </button>
          </div>

          {/* Navigation */}
          <nav className="flex-1 px-4 py-6 space-y-1 overflow-y-auto">
            {navigation.map((item) => {
              const isActive = pathname === item.href;
              return (
                <Link
                  key={item.name}
                  href={item.href}
                  className={`flex items-center gap-3 px-4 py-3 rounded-xl transition-all ${
                    isActive
                      ? 'bg-gradient-to-r from-orange-500 to-amber-500 text-white shadow-lg shadow-orange-500/25'
                      : 'text-gray-700 hover:bg-gray-100'
                  }`}
                >
                  {icons[item.icon]}
                  <span className="font-medium">{item.name}</span>
                </Link>
              );
            })}
          </nav>

          {/* Subscription Card */}
          <div className="p-4">
            <div className="p-4 bg-gradient-to-br from-orange-50 to-amber-50 rounded-xl border border-orange-100">
              <div className="flex items-center gap-3 mb-3">
                <div className="w-10 h-10 bg-orange-100 rounded-lg flex items-center justify-center">
                  <svg className="w-5 h-5 text-orange-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 3v4M3 5h4M6 17v4m-2-2h4m5-16l2.286 6.857L21 12l-5.714 2.143L13 21l-2.286-6.857L5 12l5.714-2.143L13 3z" />
                  </svg>
                </div>
                <div>
                  <p className="font-semibold text-gray-900">Free Plan</p>
                  <p className="text-xs text-gray-600">5 of 10 searches used</p>
                </div>
              </div>
              <Link
                href="/dashboard/subscription"
                className="block w-full py-2 text-center text-sm font-medium text-orange-600 hover:text-orange-700 border border-orange-200 rounded-lg hover:bg-orange-50 transition-colors"
              >
                Upgrade Plan
              </Link>
            </div>
          </div>

          {/* User Profile */}
          <div className="p-4 border-t">
            <Link
              href="/dashboard/settings"
              className="flex items-center gap-3 p-3 rounded-xl hover:bg-gray-100 transition-colors"
            >
              <div className="w-10 h-10 rounded-full bg-gradient-to-br from-orange-400 to-amber-400 flex items-center justify-center text-white font-semibold">
                {user?.firstName?.[0]}{user?.lastName?.[0]}
              </div>
              <div className="flex-1 min-w-0">
                <p className="font-medium text-gray-900 truncate">
                  {user?.firstName} {user?.lastName}
                </p>
                <p className="text-sm text-gray-500 truncate">{user?.email}</p>
              </div>
              <svg className="w-5 h-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
              </svg>
            </Link>
          </div>
        </div>
      </aside>

      {/* Main Content */}
      <div className="lg:pl-72">
        {/* Top Header */}
        <header className="sticky top-0 z-30 bg-white border-b border-gray-200">
          <div className="flex items-center justify-between h-16 px-4 lg:px-8">
            <div className="flex items-center gap-4">
              <button
                onClick={() => setSidebarOpen(true)}
                className="lg:hidden p-2 text-gray-500 hover:text-gray-700"
              >
                <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6h16M4 12h16M4 18h16" />
                </svg>
              </button>

              {/* Breadcrumb */}
              <nav className="hidden sm:flex items-center gap-2 text-sm">
                <Link href="/dashboard" className="text-gray-500 hover:text-gray-700">
                  Dashboard
                </Link>
                {pathname !== '/dashboard' && (
                  <>
                    <svg className="w-4 h-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
                    </svg>
                    <span className="text-gray-900 font-medium capitalize">
                      {pathname.split('/').pop()?.replace('-', ' ')}
                    </span>
                  </>
                )}
              </nav>
            </div>

            <div className="flex items-center gap-4">
              {/* Search */}
              <div className="hidden md:block relative">
                <input
                  type="text"
                  placeholder="Search..."
                  className="w-64 pl-10 pr-4 py-2 border border-gray-300 rounded-xl focus:ring-2 focus:ring-orange-500 focus:border-orange-500"
                />
                <svg className="absolute left-3 top-1/2 -translate-y-1/2 w-5 h-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                </svg>
              </div>

              {/* Notifications */}
              <button className="relative p-2 text-gray-500 hover:text-gray-700 hover:bg-gray-100 rounded-lg">
                <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9" />
                </svg>
                {notifications > 0 && (
                  <span className="absolute top-1 right-1 w-5 h-5 bg-red-500 text-white text-xs rounded-full flex items-center justify-center">
                    {notifications}
                  </span>
                )}
              </button>

              {/* Quick Actions */}
              <button className="hidden sm:flex items-center gap-2 px-4 py-2 bg-gradient-to-r from-orange-500 to-amber-500 text-white rounded-xl font-medium hover:from-orange-600 hover:to-amber-600 transition-all">
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
                </svg>
                {user?.role === 'AGENT' || user?.role === 'SELLER' ? 'New Listing' : 'Search Properties'}
              </button>
            </div>
          </div>
        </header>

        {/* Page Content */}
        <main className="p-4 lg:p-8">
          {children}
        </main>
      </div>
    </div>
  );
}
Page · TSX
'use client';

import { useState, useEffect } from 'react';
import Link from 'next/link';
import { motion } from 'framer-motion';

interface DashboardStats {
  savedProperties: number;
  activeSearches: number;
  scheduledShowings: number;
  unreadMessages: number;
  recentViews: number;
  pendingOffers: number;
}

interface Activity {
  id: string;
  type: 'view' | 'save' | 'message' | 'showing' | 'offer' | 'price_change';
  title: string;
  description: string;
  timestamp: string;
  propertyId?: string;
  propertyImage?: string;
}

interface RecommendedProperty {
  id: string;
  title: string;
  address: string;
  price: number;
  beds: number;
  baths: number;
  sqft: number;
  image: string;
  vastuScore?: number;
  matchScore: number;
}

export default function DashboardPage() {
  const [stats, setStats] = useState<DashboardStats>({
    savedProperties: 12,
    activeSearches: 3,
    scheduledShowings: 2,
    unreadMessages: 5,
    recentViews: 24,
    pendingOffers: 1,
  });

  const [activities, setActivities] = useState<Activity[]>([
    {
      id: '1',
      type: 'price_change',
      title: 'Price Reduced',
      description: 'Sunset Villa dropped by ₹15L',
      timestamp: '2 hours ago',
      propertyId: 'p1',
      propertyImage: 'https://images.unsplash.com/photo-1600596542815-ffad4c1539a9?w=100&h=100&fit=crop',
    },
    {
      id: '2',
      type: 'showing',
      title: 'Showing Confirmed',
      description: 'Tomorrow at 10:00 AM - Green Valley Apartment',
      timestamp: '5 hours ago',
      propertyId: 'p2',
    },
    {
      id: '3',
      type: 'message',
      title: 'New Message',
      description: 'Agent Priya replied to your inquiry',
      timestamp: 'Yesterday',
    },
    {
      id: '4',
      type: 'save',
      title: 'Property Saved',
      description: 'Added Modern Penthouse to favorites',
      timestamp: 'Yesterday',
      propertyId: 'p3',
    },
    {
      id: '5',
      type: 'view',
      title: 'Property Viewed',
      description: 'Someone viewed your listing',
      timestamp: '2 days ago',
    },
  ]);

  const [recommended, setRecommended] = useState<RecommendedProperty[]>([
    {
      id: 'r1',
      title: 'Vastu-Compliant Villa',
      address: 'Whitefield, Bangalore',
      price: 15000000,
      beds: 4,
      baths: 3,
      sqft: 3200,
      image: 'https://images.unsplash.com/photo-1600585154340-be6161a56a0c?w=400&h=300&fit=crop',
      vastuScore: 92,
      matchScore: 95,
    },
    {
      id: 'r2',
      title: 'Modern Apartment',
      address: 'Koramangala, Bangalore',
      price: 8500000,
      beds: 3,
      baths: 2,
      sqft: 1800,
      image: 'https://images.unsplash.com/photo-1560448204-e02f11c3d0e2?w=400&h=300&fit=crop',
      vastuScore: 85,
      matchScore: 88,
    },
    {
      id: 'r3',
      title: 'Heritage Bungalow',
      address: 'Indiranagar, Bangalore',
      price: 22000000,
      beds: 5,
      baths: 4,
      sqft: 4500,
      image: 'https://images.unsplash.com/photo-1613490493576-7fde63acd811?w=400&h=300&fit=crop',
      vastuScore: 98,
      matchScore: 82,
    },
  ]);

  const [panchangData, setPanchangData] = useState({
    tithi: 'Shukla Dashami',
    nakshatra: 'Pushya',
    yoga: 'Siddhi',
    muhurat: 'Auspicious for property dealings',
    isAuspicious: true,
  });

  const formatPrice = (price: number) => {
    if (price >= 10000000) {
      return `₹${(price / 10000000).toFixed(2)} Cr`;
    } else if (price >= 100000) {
      return `₹${(price / 100000).toFixed(2)} L`;
    }
    return `₹${price.toLocaleString()}`;
  };

  const activityIcons: Record<string, React.ReactNode> = {
    view: (
      <div className="w-10 h-10 bg-blue-100 rounded-full flex items-center justify-center">
        <svg className="w-5 h-5 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
        </svg>
      </div>
    ),
    save: (
      <div className="w-10 h-10 bg-pink-100 rounded-full flex items-center justify-center">
        <svg className="w-5 h-5 text-pink-600" fill="currentColor" viewBox="0 0 24 24">
          <path d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z" />
        </svg>
      </div>
    ),
    message: (
      <div className="w-10 h-10 bg-green-100 rounded-full flex items-center justify-center">
        <svg className="w-5 h-5 text-green-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z" />
        </svg>
      </div>
    ),
    showing: (
      <div className="w-10 h-10 bg-purple-100 rounded-full flex items-center justify-center">
        <svg className="w-5 h-5 text-purple-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
        </svg>
      </div>
    ),
    offer: (
      <div className="w-10 h-10 bg-amber-100 rounded-full flex items-center justify-center">
        <svg className="w-5 h-5 text-amber-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
        </svg>
      </div>
    ),
    price_change: (
      <div className="w-10 h-10 bg-orange-100 rounded-full flex items-center justify-center">
        <svg className="w-5 h-5 text-orange-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 17h8m0 0V9m0 8l-8-8-4 4-6-6" />
        </svg>
      </div>
    ),
  };

  return (
    <div className="space-y-8">
      {/* Welcome Section */}
      <div className="flex flex-col md:flex-row md:items-center md:justify-between gap-4">
        <div>
          <h1 className="text-2xl font-bold text-gray-900">Welcome back! 🙏</h1>
          <p className="text-gray-600">Here's what's happening with your property search</p>
        </div>
        <div className="flex gap-3">
          <Link
            href="/search"
            className="px-4 py-2 bg-white border border-gray-300 rounded-xl font-medium text-gray-700 hover:bg-gray-50 transition-colors"
          >
            Search Properties
          </Link>
          <Link
            href="/dashboard/astrology"
            className="px-4 py-2 bg-gradient-to-r from-orange-500 to-amber-500 text-white rounded-xl font-medium hover:from-orange-600 hover:to-amber-600 transition-all"
          >
            Check Muhurat
          </Link>
        </div>
      </div>

      {/* Panchang Widget */}
      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        className={`p-6 rounded-2xl border ${
          panchangData.isAuspicious
            ? 'bg-gradient-to-r from-green-50 to-emerald-50 border-green-200'
            : 'bg-gradient-to-r from-orange-50 to-amber-50 border-orange-200'
        }`}
      >
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-4">
            <div className={`w-12 h-12 rounded-xl flex items-center justify-center ${
              panchangData.isAuspicious ? 'bg-green-100' : 'bg-orange-100'
            }`}>
              <span className="text-2xl">🕉️</span>
            </div>
            <div>
              <p className="text-sm text-gray-600">Today's Panchang</p>
              <p className="font-semibold text-gray-900">{panchangData.tithi} • {panchangData.nakshatra}</p>
            </div>
          </div>
          <div className="text-right">
            <p className={`text-sm font-medium ${panchangData.isAuspicious ? 'text-green-600' : 'text-orange-600'}`}>
              {panchangData.muhurat}
            </p>
            <p className="text-xs text-gray-500">Yoga: {panchangData.yoga}</p>
          </div>
        </div>
      </motion.div>

      {/* Stats Grid */}
      <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-6 gap-4">
        {[
          { label: 'Saved Properties', value: stats.savedProperties, icon: '❤️', color: 'pink', href: '/dashboard/favorites' },
          { label: 'Active Searches', value: stats.activeSearches, icon: '🔍', color: 'blue', href: '/dashboard/searches' },
          { label: 'Scheduled Showings', value: stats.scheduledShowings, icon: '📅', color: 'purple', href: '/dashboard/showings' },
          { label: 'Unread Messages', value: stats.unreadMessages, icon: '💬', color: 'green', href: '/dashboard/messages' },
          { label: 'Recent Views', value: stats.recentViews, icon: '👁️', color: 'gray', href: '/dashboard/activity' },
          { label: 'Pending Offers', value: stats.pendingOffers, icon: '📝', color: 'amber', href: '/dashboard/offers' },
        ].map((stat, i) => (
          <motion.div
            key={stat.label}
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: i * 0.05 }}
          >
            <Link
              href={stat.href}
              className="block p-4 bg-white rounded-xl border border-gray-200 hover:border-orange-300 hover:shadow-lg transition-all"
            >
              <div className="flex items-center justify-between mb-2">
                <span className="text-2xl">{stat.icon}</span>
                <span className="text-2xl font-bold text-gray-900">{stat.value}</span>
              </div>
              <p className="text-sm text-gray-600">{stat.label}</p>
            </Link>
          </motion.div>
        ))}
      </div>

      <div className="grid lg:grid-cols-3 gap-8">
        {/* Recent Activity */}
        <div className="lg:col-span-2">
          <div className="bg-white rounded-2xl border border-gray-200 overflow-hidden">
            <div className="p-6 border-b border-gray-200">
              <div className="flex items-center justify-between">
                <h2 className="text-lg font-semibold text-gray-900">Recent Activity</h2>
                <Link href="/dashboard/activity" className="text-sm text-orange-600 hover:text-orange-700">
                  View all
                </Link>
              </div>
            </div>
            <div className="divide-y divide-gray-100">
              {activities.map((activity, i) => (
                <motion.div
                  key={activity.id}
                  initial={{ opacity: 0, x: -20 }}
                  animate={{ opacity: 1, x: 0 }}
                  transition={{ delay: i * 0.05 }}
                  className="p-4 hover:bg-gray-50 transition-colors"
                >
                  <div className="flex items-center gap-4">
                    {activityIcons[activity.type]}
                    <div className="flex-1 min-w-0">
                      <p className="font-medium text-gray-900">{activity.title}</p>
                      <p className="text-sm text-gray-600 truncate">{activity.description}</p>
                    </div>
                    <div className="text-right">
                      <p className="text-xs text-gray-500">{activity.timestamp}</p>
                      {activity.propertyId && (
                        <Link
                          href={`/property/${activity.propertyId}`}
                          className="text-xs text-orange-600 hover:text-orange-700"
                        >
                          View →
                        </Link>
                      )}
                    </div>
                  </div>
                </motion.div>
              ))}
            </div>
          </div>
        </div>

        {/* Quick Actions */}
        <div className="space-y-6">
          {/* Upcoming Showings */}
          <div className="bg-white rounded-2xl border border-gray-200 p-6">
            <h3 className="font-semibold text-gray-900 mb-4">Upcoming Showings</h3>
            <div className="space-y-3">
              <div className="p-3 bg-purple-50 rounded-xl">
                <div className="flex items-center gap-3">
                  <div className="w-12 h-12 bg-purple-100 rounded-lg flex items-center justify-center">
                    <span className="text-lg">🏠</span>
                  </div>
                  <div className="flex-1">
                    <p className="font-medium text-gray-900 text-sm">Green Valley Apartment</p>
                    <p className="text-xs text-gray-600">Tomorrow, 10:00 AM</p>
                  </div>
                </div>
              </div>
              <div className="p-3 bg-gray-50 rounded-xl">
                <div className="flex items-center gap-3">
                  <div className="w-12 h-12 bg-gray-100 rounded-lg flex items-center justify-center">
                    <span className="text-lg">🏡</span>
                  </div>
                  <div className="flex-1">
                    <p className="font-medium text-gray-900 text-sm">Sunset Villa</p>
                    <p className="text-xs text-gray-600">Dec 22, 2:00 PM</p>
                  </div>
                </div>
              </div>
            </div>
            <Link
              href="/dashboard/showings"
              className="block mt-4 text-center text-sm text-orange-600 hover:text-orange-700"
            >
              View all showings →
            </Link>
          </div>

          {/* Saved Search Alerts */}
          <div className="bg-white rounded-2xl border border-gray-200 p-6">
            <h3 className="font-semibold text-gray-900 mb-4">Saved Search Alerts</h3>
            <div className="space-y-3">
              <div className="flex items-center justify-between p-3 bg-blue-50 rounded-xl">
                <div>
                  <p className="font-medium text-gray-900 text-sm">3BHK in Koramangala</p>
                  <p className="text-xs text-gray-600">5 new matches</p>
                </div>
                <span className="px-2 py-1 bg-blue-100 text-blue-700 text-xs rounded-full">Active</span>
              </div>
              <div className="flex items-center justify-between p-3 bg-gray-50 rounded-xl">
                <div>
                  <p className="font-medium text-gray-900 text-sm">Villa under ₹2Cr</p>
                  <p className="text-xs text-gray-600">2 new matches</p>
                </div>
                <span className="px-2 py-1 bg-gray-100 text-gray-600 text-xs rounded-full">Active</span>
              </div>
            </div>
            <Link
              href="/dashboard/searches"
              className="block mt-4 text-center text-sm text-orange-600 hover:text-orange-700"
            >
              Manage searches →
            </Link>
          </div>
        </div>
      </div>

      {/* Recommended Properties */}
      <div>
        <div className="flex items-center justify-between mb-6">
          <div>
            <h2 className="text-lg font-semibold text-gray-900">Recommended for You</h2>
            <p className="text-sm text-gray-600">Based on your searches and preferences</p>
          </div>
          <Link href="/search" className="text-sm text-orange-600 hover:text-orange-700">
            View all →
          </Link>
        </div>

        <div className="grid md:grid-cols-2 lg:grid-cols-3 gap-6">
          {recommended.map((property, i) => (
            <motion.div
              key={property.id}
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ delay: i * 0.1 }}
            >
              <Link
                href={`/property/${property.id}`}
                className="block bg-white rounded-2xl border border-gray-200 overflow-hidden hover:shadow-xl transition-all group"
              >
                <div className="relative">
                  <img
                    src={property.image}
                    alt={property.title}
                    className="w-full h-48 object-cover group-hover:scale-105 transition-transform duration-300"
                  />
                  <div className="absolute top-3 left-3 flex gap-2">
                    {property.vastuScore && property.vastuScore >= 90 && (
                      <span className="px-2 py-1 bg-green-500 text-white text-xs rounded-full flex items-center gap-1">
                        🕉️ {property.vastuScore}% Vastu
                      </span>
                    )}
                    <span className="px-2 py-1 bg-orange-500 text-white text-xs rounded-full">
                      {property.matchScore}% Match
                    </span>
                  </div>
                  <button className="absolute top-3 right-3 w-8 h-8 bg-white/90 backdrop-blur-sm rounded-full flex items-center justify-center hover:bg-white transition-colors">
                    <svg className="w-5 h-5 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z" />
                    </svg>
                  </button>
                </div>
                <div className="p-4">
                  <p className="text-xl font-bold text-gray-900">{formatPrice(property.price)}</p>
                  <h3 className="font-semibold text-gray-900 mt-1">{property.title}</h3>
                  <p className="text-sm text-gray-600">{property.address}</p>
                  <div className="flex items-center gap-4 mt-3 text-sm text-gray-600">
                    <span>{property.beds} beds</span>
                    <span>•</span>
                    <span>{property.baths} baths</span>
                    <span>•</span>
                    <span>{property.sqft.toLocaleString()} sqft</span>
                  </div>
                </div>
              </Link>
            </motion.div>
          ))}
        </div>
      </div>

      {/* Bottom CTA */}
      <div className="bg-gradient-to-r from-orange-500 via-amber-500 to-yellow-500 rounded-2xl p-8 text-center">
        <h2 className="text-2xl font-bold text-white mb-2">
          Find Your Perfect Home with Vastu Guidance
        </h2>
        <p className="text-white/90 mb-6 max-w-2xl mx-auto">
          Let our AI-powered search find properties aligned with ancient Vedic principles 
          for prosperity, health, and harmony.
        </p>
        <div className="flex flex-col sm:flex-row gap-4 justify-center">
          <Link
            href="/search?vastu=true"
            className="px-6 py-3 bg-white text-orange-600 rounded-xl font-semibold hover:bg-orange-50 transition-colors"
          >
            Search Vastu Properties
          </Link>
          <Link
            href="/dashboard/astrology"
            className="px-6 py-3 bg-white/20 text-white border border-white/30 rounded-xl font-semibold hover:bg-white/30 transition-colors"
          >
            Get Astrological Guidance
          </Link>
        </div>
      </div>
    </div>
  );
}
Page · TSX
'use client';

import { useState, useEffect } from 'react';
import { useParams } from 'next/navigation';
import Link from 'next/link';
import { motion } from 'framer-motion';

interface Agent {
  id: string;
  firstName: string;
  lastName: string;
  email: string;
  phone: string;
  avatar?: string;
  bio?: string;
  licenseNumber: string;
  brokerage: string;
  specializations: string[];
  serviceAreas: string[];
  languages: string[];
  yearsExperience: number;
  totalTransactions: number;
  avgRating: number;
  reviewCount: number;
  responseTime: string;
  listingsCount: number;
  soldCount: number;
  vastuCertified: boolean;
  verified: boolean;
  createdAt: string;
}

interface Review {
  id: string;
  userId: string;
  userName: string;
  userAvatar?: string;
  rating: number;
  title: string;
  content: string;
  helpful: number;
  createdAt: string;
}

interface Listing {
  id: string;
  title: string;
  address: string;
  price: number;
  beds: number;
  baths: number;
  sqft: number;
  image: string;
  status: 'ACTIVE' | 'PENDING' | 'SOLD';
  vastuScore?: number;
}

export default function AgentProfilePage() {
  const params = useParams();
  const agentId = params.id as string;

  const [agent, setAgent] = useState<Agent | null>(null);
  const [reviews, setReviews] = useState<Review[]>([]);
  const [listings, setListings] = useState<Listing[]>([]);
  const [activeTab, setActiveTab] = useState<'listings' | 'reviews' | 'about'>('listings');
  const [loading, setLoading] = useState(true);
  const [showContactModal, setShowContactModal] = useState(false);

  useEffect(() => {
    // Mock data - replace with API call
    setAgent({
      id: agentId,
      firstName: 'Priya',
      lastName: 'Sharma',
      email: 'priya.sharma@dharmarealty.com',
      phone: '+91 98765 43210',
      avatar: 'https://images.unsplash.com/photo-1573496359142-b8d87734a5a2?w=400&h=400&fit=crop',
      bio: 'With over 15 years of experience in Bangalore\'s real estate market, I specialize in helping families find homes that align with both their practical needs and Vastu principles. As a certified Vastu consultant, I understand the importance of harmonious living spaces and work closely with clients to find properties that promote prosperity and well-being.',
      licenseNumber: 'RERA-KAR-2019-12345',
      brokerage: 'Dharma Realty Premium',
      specializations: ['Luxury Homes', 'Vastu Properties', 'Investment Properties', 'First-Time Buyers'],
      serviceAreas: ['Koramangala', 'Indiranagar', 'Whitefield', 'HSR Layout', 'Jayanagar'],
      languages: ['English', 'Hindi', 'Kannada', 'Telugu'],
      yearsExperience: 15,
      totalTransactions: 350,
      avgRating: 4.9,
      reviewCount: 127,
      responseTime: '< 1 hour',
      listingsCount: 24,
      soldCount: 326,
      vastuCertified: true,
      verified: true,
      createdAt: '2019-03-15',
    });

    setReviews([
      {
        id: 'r1',
        userId: 'u1',
        userName: 'Rajesh Kumar',
        userAvatar: 'https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?w=100&h=100&fit=crop',
        rating: 5,
        title: 'Exceptional service and Vastu expertise',
        content: 'Priya helped us find our dream home with perfect Vastu alignment. Her knowledge of both real estate and Vedic principles is remarkable. She was patient, professional, and always available to answer our questions.',
        helpful: 24,
        createdAt: '2024-11-20',
      },
      {
        id: 'r2',
        userId: 'u2',
        userName: 'Anita Reddy',
        rating: 5,
        title: 'Highly recommended!',
        content: 'Working with Priya was a wonderful experience. She understood our requirements perfectly and showed us properties that matched our budget and Vastu preferences. The entire process was smooth and stress-free.',
        helpful: 18,
        createdAt: '2024-10-15',
      },
      {
        id: 'r3',
        userId: 'u3',
        userName: 'Vikram Singh',
        userAvatar: 'https://images.unsplash.com/photo-1500648767791-00dcc994a43e?w=100&h=100&fit=crop',
        rating: 4,
        title: 'Great experience overall',
        content: 'Priya is very knowledgeable and professional. She helped us navigate the complex Bangalore market with ease. Only minor issue was scheduling conflicts due to her busy calendar, but she always made time for us.',
        helpful: 12,
        createdAt: '2024-09-08',
      },
    ]);

    setListings([
      {
        id: 'l1',
        title: 'Luxury Villa with Garden',
        address: 'Whitefield, Bangalore',
        price: 25000000,
        beds: 5,
        baths: 4,
        sqft: 4500,
        image: 'https://images.unsplash.com/photo-1600596542815-ffad4c1539a9?w=400&h=300&fit=crop',
        status: 'ACTIVE',
        vastuScore: 95,
      },
      {
        id: 'l2',
        title: 'Modern 3BHK Apartment',
        address: 'Koramangala, Bangalore',
        price: 12000000,
        beds: 3,
        baths: 2,
        sqft: 1800,
        image: 'https://images.unsplash.com/photo-1560448204-e02f11c3d0e2?w=400&h=300&fit=crop',
        status: 'ACTIVE',
        vastuScore: 88,
      },
      {
        id: 'l3',
        title: 'Premium Penthouse',
        address: 'Indiranagar, Bangalore',
        price: 35000000,
        beds: 4,
        baths: 3,
        sqft: 3200,
        image: 'https://images.unsplash.com/photo-1600607687939-ce8a6c25118c?w=400&h=300&fit=crop',
        status: 'PENDING',
        vastuScore: 92,
      },
    ]);

    setLoading(false);
  }, [agentId]);

  const formatPrice = (price: number) => {
    if (price >= 10000000) {
      return `₹${(price / 10000000).toFixed(2)} Cr`;
    } else if (price >= 100000) {
      return `₹${(price / 100000).toFixed(2)} L`;
    }
    return `₹${price.toLocaleString()}`;
  };

  if (loading) {
    return (
      <div className="min-h-screen bg-gray-50 flex items-center justify-center">
        <div className="w-12 h-12 border-4 border-orange-500 border-t-transparent rounded-full animate-spin" />
      </div>
    );
  }

  if (!agent) {
    return (
      <div className="min-h-screen bg-gray-50 flex items-center justify-center">
        <div className="text-center">
          <h1 className="text-2xl font-bold text-gray-900">Agent not found</h1>
          <Link href="/agents" className="text-orange-600 hover:text-orange-700 mt-2 inline-block">
            Browse all agents →
          </Link>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-50">
      {/* Hero Section */}
      <div className="bg-gradient-to-br from-orange-500 via-amber-500 to-yellow-500">
        <div className="max-w-7xl mx-auto px-4 py-12">
          <div className="flex flex-col lg:flex-row gap-8 items-start">
            {/* Agent Photo & Quick Actions */}
            <div className="flex-shrink-0">
              <div className="relative">
                <img
                  src={agent.avatar || `https://ui-avatars.com/api/?name=${agent.firstName}+${agent.lastName}&size=200`}
                  alt={`${agent.firstName} ${agent.lastName}`}
                  className="w-48 h-48 rounded-2xl object-cover border-4 border-white shadow-xl"
                />
                {agent.verified && (
                  <div className="absolute -bottom-2 -right-2 w-10 h-10 bg-blue-500 rounded-full flex items-center justify-center border-4 border-white">
                    <svg className="w-5 h-5 text-white" fill="currentColor" viewBox="0 0 20 20">
                      <path fillRule="evenodd" d="M6.267 3.455a3.066 3.066 0 001.745-.723 3.066 3.066 0 013.976 0 3.066 3.066 0 001.745.723 3.066 3.066 0 012.812 2.812c.051.643.304 1.254.723 1.745a3.066 3.066 0 010 3.976 3.066 3.066 0 00-.723 1.745 3.066 3.066 0 01-2.812 2.812 3.066 3.066 0 00-1.745.723 3.066 3.066 0 01-3.976 0 3.066 3.066 0 00-1.745-.723 3.066 3.066 0 01-2.812-2.812 3.066 3.066 0 00-.723-1.745 3.066 3.066 0 010-3.976 3.066 3.066 0 00.723-1.745 3.066 3.066 0 012.812-2.812zm7.44 5.252a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clipRule="evenodd" />
                    </svg>
                  </div>
                )}
              </div>
            </div>

            {/* Agent Info */}
            <div className="flex-1 text-white">
              <div className="flex flex-wrap items-center gap-3 mb-2">
                <h1 className="text-3xl font-bold">{agent.firstName} {agent.lastName}</h1>
                {agent.vastuCertified && (
                  <span className="px-3 py-1 bg-white/20 backdrop-blur-sm rounded-full text-sm flex items-center gap-1">
                    🕉️ Vastu Certified
                  </span>
                )}
              </div>
              <p className="text-white/90 text-lg mb-4">{agent.brokerage}</p>

              <div className="flex flex-wrap gap-6 mb-6">
                <div>
                  <div className="flex items-center gap-1">
                    <span className="text-2xl font-bold">{agent.avgRating}</span>
                    <svg className="w-6 h-6 text-yellow-300" fill="currentColor" viewBox="0 0 20 20">
                      <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z" />
                    </svg>
                  </div>
                  <p className="text-white/80 text-sm">{agent.reviewCount} reviews</p>
                </div>
                <div>
                  <p className="text-2xl font-bold">{agent.yearsExperience}+</p>
                  <p className="text-white/80 text-sm">Years Experience</p>
                </div>
                <div>
                  <p className="text-2xl font-bold">{agent.totalTransactions}</p>
                  <p className="text-white/80 text-sm">Transactions</p>
                </div>
                <div>
                  <p className="text-2xl font-bold">{agent.responseTime}</p>
                  <p className="text-white/80 text-sm">Response Time</p>
                </div>
              </div>

              <div className="flex flex-wrap gap-3">
                <button
                  onClick={() => setShowContactModal(true)}
                  className="px-6 py-3 bg-white text-orange-600 rounded-xl font-semibold hover:bg-orange-50 transition-colors"
                >
                  Contact Agent
                </button>
                <a
                  href={`tel:${agent.phone}`}
                  className="px-6 py-3 bg-white/20 backdrop-blur-sm text-white border border-white/30 rounded-xl font-semibold hover:bg-white/30 transition-colors flex items-center gap-2"
                >
                  <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 5a2 2 0 012-2h3.28a1 1 0 01.948.684l1.498 4.493a1 1 0 01-.502 1.21l-2.257 1.13a11.042 11.042 0 005.516 5.516l1.13-2.257a1 1 0 011.21-.502l4.493 1.498a1 1 0 01.684.949V19a2 2 0 01-2 2h-1C9.716 21 3 14.284 3 6V5z" />
                  </svg>
                  Call Now
                </a>
                <button className="px-6 py-3 bg-white/20 backdrop-blur-sm text-white border border-white/30 rounded-xl font-semibold hover:bg-white/30 transition-colors flex items-center gap-2">
                  <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8.684 13.342C8.886 12.938 9 12.482 9 12c0-.482-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.368 2.684 3 3 0 00-5.368-2.684z" />
                  </svg>
                  Share Profile
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>

      {/* Content */}
      <div className="max-w-7xl mx-auto px-4 py-8">
        {/* Tabs */}
        <div className="flex gap-1 p-1 bg-gray-100 rounded-xl w-fit mb-8">
          {[
            { id: 'listings', label: `Listings (${agent.listingsCount})` },
            { id: 'reviews', label: `Reviews (${agent.reviewCount})` },
            { id: 'about', label: 'About' },
          ].map((tab) => (
            <button
              key={tab.id}
              onClick={() => setActiveTab(tab.id as any)}
              className={`px-6 py-2 rounded-lg font-medium transition-all ${
                activeTab === tab.id
                  ? 'bg-white text-gray-900 shadow-sm'
                  : 'text-gray-600 hover:text-gray-900'
              }`}
            >
              {tab.label}
            </button>
          ))}
        </div>

        {/* Listings Tab */}
        {activeTab === 'listings' && (
          <div className="grid md:grid-cols-2 lg:grid-cols-3 gap-6">
            {listings.map((listing, i) => (
              <motion.div
                key={listing.id}
                initial={{ opacity: 0, y: 20 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ delay: i * 0.1 }}
              >
                <Link
                  href={`/property/${listing.id}`}
                  className="block bg-white rounded-2xl border border-gray-200 overflow-hidden hover:shadow-xl transition-all group"
                >
                  <div className="relative">
                    <img
                      src={listing.image}
                      alt={listing.title}
                      className="w-full h-48 object-cover group-hover:scale-105 transition-transform duration-300"
                    />
                    <div className="absolute top-3 left-3 flex gap-2">
                      <span className={`px-2 py-1 text-xs rounded-full ${
                        listing.status === 'ACTIVE' ? 'bg-green-500 text-white' :
                        listing.status === 'PENDING' ? 'bg-yellow-500 text-white' :
                        'bg-gray-500 text-white'
                      }`}>
                        {listing.status}
                      </span>
                      {listing.vastuScore && listing.vastuScore >= 85 && (
                        <span className="px-2 py-1 bg-orange-500 text-white text-xs rounded-full">
                          🕉️ {listing.vastuScore}%
                        </span>
                      )}
                    </div>
                  </div>
                  <div className="p-4">
                    <p className="text-xl font-bold text-gray-900">{formatPrice(listing.price)}</p>
                    <h3 className="font-semibold text-gray-900 mt-1">{listing.title}</h3>
                    <p className="text-sm text-gray-600">{listing.address}</p>
                    <div className="flex items-center gap-4 mt-3 text-sm text-gray-600">
                      <span>{listing.beds} beds</span>
                      <span>•</span>
                      <span>{listing.baths} baths</span>
                      <span>•</span>
                      <span>{listing.sqft.toLocaleString()} sqft</span>
                    </div>
                  </div>
                </Link>
              </motion.div>
            ))}
          </div>
        )}

        {/* Reviews Tab */}
        {activeTab === 'reviews' && (
          <div className="space-y-6">
            {/* Rating Summary */}
            <div className="bg-white rounded-2xl border border-gray-200 p-6">
              <div className="flex flex-col md:flex-row md:items-center gap-8">
                <div className="text-center">
                  <p className="text-5xl font-bold text-gray-900">{agent.avgRating}</p>
                  <div className="flex justify-center gap-1 my-2">
                    {[1, 2, 3, 4, 5].map((star) => (
                      <svg
                        key={star}
                        className={`w-6 h-6 ${star <= Math.round(agent.avgRating) ? 'text-yellow-400' : 'text-gray-300'}`}
                        fill="currentColor"
                        viewBox="0 0 20 20"
                      >
                        <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z" />
                      </svg>
                    ))}
                  </div>
                  <p className="text-gray-600">{agent.reviewCount} reviews</p>
                </div>
                <div className="flex-1 space-y-2">
                  {[5, 4, 3, 2, 1].map((rating) => {
                    const count = rating === 5 ? 100 : rating === 4 ? 20 : rating === 3 ? 5 : 2;
                    const percentage = (count / agent.reviewCount) * 100;
                    return (
                      <div key={rating} className="flex items-center gap-3">
                        <span className="w-3 text-sm text-gray-600">{rating}</span>
                        <svg className="w-4 h-4 text-yellow-400" fill="currentColor" viewBox="0 0 20 20">
                          <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z" />
                        </svg>
                        <div className="flex-1 h-2 bg-gray-200 rounded-full">
                          <div
                            className="h-full bg-yellow-400 rounded-full"
                            style={{ width: `${percentage}%` }}
                          />
                        </div>
                        <span className="w-8 text-sm text-gray-600">{count}</span>
                      </div>
                    );
                  })}
                </div>
              </div>
            </div>

            {/* Reviews List */}
            {reviews.map((review, i) => (
              <motion.div
                key={review.id}
                initial={{ opacity: 0, y: 20 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ delay: i * 0.1 }}
                className="bg-white rounded-2xl border border-gray-200 p-6"
              >
                <div className="flex items-start gap-4">
                  <img
                    src={review.userAvatar || `https://ui-avatars.com/api/?name=${review.userName}&size=48`}
                    alt={review.userName}
                    className="w-12 h-12 rounded-full object-cover"
                  />
                  <div className="flex-1">
                    <div className="flex items-center justify-between">
                      <div>
                        <p className="font-semibold text-gray-900">{review.userName}</p>
                        <div className="flex items-center gap-2 mt-1">
                          <div className="flex gap-0.5">
                            {[1, 2, 3, 4, 5].map((star) => (
                              <svg
                                key={star}
                                className={`w-4 h-4 ${star <= review.rating ? 'text-yellow-400' : 'text-gray-300'}`}
                                fill="currentColor"
                                viewBox="0 0 20 20"
                              >
                                <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z" />
                              </svg>
                            ))}
                          </div>
                          <span className="text-sm text-gray-500">{review.createdAt}</span>
                        </div>
                      </div>
                    </div>
                    <h4 className="font-medium text-gray-900 mt-3">{review.title}</h4>
                    <p className="text-gray-600 mt-2">{review.content}</p>
                    <div className="flex items-center gap-4 mt-4">
                      <button className="flex items-center gap-1 text-sm text-gray-500 hover:text-gray-700">
                        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M14 10h4.764a2 2 0 011.789 2.894l-3.5 7A2 2 0 0115.263 21h-4.017c-.163 0-.326-.02-.485-.06L7 20m7-10V5a2 2 0 00-2-2h-.095c-.5 0-.905.405-.905.905 0 .714-.211 1.412-.608 2.006L7 11v9m7-10h-2M7 20H5a2 2 0 01-2-2v-6a2 2 0 012-2h2.5" />
                        </svg>
                        Helpful ({review.helpful})
                      </button>
                    </div>
                  </div>
                </div>
              </motion.div>
            ))}
          </div>
        )}

        {/* About Tab */}
        {activeTab === 'about' && (
          <div className="grid lg:grid-cols-3 gap-8">
            <div className="lg:col-span-2 space-y-6">
              <div className="bg-white rounded-2xl border border-gray-200 p-6">
                <h3 className="text-lg font-semibold text-gray-900 mb-4">About {agent.firstName}</h3>
                <p className="text-gray-600 leading-relaxed">{agent.bio}</p>
              </div>

              <div className="bg-white rounded-2xl border border-gray-200 p-6">
                <h3 className="text-lg font-semibold text-gray-900 mb-4">Specializations</h3>
                <div className="flex flex-wrap gap-2">
                  {agent.specializations.map((spec) => (
                    <span key={spec} className="px-4 py-2 bg-orange-50 text-orange-700 rounded-full text-sm">
                      {spec}
                    </span>
                  ))}
                </div>
              </div>

              <div className="bg-white rounded-2xl border border-gray-200 p-6">
                <h3 className="text-lg font-semibold text-gray-900 mb-4">Service Areas</h3>
                <div className="flex flex-wrap gap-2">
                  {agent.serviceAreas.map((area) => (
                    <span key={area} className="px-4 py-2 bg-gray-100 text-gray-700 rounded-full text-sm">
                      {area}
                    </span>
                  ))}
                </div>
              </div>
            </div>

            <div className="space-y-6">
              <div className="bg-white rounded-2xl border border-gray-200 p-6">
                <h3 className="text-lg font-semibold text-gray-900 mb-4">Contact Information</h3>
                <div className="space-y-4">
                  <div className="flex items-center gap-3">
                    <div className="w-10 h-10 bg-orange-100 rounded-lg flex items-center justify-center">
                      <svg className="w-5 h-5 text-orange-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 8l7.89 5.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />
                      </svg>
                    </div>
                    <div>
                      <p className="text-sm text-gray-500">Email</p>
                      <a href={`mailto:${agent.email}`} className="text-orange-600 hover:text-orange-700">
                        {agent.email}
                      </a>
                    </div>
                  </div>
                  <div className="flex items-center gap-3">
                    <div className="w-10 h-10 bg-orange-100 rounded-lg flex items-center justify-center">
                      <svg className="w-5 h-5 text-orange-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 5a2 2 0 012-2h3.28a1 1 0 01.948.684l1.498 4.493a1 1 0 01-.502 1.21l-2.257 1.13a11.042 11.042 0 005.516 5.516l1.13-2.257a1 1 0 011.21-.502l4.493 1.498a1 1 0 01.684.949V19a2 2 0 01-2 2h-1C9.716 21 3 14.284 3 6V5z" />
                      </svg>
                    </div>
                    <div>
                      <p className="text-sm text-gray-500">Phone</p>
                      <a href={`tel:${agent.phone}`} className="text-orange-600 hover:text-orange-700">
                        {agent.phone}
                      </a>
                    </div>
                  </div>
                </div>
              </div>

              <div className="bg-white rounded-2xl border border-gray-200 p-6">
                <h3 className="text-lg font-semibold text-gray-900 mb-4">Languages</h3>
                <div className="flex flex-wrap gap-2">
                  {agent.languages.map((lang) => (
                    <span key={lang} className="px-3 py-1 bg-gray-100 text-gray-700 rounded-full text-sm">
                      {lang}
                    </span>
                  ))}
                </div>
              </div>

              <div className="bg-white rounded-2xl border border-gray-200 p-6">
                <h3 className="text-lg font-semibold text-gray-900 mb-4">License</h3>
                <p className="text-gray-600">{agent.licenseNumber}</p>
                <p className="text-sm text-gray-500 mt-1">Member since {new Date(agent.createdAt).getFullYear()}</p>
              </div>
            </div>
          </div>
        )}
      </div>

      {/* Contact Modal */}
      {showContactModal && (
        <div className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/50">
          <motion.div
            initial={{ opacity: 0, scale: 0.95 }}
            animate={{ opacity: 1, scale: 1 }}
            className="bg-white rounded-2xl w-full max-w-md p-6"
          >
            <div className="flex items-center justify-between mb-6">
              <h3 className="text-lg font-semibold text-gray-900">Contact {agent.firstName}</h3>
              <button
                onClick={() => setShowContactModal(false)}
                className="p-2 hover:bg-gray-100 rounded-lg"
              >
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                </svg>
              </button>
            </div>
            <div className="space-y-4">
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">Your Name</label>
                <input
                  type="text"
                  className="w-full px-4 py-3 border border-gray-300 rounded-xl focus:ring-2 focus:ring-orange-500 focus:border-orange-500"
                  placeholder="Enter your name"
                />
              </div>
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">Phone Number</label>
                <input
                  type="tel"
                  className="w-full px-4 py-3 border border-gray-300 rounded-xl focus:ring-2 focus:ring-orange-500 focus:border-orange-500"
                  placeholder="Enter your phone"
                />
              </div>
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">Message</label>
                <textarea
                  rows={4}
                  className="w-full px-4 py-3 border border-gray-300 rounded-xl focus:ring-2 focus:ring-orange-500 focus:border-orange-500"
                  placeholder="I'm interested in learning more about your listings..."
                />
              </div>
              <button className="w-full py-3 bg-gradient-to-r from-orange-500 to-amber-500 text-white rounded-xl font-semibold hover:from-orange-600 hover:to-amber-600 transition-all">
                Send Message
              </button>
            </div>
          </motion.div>
        </div>
      )}
    </div>
  );
}
Page · TSX
'use client';

import { useState, useEffect } from 'react';
import Link from 'next/link';
import { motion, AnimatePresence } from 'framer-motion';

interface SavedProperty {
  id: string;
  title: string;
  address: string;
  city: string;
  state: string;
  price: number;
  beds: number;
  baths: number;
  sqft: number;
  images: string[];
  status: 'ACTIVE' | 'PENDING' | 'SOLD' | 'OFF_MARKET';
  vastuScore?: number;
  daysOnMarket: number;
  priceChange?: {
    amount: number;
    type: 'increase' | 'decrease';
    date: string;
  };
  savedAt: string;
  notes?: string;
  folder?: string;
}

interface Folder {
  id: string;
  name: string;
  count: number;
  color: string;
}

export default function FavoritesPage() {
  const [properties, setProperties] = useState<SavedProperty[]>([]);
  const [folders, setFolders] = useState<Folder[]>([]);
  const [loading, setLoading] = useState(true);
  const [selectedFolder, setSelectedFolder] = useState<string | null>(null);
  const [viewMode, setViewMode] = useState<'grid' | 'list'>('grid');
  const [sortBy, setSortBy] = useState<'savedAt' | 'price' | 'vastuScore'>('savedAt');
  const [showCompare, setShowCompare] = useState(false);
  const [compareList, setCompareList] = useState<string[]>([]);
  const [editingNote, setEditingNote] = useState<string | null>(null);

  useEffect(() => {
    // Mock data
    setFolders([
      { id: 'all', name: 'All Saved', count: 12, color: 'gray' },
      { id: 'shortlist', name: 'Shortlisted', count: 4, color: 'green' },
      { id: 'visit', name: 'To Visit', count: 3, color: 'blue' },
      { id: 'compare', name: 'For Comparison', count: 5, color: 'purple' },
    ]);

    setProperties([
      {
        id: 'p1',
        title: 'Luxury Villa with Garden',
        address: '123 Palm Street',
        city: 'Whitefield',
        state: 'Karnataka',
        price: 25000000,
        beds: 5,
        baths: 4,
        sqft: 4500,
        images: ['https://images.unsplash.com/photo-1600596542815-ffad4c1539a9?w=800&h=600&fit=crop'],
        status: 'ACTIVE',
        vastuScore: 95,
        daysOnMarket: 15,
        priceChange: { amount: 1500000, type: 'decrease', date: '2024-12-15' },
        savedAt: '2024-12-10',
        notes: 'Beautiful garden, perfect for family. Need to check parking.',
        folder: 'shortlist',
      },
      {
        id: 'p2',
        title: 'Modern 3BHK Apartment',
        address: '456 Tech Park Road',
        city: 'Koramangala',
        state: 'Karnataka',
        price: 12000000,
        beds: 3,
        baths: 2,
        sqft: 1800,
        images: ['https://images.unsplash.com/photo-1560448204-e02f11c3d0e2?w=800&h=600&fit=crop'],
        status: 'ACTIVE',
        vastuScore: 88,
        daysOnMarket: 30,
        savedAt: '2024-12-05',
        folder: 'visit',
      },
      {
        id: 'p3',
        title: 'Premium Penthouse',
        address: '789 MG Road',
        city: 'Indiranagar',
        state: 'Karnataka',
        price: 35000000,
        beds: 4,
        baths: 3,
        sqft: 3200,
        images: ['https://images.unsplash.com/photo-1600607687939-ce8a6c25118c?w=800&h=600&fit=crop'],
        status: 'PENDING',
        vastuScore: 92,
        daysOnMarket: 5,
        savedAt: '2024-12-18',
        folder: 'shortlist',
      },
      {
        id: 'p4',
        title: 'Vastu-Compliant Bungalow',
        address: '321 Lake View',
        city: 'HSR Layout',
        state: 'Karnataka',
        price: 18000000,
        beds: 4,
        baths: 3,
        sqft: 2800,
        images: ['https://images.unsplash.com/photo-1613490493576-7fde63acd811?w=800&h=600&fit=crop'],
        status: 'ACTIVE',
        vastuScore: 98,
        daysOnMarket: 20,
        savedAt: '2024-12-01',
        folder: 'compare',
      },
    ]);

    setLoading(false);
  }, []);

  const formatPrice = (price: number) => {
    if (price >= 10000000) {
      return `₹${(price / 10000000).toFixed(2)} Cr`;
    } else if (price >= 100000) {
      return `₹${(price / 100000).toFixed(2)} L`;
    }
    return `₹${price.toLocaleString()}`;
  };

  const filteredProperties = selectedFolder && selectedFolder !== 'all'
    ? properties.filter(p => p.folder === selectedFolder)
    : properties;

  const sortedProperties = [...filteredProperties].sort((a, b) => {
    if (sortBy === 'price') return b.price - a.price;
    if (sortBy === 'vastuScore') return (b.vastuScore || 0) - (a.vastuScore || 0);
    return new Date(b.savedAt).getTime() - new Date(a.savedAt).getTime();
  });

  const toggleCompare = (id: string) => {
    if (compareList.includes(id)) {
      setCompareList(compareList.filter(i => i !== id));
    } else if (compareList.length < 4) {
      setCompareList([...compareList, id]);
    }
  };

  const removeFromFavorites = (id: string) => {
    setProperties(properties.filter(p => p.id !== id));
  };

  if (loading) {
    return (
      <div className="flex items-center justify-center min-h-[400px]">
        <div className="w-12 h-12 border-4 border-orange-500 border-t-transparent rounded-full animate-spin" />
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
        <div>
          <h1 className="text-2xl font-bold text-gray-900">Saved Properties</h1>
          <p className="text-gray-600">{properties.length} properties saved</p>
        </div>
        <div className="flex gap-3">
          {compareList.length > 1 && (
            <button
              onClick={() => setShowCompare(true)}
              className="px-4 py-2 bg-gradient-to-r from-orange-500 to-amber-500 text-white rounded-xl font-medium hover:from-orange-600 hover:to-amber-600"
            >
              Compare ({compareList.length})
            </button>
          )}
          <Link
            href="/search"
            className="px-4 py-2 border border-gray-300 rounded-xl font-medium text-gray-700 hover:bg-gray-50"
          >
            Find More
          </Link>
        </div>
      </div>

      {/* Folders */}
      <div className="flex gap-3 overflow-x-auto pb-2">
        {folders.map((folder) => (
          <button
            key={folder.id}
            onClick={() => setSelectedFolder(folder.id === 'all' ? null : folder.id)}
            className={`flex items-center gap-2 px-4 py-2 rounded-xl whitespace-nowrap transition-all ${
              (selectedFolder === folder.id) || (!selectedFolder && folder.id === 'all')
                ? 'bg-orange-500 text-white'
                : 'bg-white border border-gray-200 text-gray-700 hover:border-orange-300'
            }`}
          >
            <span>{folder.name}</span>
            <span className={`px-2 py-0.5 rounded-full text-xs ${
              (selectedFolder === folder.id) || (!selectedFolder && folder.id === 'all')
                ? 'bg-white/20'
                : 'bg-gray-100'
            }`}>
              {folder.count}
            </span>
          </button>
        ))}
        <button className="flex items-center gap-2 px-4 py-2 border border-dashed border-gray-300 rounded-xl text-gray-500 hover:border-orange-300 hover:text-orange-500 whitespace-nowrap">
          <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
          </svg>
          New Folder
        </button>
      </div>

      {/* Controls */}
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-4">
          <select
            value={sortBy}
            onChange={(e) => setSortBy(e.target.value as any)}
            className="px-4 py-2 border border-gray-300 rounded-xl focus:ring-2 focus:ring-orange-500 focus:border-orange-500"
          >
            <option value="savedAt">Recently Saved</option>
            <option value="price">Price (High to Low)</option>
            <option value="vastuScore">Vastu Score</option>
          </select>
        </div>
        <div className="flex items-center gap-2 bg-gray-100 p-1 rounded-xl">
          <button
            onClick={() => setViewMode('grid')}
            className={`p-2 rounded-lg transition-all ${viewMode === 'grid' ? 'bg-white shadow-sm' : 'text-gray-500'}`}
          >
            <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2V6zM14 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V6zM4 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2v-2zM14 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z" />
            </svg>
          </button>
          <button
            onClick={() => setViewMode('list')}
            className={`p-2 rounded-lg transition-all ${viewMode === 'list' ? 'bg-white shadow-sm' : 'text-gray-500'}`}
          >
            <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6h16M4 10h16M4 14h16M4 18h16" />
            </svg>
          </button>
        </div>
      </div>

      {/* Properties Grid/List */}
      {sortedProperties.length === 0 ? (
        <div className="text-center py-12 bg-white rounded-2xl border border-gray-200">
          <div className="w-16 h-16 bg-gray-100 rounded-full flex items-center justify-center mx-auto mb-4">
            <svg className="w-8 h-8 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z" />
            </svg>
          </div>
          <h3 className="text-lg font-semibold text-gray-900 mb-2">No saved properties</h3>
          <p className="text-gray-600 mb-4">Start saving properties you love to see them here</p>
          <Link
            href="/search"
            className="inline-flex items-center gap-2 px-6 py-3 bg-gradient-to-r from-orange-500 to-amber-500 text-white rounded-xl font-medium"
          >
            Browse Properties
          </Link>
        </div>
      ) : viewMode === 'grid' ? (
        <div className="grid md:grid-cols-2 lg:grid-cols-3 gap-6">
          <AnimatePresence>
            {sortedProperties.map((property, i) => (
              <motion.div
                key={property.id}
                initial={{ opacity: 0, y: 20 }}
                animate={{ opacity: 1, y: 0 }}
                exit={{ opacity: 0, scale: 0.95 }}
                transition={{ delay: i * 0.05 }}
                className="bg-white rounded-2xl border border-gray-200 overflow-hidden group"
              >
                <div className="relative">
                  <Link href={`/property/${property.id}`}>
                    <img
                      src={property.images[0]}
                      alt={property.title}
                      className="w-full h-48 object-cover group-hover:scale-105 transition-transform duration-300"
                    />
                  </Link>
                  
                  {/* Status Badge */}
                  <div className="absolute top-3 left-3 flex gap-2">
                    <span className={`px-2 py-1 text-xs rounded-full ${
                      property.status === 'ACTIVE' ? 'bg-green-500 text-white' :
                      property.status === 'PENDING' ? 'bg-yellow-500 text-white' :
                      property.status === 'SOLD' ? 'bg-red-500 text-white' :
                      'bg-gray-500 text-white'
                    }`}>
                      {property.status}
                    </span>
                    {property.vastuScore && property.vastuScore >= 90 && (
                      <span className="px-2 py-1 bg-orange-500 text-white text-xs rounded-full">
                        🕉️ {property.vastuScore}%
                      </span>
                    )}
                  </div>

                  {/* Price Change Badge */}
                  {property.priceChange && (
                    <div className="absolute top-3 right-3">
                      <span className={`px-2 py-1 text-xs rounded-full ${
                        property.priceChange.type === 'decrease' ? 'bg-green-500' : 'bg-red-500'
                      } text-white flex items-center gap-1`}>
                        {property.priceChange.type === 'decrease' ? '↓' : '↑'}
                        {formatPrice(property.priceChange.amount)}
                      </span>
                    </div>
                  )}

                  {/* Actions */}
                  <div className="absolute bottom-3 right-3 flex gap-2 opacity-0 group-hover:opacity-100 transition-opacity">
                    <button
                      onClick={() => toggleCompare(property.id)}
                      className={`p-2 rounded-lg backdrop-blur-sm transition-colors ${
                        compareList.includes(property.id)
                          ? 'bg-orange-500 text-white'
                          : 'bg-white/90 text-gray-700 hover:bg-white'
                      }`}
                    >
                      <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" />
                      </svg>
                    </button>
                    <button
                      onClick={() => removeFromFavorites(property.id)}
                      className="p-2 bg-white/90 rounded-lg backdrop-blur-sm text-red-500 hover:bg-white"
                    >
                      <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
                        <path d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z" />
                      </svg>
                    </button>
                  </div>
                </div>

                <div className="p-4">
                  <div className="flex items-center justify-between mb-1">
                    <p className="text-xl font-bold text-gray-900">{formatPrice(property.price)}</p>
                    <span className="text-xs text-gray-500">{property.daysOnMarket} days</span>
                  </div>
                  <Link href={`/property/${property.id}`}>
                    <h3 className="font-semibold text-gray-900 hover:text-orange-600 transition-colors">{property.title}</h3>
                  </Link>
                  <p className="text-sm text-gray-600">{property.address}, {property.city}</p>
                  
                  <div className="flex items-center gap-4 mt-3 text-sm text-gray-600">
                    <span>{property.beds} beds</span>
                    <span>•</span>
                    <span>{property.baths} baths</span>
                    <span>•</span>
                    <span>{property.sqft.toLocaleString()} sqft</span>
                  </div>

                  {/* Notes */}
                  {editingNote === property.id ? (
                    <div className="mt-3">
                      <textarea
                        defaultValue={property.notes}
                        className="w-full px-3 py-2 text-sm border border-gray-300 rounded-lg focus:ring-2 focus:ring-orange-500 focus:border-orange-500"
                        rows={2}
                        placeholder="Add a note..."
                      />
                      <div className="flex gap-2 mt-2">
                        <button
                          onClick={() => setEditingNote(null)}
                          className="px-3 py-1 text-sm bg-orange-500 text-white rounded-lg"
                        >
                          Save
                        </button>
                        <button
                          onClick={() => setEditingNote(null)}
                          className="px-3 py-1 text-sm text-gray-600 hover:text-gray-900"
                        >
                          Cancel
                        </button>
                      </div>
                    </div>
                  ) : property.notes ? (
                    <div
                      onClick={() => setEditingNote(property.id)}
                      className="mt-3 p-2 bg-yellow-50 border border-yellow-100 rounded-lg text-sm text-gray-700 cursor-pointer hover:bg-yellow-100 transition-colors"
                    >
                      📝 {property.notes}
                    </div>
                  ) : (
                    <button
                      onClick={() => setEditingNote(property.id)}
                      className="mt-3 text-sm text-gray-500 hover:text-orange-600"
                    >
                      + Add note
                    </button>
                  )}
                </div>
              </motion.div>
            ))}
          </AnimatePresence>
        </div>
      ) : (
        <div className="space-y-4">
          <AnimatePresence>
            {sortedProperties.map((property, i) => (
              <motion.div
                key={property.id}
                initial={{ opacity: 0, x: -20 }}
                animate={{ opacity: 1, x: 0 }}
                exit={{ opacity: 0, x: 20 }}
                transition={{ delay: i * 0.05 }}
                className="bg-white rounded-2xl border border-gray-200 overflow-hidden flex group"
              >
                <Link href={`/property/${property.id}`} className="flex-shrink-0">
                  <img
                    src={property.images[0]}
                    alt={property.title}
                    className="w-48 h-full object-cover group-hover:scale-105 transition-transform duration-300"
                  />
                </Link>
                <div className="flex-1 p-4">
                  <div className="flex items-start justify-between">
                    <div>
                      <div className="flex items-center gap-3 mb-1">
                        <p className="text-xl font-bold text-gray-900">{formatPrice(property.price)}</p>
                        {property.priceChange && (
                          <span className={`text-sm ${property.priceChange.type === 'decrease' ? 'text-green-600' : 'text-red-600'}`}>
                            {property.priceChange.type === 'decrease' ? '↓' : '↑'} {formatPrice(property.priceChange.amount)}
                          </span>
                        )}
                        <span className={`px-2 py-0.5 text-xs rounded-full ${
                          property.status === 'ACTIVE' ? 'bg-green-100 text-green-700' :
                          property.status === 'PENDING' ? 'bg-yellow-100 text-yellow-700' :
                          'bg-gray-100 text-gray-700'
                        }`}>
                          {property.status}
                        </span>
                      </div>
                      <Link href={`/property/${property.id}`}>
                        <h3 className="font-semibold text-gray-900 hover:text-orange-600">{property.title}</h3>
                      </Link>
                      <p className="text-sm text-gray-600">{property.address}, {property.city}</p>
                      <div className="flex items-center gap-4 mt-2 text-sm text-gray-600">
                        <span>{property.beds} beds</span>
                        <span>•</span>
                        <span>{property.baths} baths</span>
                        <span>•</span>
                        <span>{property.sqft.toLocaleString()} sqft</span>
                        {property.vastuScore && (
                          <>
                            <span>•</span>
                            <span className="text-orange-600">🕉️ {property.vastuScore}% Vastu</span>
                          </>
                        )}
                      </div>
                    </div>
                    <div className="flex items-center gap-2">
                      <button
                        onClick={() => toggleCompare(property.id)}
                        className={`p-2 rounded-lg transition-colors ${
                          compareList.includes(property.id)
                            ? 'bg-orange-500 text-white'
                            : 'bg-gray-100 text-gray-600 hover:bg-gray-200'
                        }`}
                      >
                        <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" />
                        </svg>
                      </button>
                      <button
                        onClick={() => removeFromFavorites(property.id)}
                        className="p-2 bg-gray-100 rounded-lg text-red-500 hover:bg-red-50"
                      >
                        <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
                          <path d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z" />
                        </svg>
                      </button>
                    </div>
                  </div>
                  {property.notes && (
                    <div className="mt-3 p-2 bg-yellow-50 rounded-lg text-sm text-gray-700">
                      📝 {property.notes}
                    </div>
                  )}
                </div>
              </motion.div>
            ))}
          </AnimatePresence>
        </div>
      )}

      {/* Compare Modal */}
      <AnimatePresence>
        {showCompare && compareList.length > 1 && (
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            className="fixed inset-0 z-50 bg-black/50 flex items-center justify-center p-4"
          >
            <motion.div
              initial={{ scale: 0.95 }}
              animate={{ scale: 1 }}
              exit={{ scale: 0.95 }}
              className="bg-white rounded-2xl w-full max-w-6xl max-h-[90vh] overflow-auto"
            >
              <div className="sticky top-0 bg-white border-b border-gray-200 p-6 flex items-center justify-between">
                <h2 className="text-xl font-bold text-gray-900">Compare Properties</h2>
                <button
                  onClick={() => setShowCompare(false)}
                  className="p-2 hover:bg-gray-100 rounded-lg"
                >
                  <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                  </svg>
                </button>
              </div>
              <div className="p-6">
                <div className="overflow-x-auto">
                  <table className="w-full">
                    <thead>
                      <tr>
                        <th className="text-left p-4 bg-gray-50">Feature</th>
                        {compareList.map(id => {
                          const p = properties.find(prop => prop.id === id);
                          if (!p) return null;
                          return (
                            <th key={id} className="p-4 bg-gray-50 min-w-[200px]">
                              <img src={p.images[0]} alt={p.title} className="w-full h-32 object-cover rounded-lg mb-2" />
                              <p className="font-semibold text-gray-900">{p.title}</p>
                            </th>
                          );
                        })}
                      </tr>
                    </thead>
                    <tbody>
                      {[
                        { label: 'Price', key: 'price', format: (v: number) => formatPrice(v) },
                        { label: 'Bedrooms', key: 'beds' },
                        { label: 'Bathrooms', key: 'baths' },
                        { label: 'Square Feet', key: 'sqft', format: (v: number) => v.toLocaleString() },
                        { label: 'Vastu Score', key: 'vastuScore', format: (v: number) => v ? `${v}%` : 'N/A' },
                        { label: 'Days on Market', key: 'daysOnMarket' },
                        { label: 'Status', key: 'status' },
                      ].map(row => (
                        <tr key={row.key} className="border-b">
                          <td className="p-4 font-medium text-gray-700">{row.label}</td>
                          {compareList.map(id => {
                            const p = properties.find(prop => prop.id === id);
                            if (!p) return null;
                            const value = (p as any)[row.key];
                            return (
                              <td key={id} className="p-4 text-center">
                                {row.format ? row.format(value) : value}
                              </td>
                            );
                          })}
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
              </div>
            </motion.div>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
}

